<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>学成在线项目介绍</title>
    <url>/posts/42876.html</url>
    <content><![CDATA[<h1>学成在线</h1>
<h4 id="介绍">介绍</h4>
<p>本项目基于<strong>黑马程序员</strong>的 <em>《学成在线》</em> 项目搭建 仅供学习参考<br>
在线教育行业是一个有着极强的广度和深度的行业，从校内到校外；从早幼教到职业培训；从教育工具到全信息化平台等等。</p>
<p>学成在线项目是本公司自研的一个专门针对成人职业技能教育的网络课堂系统，网站提供了成人职业技能培训的相关课程，如：软件开发培训、职业资格证书培训、成人学历教育培训等课程。项目基于B2B2C的业务模式，培训机构可以在平台入驻、发布课程，运营人员对发布的课程进行审核，审核通过后课程才可以发布成功，课程包括免费和收费两种形式，对于免费课程可以直接选课学习，对于收费课程在选课后需要支付成功才可以继续学习。</p>
<span id="more"></span>
<h4 id="软件架构">软件架构</h4>
<p>本项目包括了用户端、机构端、运营端。</p>
<p>核心模块包括：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等。</p>
<p>下图是项目的功能模块图：</p>
<img src="https://xuecheng-rzf.oss-cn-beijing.aliyuncs.com/gitee_readme/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%9B%BE.png" style="zoom:150%;" />
<p>本项目采用前后端分离架构，后端采用SpringBoot、SpringCloud技术栈开发，数据库使用了MySQL，还使用的Redis、消息队列、分布式文件系统、Elasticsearch等中间件系统。</p>
<p>划分的微服务包括：内容管理服务、媒资管理服务、搜索服务、订单支付服务、 学习中心服务、系统管理服务、认证授权服务、网关服务、注册中心服务、配置中心服务等。</p>
<p>下图是项目的技术架构图：</p>
<img src="https://xuecheng-rzf.oss-cn-beijing.aliyuncs.com/gitee_readme/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%9B%BE.png" style="zoom:150%;" />
<h4 id="安装教程">安装教程</h4>
<ol>
<li>项目基于JDK1.8环境开发，使用Mavne构建项目工程</li>
</ol>
<h4 id="使用说明">使用说明</h4>
<ol>
<li>
<p>教学机构的老师登录教学管理平台，编辑课程信息，发布自己的课程。</p>
</li>
<li>
<p>平台运营人员登录运营平台审核课程、视频等信息，审核通过后课程方可发布。</p>
</li>
<li>
<p>课程发布后学生登录平台进行选课、在线学习。免费课程可直接学习，收费课程需要下单购买。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>博客config配置</title>
    <url>/posts/8702.html</url>
    <content><![CDATA[<p>初始配置文件（config那个没有别的后缀）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment"># 网站显示的标题 随意填</span></span><br><span class="line"><span class="attr">author:</span> <span class="comment"># 你的名字 随意填</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:username/username.github.io.git</span>  <span class="comment"># 要是GitHub改名了，记得这里改一下</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span> <span class="comment"># 仓库名称</span></span><br></pre></td></tr></table></figure>
<p>主题配置文件常见配置（我所有是butterflyx主题）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Avatar (头像设置)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span>  <span class="comment"># url</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Favicon（网站的图标）</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/myFavicon.png</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/img/***.***</span>  <span class="comment"># 默认封面 对应文档的cover参数 可以是GIF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Menu 目錄</span></span><br><span class="line"><span class="attr">menu:</span> <span class="comment"># 右上角的选项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---     </span></span><br><span class="line"><span class="comment"># Sponsor/reward</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">text:</span></span><br><span class="line">  <span class="attr">QR_code:</span> <span class="comment">#二维码设置</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/***.png</span></span><br><span class="line">       <span class="attr">link:</span> <span class="comment"># 链接</span></span><br><span class="line">       <span class="attr">text:</span> <span class="comment"># 图片下面显示的文本</span></span><br><span class="line">       </span><br><span class="line"> <span class="string">---</span></span><br><span class="line"><span class="comment"># 网站优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_ribbon:  背景彩帶设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mouse click effects 鼠标点击效果设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Loading Animation (加载动画设置)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建的一些问题汇总</category>
      </categories>
      <tags>
        <tag>butterflyx主题</tag>
        <tag>博客搭建</tag>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>创建特殊文档</title>
    <url>/posts/15129.html</url>
    <content><![CDATA[<p>创建分类总览页代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>创建标签总览页代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>创建About总览页代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：</p>
<p>网址路径结尾是“/”的话 会自动加载对应目录的index.html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">也就是  http://localhost:4000/tags/ 加载的是tags目录下的index.html 而不是tags.html </span><br></pre></td></tr></table></figure>
<p>上面前两个文档文件需要手动生成，但里面的内容会自动生成 。</p>
]]></content>
      <categories>
        <category>博客搭建的一些问题汇总</category>
      </categories>
      <tags>
        <tag>butterflyx主题</tag>
        <tag>博客搭建</tag>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>文档上的注释</title>
    <url>/posts/33714.html</url>
    <content><![CDATA[<p>Front-matter 采用 YAML  格式</p>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: # 标题</span><br><span class="line">date: # 日期</span><br><span class="line">tags: # 标签</span><br><span class="line">- </span><br><span class="line">categories: # 分类</span><br><span class="line">-</span><br><span class="line">cover: /img/***.jpg # 封面 相对路径或者使用网址</span><br><span class="line">indexing: false #  生成的搜素（此功能需要手动开启）结果将不包含此帖子或页面</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>可以参考<a href="https://hexo.io/zh-cn/docs/front-matter">官方文档</a></p>
<p><strong>注意事项</strong>：</p>
<p>title 不建议写中文或者网站采用hash算法（避免网址中文乱码）</p>
<p>采用hash算法设置（主路径下的_config配置中的下面位置）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://***.github.io</span></span><br><span class="line"><span class="comment"># 改这里 原先是 :year/:month/:day/:title/ -&gt; :year/:month/:day/:hash/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:hash/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>小技巧</strong>：</p>
<p>微软输入法快速输入日期的方法：</p>
<p>可以去右下角输入法的地方右键点击设置 --&gt; 找到词库 --&gt; 然后添加自定义短语 --&gt;</p>
<p>关键词自己定义  映射短语设置：%yyyy%-%MM%-%dd% %HH%:%mm%:%ss%</p>
<p>就可以快速输入时间了</p>
]]></content>
      <categories>
        <category>博客搭建的一些问题汇总</category>
      </categories>
      <tags>
        <tag>butterflyx主题</tag>
        <tag>博客搭建</tag>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>本地与云端不一致</title>
    <url>/posts/41171.html</url>
    <content><![CDATA[<p><strong>前面碰到过地测试正常但是上传后的页面错误</strong></p>
<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">前者清除站点文件，后者重新生成并将之推送到指定的库分支。</span><br></pre></td></tr></table></figure>
<p>**建议每次更新都需要hexo clean **</p>
<p>当然<strong>游览器缓存</strong>也可能是一个问题，不过过一会就会正常。</p>
]]></content>
      <categories>
        <category>博客搭建的一些问题汇总</category>
      </categories>
      <tags>
        <tag>butterflyx主题</tag>
        <tag>博客搭建</tag>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐书籍</title>
    <url>/posts/62923.html</url>
    <content><![CDATA[<p>记录一下一些我看完的书籍，以后有空的话可能会写写推荐语什么的♪(´▽｀)嘿嘿</p>
<p>排名不分先后，后面是推荐指数：</p>
<h3 id="历史："><strong>历史</strong>：</h3>
<p>《全球通史》（推荐指数★★★★★⚝，个人觉得上册比较好看 ）</p>
<p>《人类的故事》（推荐指数★★★★★⚝，书不是很枯燥，值得一看 ）</p>
<p>《红星照耀中国》（推荐指数★★★★⚝⚝）</p>
<p>《人类简史》（太久之前看的，不太记得了ψ(._. )&gt;暂时：★★★★⚝⚝）</p>
<h3 id="经济，政治，心理："><strong>经济</strong>，政治，心理：</h3>
<p>《乌合之众》（推荐指数★★★★★⚝）</p>
<p>《娱乐至死》（推荐指数★★★★★⚝）</p>
<p>《极简主义》（推荐指数★★★⚝⚝⚝）</p>
<p>《工作，消费主义和新穷人》（推荐指数★★★★★⚝）</p>
<h3 id="文学："><strong>文学</strong>：</h3>
<p>《1984》（值得细细回味，另外，他的一个短篇小说《动物庄园》）（推荐指数★★★★★★）</p>
<p>《局外人》（推荐指数★★★★★⚝）</p>
<p>《老人与海》（推荐指数★★★★★★）</p>
<p>《野性的呼唤》（推荐指数★★★★★★）</p>
<p>《牧羊少年奇幻之旅》（推荐指数★★★★★★，“马克图布” ）</p>
<p>《钢铁是怎样炼成的》（推荐指数★★★★★★）</p>
<p>《一个人的朝圣》（推荐指数★★★★★★）</p>
<p>《苏菲的世界》（推荐指数★★★★★⚝）</p>
<p>《西游记》《水浒传》（推荐指数★★★★★★）</p>
<p>《我是猫》（推荐指数★★★★⚝⚝）</p>
<p>《杀死一只知更鸟》（推荐指数★★★★★⚝）</p>
<h3 id="计算机相关："><strong>计算机相关</strong>：</h3>
<p>《Java并发编程的艺术》（推荐指数★★★★⚝⚝）</p>
<p>《Spring实战》（推荐指数★★★★⚝⚝）</p>
<p>《redis设计与实战》（推荐指数★★★★⚝⚝）</p>
<h3 id="其它：">其它：</h3>
<p>《催眠师手记》（推荐指数★★★★★★）</p>
<p>《天才在左，疯子在右》（推荐指数★★★★★★）</p>
<p>《三体》（推荐指数★★★★★★）</p>
<p>《福尔摩斯》（推荐指数★★★★★★）</p>
<p>《人生的智慧》（推荐指数★★★★★⚝）</p>
<p>《契诃夫小说集》（推荐指数★★★★★★）</p>
<h3 id=""></h3>
]]></content>
      <categories>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐关注</title>
    <url>/posts/22031.html</url>
    <content><![CDATA[<p>B站</p>
<p><strong>老陌Ss</strong> UID：1343324216</p>
<p><strong>左神（左程云）的算法课</strong> （我个人认为最好的算法课没有之一）</p>
<p><strong>极海Channel</strong> UID：1525355</p>
<p><strong>我的B站号</strong></p>
<p><strong>长夜有晨星</strong> UID：95747099</p>
]]></content>
      <categories>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>推荐</tag>
        <tag>博主</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排</title>
    <url>/posts/40634.html</url>
    <content><![CDATA[<p><strong>一个比较经典的的排序算法</strong></p>
<h2 id="堆排的由来">堆排的由来</h2>
<p>堆排序（英语：Heapsort）是指利用二叉堆这种数据结构所设计的一种排序算法。由罗伯特·弗洛伊德发明。<br>
罗伯特·弗洛伊德：<br>
计算机科学家，<a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E5%A5%96/324645?fromModule=lemma_inlink">图灵奖</a>得主，前后断言法的<a href="https://baike.baidu.com/item/%E5%88%9B%E5%A7%8B%E4%BA%BA/36538?fromModule=lemma_inlink">创始人</a>，<a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/0?fromModule=lemma_inlink">堆排序</a>算法和<a href="https://baike.baidu.com/item/Floyd-Warshall%E7%AE%97%E6%B3%95/9705345?fromModule=lemma_inlink">Floyd-Warshall算法</a>的创始人之一。[1]</p>
<h2 id="基本原理">基本原理</h2>
<p><strong>堆（特指大根堆）<strong>是一种特殊的</strong>二叉树</strong>，在堆的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0?fromModule=lemma_inlink">数据结构</a>中，堆中的<strong>最大值总是位于根节点。</strong><br>
<strong>堆排</strong>就是用<strong>数组</strong>存储堆的结构（<strong>层序遍历</strong>）并进行排序</p>
<p>如果<strong>初始索引是0</strong> 那么可以看出一个节点的<strong>左孩子索引</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2*N+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><strong>右孩子索引</strong> 为 <strong>左孩子索引</strong> <strong>+1</strong></p>
<p><strong>父节点索引</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[(index - 1) / 2]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mclose">]</span></span></span></span></span></p>
<p>然后对数组进行如下过程定义：</p>
<ol>
<li>
<p><strong>heapinsert：向堆中插入数据，并保持堆的特性</strong></p>
</li>
<li>
<p><strong>heapify：移除堆顶元素（即最大值），再重新组织堆的特性</strong></p>
</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<p><strong>heapinsert：向堆中插入数据，并保持堆的特性</strong></p>
<p>因为前面的数组 已经调整好了，当我们插入尾部后只要比父节点大就往上移，同时与父节点的交换并不会影响下面的子节点的堆特性（因为父节点相对于子节点本来就是最大的）<br>
（是一个从下往上的过程）</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapinsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="comment">//只要大于原先父节点就往上跳</span></span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        TestMachine.swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>heapify：移除堆顶元素（即最大值），再放入一个新值，再重新堆化</p>
<p>移除时只需要把堆的最后一个元素（即数组对应的索引）与堆顶的元素交换，对所用堆元素进行heapify过程，就可以实现数组的从小到大的排序（是一个从上往下的过程）</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index 当前索引（传入0） size 堆的规模</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">//左孩子的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//没有越界就继续</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">        <span class="comment">//右孩子的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//需要交换的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">exchange</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size) </span><br><span class="line">            <span class="comment">//没有越界就继续</span></span><br><span class="line">            exchange =</span><br><span class="line">            	<span class="comment">//右边是不是大于当前位置</span></span><br><span class="line">                arr[right] &gt; arr[index] ?      </span><br><span class="line">                        ( <span class="comment">//是 判断左边是否更大</span></span><br><span class="line">                                arr[right] &gt; arr[left] ? right : left </span><br><span class="line">                        )</span><br><span class="line">                        :</span><br><span class="line">                        ( <span class="comment">//不是 判断左边是否比当前位置大</span></span><br><span class="line">                                arr[left] &gt; arr[index] ? left : index</span><br><span class="line">                        );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; arr[index]) </span><br><span class="line">            <span class="comment">//右边越界判断左边是否是大于</span></span><br><span class="line">            exchange = left;</span><br><span class="line">        <span class="comment">//如果exchange改变则交换</span></span><br><span class="line">        <span class="keyword">if</span> (exchange != index) &#123;</span><br><span class="line">            <span class="comment">//数组对应的索引进行交换</span></span><br><span class="line">            TestMachine.swap(arr, exchange, index);</span><br><span class="line">            index = exchange;<span class="comment">//当前指针记录进行下一次heapify</span></span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>; <span class="comment">//计算左孩子的索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//没有改变 则堆的结构已经改变完成 退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个排序的算法</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || arr.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(N*logN) 可以优化</span></span><br><span class="line">    <span class="comment">//数组进行堆化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;<span class="comment">//O(N)</span></span><br><span class="line">        heapinsert(arr, i);<span class="comment">//O(logN)</span></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//开始排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    TestMachine.swap(arr, <span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//第一个数（最大值 ）移除 对剩余数据进行heapify 重新进行堆化 </span></span><br><span class="line">        <span class="comment">// 重复过程直到全部排序完成</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        TestMachine.swap(arr, <span class="number">0</span>, --len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化">优化</h2>
<p><strong>对上面的数组堆话过程可以继续进行优化</strong></p>
<p><strong>由于每次heapinsert都是一个logN的过程（即树的高度）</strong> 也就是<strong>时间复杂度O(N*logN)</strong></p>
<p>而如果我们<strong>从下往上</strong>来进行数组堆化</p>
<p>也就是修改成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="comment">//数组进行堆化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    heapify(arr, i, arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这些代码每一层（堆中）复杂度都是递增的</strong><br>
但上面的代码是<strong>从上往下</strong>也就是<strong>底下数据量越多而且越复杂</strong><br>
而优化后是<strong>从下往上</strong>也就是<strong>越往上越复杂 但数据量也越少</strong></p>
<p><strong>复杂度O(N)的证明：</strong></p>
<p>由于二叉树的特性 每层节点的heapify过程最多走层高 而每层节点的个数也可以通过二叉树的性质求出</p>
<p>所以从底层加到顶层的次数：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>∗</mo><mn>1</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>2</mn></msup></mfrac><mo>∗</mo><mn>2</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>3</mn></msup></mfrac><mo>∗</mo><mn>3</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>4</mn></msup></mfrac><mo>∗</mo><mn>4</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">S_n=\frac {N}{2}*1 + \frac {N}{2^2}*2 + \frac {N}{2^3}*3 + \frac {N}{2^4}*4 + ......
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.1056em;"></span><span class="mord">......</span></span></span></span></span></p>
<p>令</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo>∗</mo><mn>2</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>1</mn></msup></mfrac><mo>∗</mo><mn>2</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>2</mn></msup></mfrac><mo>∗</mo><mn>3</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>3</mn></msup></mfrac><mo>∗</mo><mn>4</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">2S_n=\frac {N}{2}*2 + \frac {N}{2^1}*2 + \frac {N}{2^2}*3 + \frac {N}{2^3}*4 + ......
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.1056em;"></span><span class="mord">......</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><msub><mi>S</mi><mi>n</mi></msub><mo>−</mo><msub><mi>S</mi><mi>n</mi></msub><mo>=</mo><mi>N</mi><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>1</mn></msup></mfrac><mo>∗</mo><mn>1</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>2</mn></msup></mfrac><mo>∗</mo><mn>1</mn><mo>+</mo><mfrac><mi>N</mi><msup><mn>2</mn><mn>3</mn></msup></mfrac><mo>∗</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">2S_n-S_n=N+\frac {N}{2^1}*1 + \frac {N}{2^2}*1 + \frac {N}{2^3}*1 + ......
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.1056em;"></span><span class="mord">......</span></span></span></span></span></p>
<p>后面就是一个等比数列求和（且q=1/2）由于时间复杂度<strong>只取高次</strong>位得<strong>复杂度O(N)</strong></p>
<h2 id="总结">总结</h2>
<p>时间复杂度的函数为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*log(N))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">))</span></span></span></span></span></p>
<p>空间复杂度 有限几个变量</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>由于堆的特性数据是无法保存顺序的所以是一个不稳定的排序算法</p>
<h2 id="每日一句">每日一句</h2>
<p>如果印钞票能消除贫困的话，那么印文凭也就可以消除愚蠢了。——阿根廷总统 哈维尔·米莱</p>
<h2 id="参考">参考</h2>
<ol>
<li>百度百科</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>经典</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/posts/123.html</url>
    <content><![CDATA[<p><strong>一个比较经典的的排序算法</strong></p>
<h2 id="快速排序的由来">快速排序的由来</h2>
<p>快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称「快排」</p>
<p>英国计算机科学家Tony Hoare在1960年为了解决计算机上的排序问题，提出了快速排序的算法，最初是为了在英国的英尔兰电子公司（ELLIOTT Brothers）的快速硬件上实现高效的排序算法。[1]</p>
<h2 id="基本原理">基本原理</h2>
<p>快速排序的工作原理是通过递归中的<strong>分治</strong>思想的方式来将一个数组排序。</p>
<ol>
<li>
<p>从待排序的数组中选择一个元素，称之为枢纽元（pivot）。</p>
</li>
<li>
<p>将数组中小于枢纽元的元素移到枢纽元的左边，将大于枢纽元的元素移到枢纽元的右边，这个过程称为分区（partition）。</p>
</li>
<li>
<p>递归地对枢纽元左边的子数组和右边的子数组进行排序。</p>
</li>
<li>
<p>当所有子数组都有序时，整个数组就自然有序了。</p>
</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<p>整个流程最重要的就是<strong>partition过程</strong>了：</p>
<p>从待排序的数组中选择一个元素当作基准；</p>
<p>左右分别设置一个指针（也就是小于和大于那个基准的范围）；</p>
<p>再建立一个当前指针进行遍历：</p>
<p>当大于基准时：当前位置与左边界的前一个交换，左边界右移加一，当前指针++；</p>
<p>当小于基准时：当前位置与右边界的前一个交换，右边界左移减一，当前指针++；</p>
<p>当等于基准时：当前指针++；</p>
<p>接着对两边的数组在进行<strong>partition过程</strong>，相当于进行<strong>递归调用</strong></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> num) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; num) &#123;</span><br><span class="line">                swap(arr, i, right - <span class="number">1</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; num) &#123;</span><br><span class="line">                swap(arr, i, left + <span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == num) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回左右边界 下次递归需要使用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left + <span class="number">1</span>, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//数组元素交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="随即快排（优化）">随即快排（优化）</h2>
<p>但是num的选择有一点讲究，</p>
<p>如果我们每次都选固定的位置会造成：数据情况会对时间复杂度造成影响</p>
<p>比如 <strong>1，2，3，4，5，6，7，8，9</strong> 这样的数据</p>
<p>那每次我们都选<strong>最后一个做基准</strong>就会发现每次只能排好最后一个数</p>
<p>时间复杂度将<strong>退化为N平方</strong></p>
<p>所以我们引入一个随机快排的概念，即随机选一个数做基准，经过概率计算得出期望时间复杂度的函数为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N*log(N)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || arr.length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">       <span class="type">int</span>[] partition = partition(arr, l, r);</span><br><span class="line">      	<span class="comment">//对两边的数组在进行partition过程，递归调用</span></span><br><span class="line">       quickSort(arr, l, partition[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">       quickSort(arr, partition[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">       <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">       <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> l - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> r;</span><br><span class="line">       <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">       <span class="comment">//随机选值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> random.nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">       <span class="comment">//放到最后 避免影响排序</span></span><br><span class="line">       swap(arr, randomNum, r);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt; right; ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] &gt; arr[r]) swap(arr, i, --right);</span><br><span class="line">           <span class="keyword">if</span> (arr[i] &lt; arr[r]) swap(arr, i++, ++left);</span><br><span class="line">           <span class="keyword">if</span> (arr[i] == arr[r]) i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//选的值进行插入</span></span><br><span class="line">       swap(arr, right, r);</span><br><span class="line">       <span class="comment">//返回左右边界 下次递归需要使用</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left + <span class="number">1</span>, right&#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素交换</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">       arr[i] = arr[i] ^ arr[j];</span><br><span class="line">       arr[j] = arr[i] ^ arr[j];</span><br><span class="line">       arr[i] = arr[i] ^ arr[j];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当然实际 排序时可以<strong>根据数据情况</strong>来进行选择使用排序方式</p>
<p>如短数据采用插入排序等；</p>
<h2 id="总结">总结</h2>
<p>时间复杂度的函数为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*log(N))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">))</span></span></span></span></span></p>
<p>空间复杂度 即递归栈的空间复杂度</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(N))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">))</span></span></span></span></span></p>
<p>由于随机选择的特性不能保证原先的顺序所以是一个不稳定的排序算法</p>
<h2 id="每日一句">每日一句</h2>
<p><em><strong>多数人在25岁时就死了，一直到75岁才埋葬   —— 富兰克林</strong></em> [2]</p>
<h2 id="参考">参考</h2>
<ol>
<li>Wiki百科</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>经典</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法大总结</title>
    <url>/posts/6666.html</url>
    <content><![CDATA[<h1><em>简单的排序：</em>*</h1>
<h2 id="选择排序"><strong>选择排序</strong></h2>
<h2 id="插入排序"><strong>插入排序</strong></h2>
<h2 id="冒泡排序"><strong>冒泡排序</strong></h2>
<h3 id="时间复杂度"><strong>时间复杂度</strong></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="空间复杂度："><strong>空间复杂度：</strong></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<h1><strong>经典的排序：</strong></h1>
<h3 id="时间复杂度-2"><strong>时间复杂度</strong></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*log(N))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">))</span></span></span></span></span></p>
<h2 id="快排："><a href="https://stars-at-dawn.github.io/posts/123.html"><strong>快排：</strong></a></h2>
<h3 id="无稳定性（指是否能保留原来的顺序）"><strong>无稳定性</strong>（<strong>指是否能保留原来的顺序</strong>）</h3>
<h3 id="快排空间复杂度："><strong>快排空间复杂度：</strong></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="堆排："><a href="https://stars-at-dawn.github.io/posts/40634.html"><strong>堆排：</strong></a></h2>
<h3 id="无稳定性"><strong>无稳定性</strong></h3>
<h3 id="堆排空间复杂度："><strong>堆排空间复杂度：</strong></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="归并排序："><a href="(https://stars-at-dawn.github.io/posts/7.html)"><strong>归并排序：</strong></a></h2>
<h3 id="有稳定性"><strong>有稳定性</strong></h3>
<h3 id="归并排序空间复杂度："><strong>归并排序空间复杂度：</strong></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<h1><strong>其它 根据实际条件限制的排序算法：</strong></h1>
<h2 id="桶排"><strong>桶排</strong></h2>
<h2 id="基数排序"><strong>基数排序</strong></h2>
<h3 id="时间复杂度-3"><strong>时间复杂度</strong></h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>经典</tag>
      </tags>
  </entry>
  <entry>
    <title>打印汉诺塔过程</title>
    <url>/posts/11859.html</url>
    <content><![CDATA[<p><strong>用代码实现 打印汉诺塔最优解的过程</strong></p>
<p>废话少说咱们直接开始(‾◡◝)</p>
<p>首先先来看看汉诺塔问题的定义：</p>
<p>汉诺塔（Tower of Hanoi），又称河内塔，是一个源于<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%8D%B0%E5%BA%A6/121904%3FfromModule%3Dlemma_inlink">印度</a>古老传说的<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%9B%8A%E6%99%BA%E7%8E%A9%E5%85%B7/223159%3FfromModule%3Dlemma_inlink">益智玩具</a>。大<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%A2%B5%E5%A4%A9/2453640%3FfromModule%3Dlemma_inlink">梵天</a>创造世界的时候做了三根<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%87%91%E5%88%9A%E7%9F%B3/80698%3FfromModule%3Dlemma_inlink">金刚石</a>柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550%3FfromModule%3Dlemma_inlink">大梵天</a>命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。[<a href="https://www.zhihu.com/people/10-16-96-85/posts#ref_1">1]</a></p>
<p>那我们简化一下问题：变成三个圆盘，毕竟我们也买不起这么多黄金圆盘</p>
<p>（才不是我懒~(￣▽￣)~*）</p>
<p>如图我们要移动三个圆盘到最边上，而且小圆盘上不能放大圆盘</p>
<p><img src="https://pic3.zhimg.com/80/v2-be4e82ef46d6c2569a68d49a34311806_1440w.webp" alt="img"></p>
<p>那我们分析要让所用圆盘移到右边，很显然根据规则可以知道<strong>最下面的圆盘</strong>肯定要<strong>先移到最右边</strong>，不然移动别的大的就放不下了；</p>
<p>同时也可以看出：</p>
<p>要让最下面的圆盘移到最右边，就要让<strong>它上面的圆盘移到中间</strong>（就像把大象塞进冰箱要怎么办的问题一样）</p>
<p>顺着思路也就可以分析它上面的圆盘移到中间的问题，如果把<strong>中间的杆子当成右边的（即目标杆）</strong>，那问题就变成两层的汉诺塔问题了（底层的那个金盘你会发现有没有都无所谓），那就很显然是一个递归问题了，下面直接写代码（本文采用java）：</p>
<p>（写递归就写过程，不要去太纠结结果）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让所用圆盘移到右边    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">leftToRight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//basecase</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;move&quot;</span> + n + <span class="string">&quot;left to right&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        leftToMid(n - <span class="number">1</span>);<span class="comment">//让它上面的圆盘移到中间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;move&quot;</span> + n + <span class="string">&quot;left to right&quot;</span>);</span><br><span class="line">        midToRight(n - <span class="number">1</span>);<span class="comment">//让它上面的圆盘从中间移到右边完成整个过程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同理写出 leftToMid(n -1) midToRight(n -1)的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">leftToMid</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;move&quot;</span> + n + <span class="string">&quot;left to mid&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       leftToRight(n - <span class="number">1</span>);<span class="comment">//都是一样的</span></span><br><span class="line">       System.out.println(<span class="string">&quot;move&quot;</span> + n + <span class="string">&quot;left to mid&quot;</span>);</span><br><span class="line">       rightToMid(n - <span class="number">1</span>);<span class="comment">//完成整个过程</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rightToMid</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;move&quot;</span> + n + <span class="string">&quot;right to mid&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       rightToLeft(n - <span class="number">1</span>);<span class="comment">//都是一样的</span></span><br><span class="line">       System.out.println(<span class="string">&quot;move&quot;</span> + n + <span class="string">&quot;right to mid&quot;</span>);</span><br><span class="line">       leftToMid(n - <span class="number">1</span>);<span class="comment">//完成整个过程</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其它的从左从中间。。。我想应该不用我写了把（才不是我懒o(^▽^)o）</p>
<p>但这么长显然代码并不好看，而且能发现递归过程有大量共性，考虑优化一下</p>
<p>将当前位置和目标位置抽象出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前位置和目标位置 还有剩余位置抽象出来   </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fromTo</span><span class="params">(String from, String other, String to, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;move&quot;</span> + n + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fromTo(from, to, other, n - <span class="number">1</span>);<span class="comment">//other 和 to交换位置 代表当前圆盘的上面的圆盘移到剩余位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;move&quot;</span> + n + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">        fromTo(other, from, to, n - <span class="number">1</span>);<span class="comment">//代表当前圆盘的上面的圆盘移到目标位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>大功告成，我相信你也对递归有了更好的理解了吧</p>
<p>不过有个小彩蛋，那就是你会发现这个递归次数成指数增长</p>
<p><strong>因为</strong>从递归式可以看出</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(n)=2f(n-1)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>推出----&gt;</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)+1=2(f(n)+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>k</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k(n)=2k(n-1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>有了<strong>递推式</strong>就可以写出 <strong>f(n)</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(n)=k(n)-1=2^n-1 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7977em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>也就是n层汉诺塔至少需要这么多步</p>
<p>也就是说<strong>64片黄金</strong>圆盘需要移动 <strong>18446744073709551615</strong>次？？？那故事里的金盘移动完怕不是地球都没了</p>
<p>( ‵▽′)ψ</p>
<p>（ps：第一次写，如果有什么不好的欢迎指出( •̀ ω •́ )y）下次见</p>
<p>每日一句：</p>
<p>上善若水，水善利万物而不争。[<a href="https://www.zhihu.com/people/10-16-96-85/posts#ref_2">2]</a></p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://www.zhihu.com/people/10-16-96-85/posts#ref_1_0">^</a>百度百科</li>
<li><a href="https://www.zhihu.com/people/10-16-96-85/posts#ref_2_0">^</a>老子《道德经》</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
        <tag>汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title>合并排序</title>
    <url>/posts/7.html</url>
    <content><![CDATA[<p><strong>一个比较经典的的排序算法</strong></p>
<h2 id="合并排序的由来">合并排序的由来</h2>
<p><strong>归并排序</strong>（Merge Sort）是建立在归并操作上的一种有效，稳定的<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5399605?fromModule=lemma_inlink">排序算法</a>，该算法是采用<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fromModule=lemma_inlink">分治法</a>（Divide and Conquer）的一个非常典型的应用。发明者<a href="https://baike.baidu.com/item/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC/8790674?fromModule=lemma_inlink">约翰·冯·诺伊曼</a>[1]</p>
<h2 id="基本原理">基本原理</h2>
<p>将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且原问题相同。递归地解这些子问题，然后将各子问题的解合并得到原问题的解。</p>
<p>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
<p>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
<p>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
<p>重复步骤3直到某一指针超出序列尾</p>
<p>将另一序列剩下的所有元素直接复制到合并序列尾[1]</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="递归版本">递归版本</h3>
<p>最重要的就是<strong>合并（merge）过程</strong></p>
<p>我们需要两边数组的范围进行合并排序<br>
代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//l左起点 r右边界 mid左边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] arrHelp = <span class="keyword">new</span> <span class="title class_">int</span>[length];<span class="comment">//存放排序的数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//拷贝计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">//右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> l; <span class="comment">//左指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= r) &#123;</span><br><span class="line">            arrHelp[index++] = </span><br><span class="line">                <span class="comment">//那边数组小 拷贝 指针加一</span></span><br><span class="line">                arr[left] &lt; arr[right] ? arr[left++] : arr[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">//右数组空了 左数组剩下的全部拷贝</span></span><br><span class="line">            arrHelp[index++] = arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= r) &#123;</span><br><span class="line">             <span class="comment">//左数组空了 同理</span></span><br><span class="line">            arrHelp[index++] = arr[right++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">            arr[i] = arrHelp[i - l]; <span class="comment">//拷贝到原数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>递归调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (l == r) <span class="keyword">return</span>; <span class="comment">//basecase</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//防止数据越界的求中值的写法</span></span><br><span class="line">  	<span class="comment">//等于 （l + r）/2</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//排序左边</span></span><br><span class="line">      mergeSort(arr, l, mid);</span><br><span class="line">      <span class="comment">//排序右边</span></span><br><span class="line">      mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">      <span class="comment">//左右合并</span></span><br><span class="line">      merge(arr, l, r, mid);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归版本（优化空间复杂度）">非递归版本（优化空间复杂度）</h3>
<p>当然递归的版本空间复杂度不好所以进行优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">//if (arr.length == 0) return;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">mergeSize</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//开始范围大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; arr.length) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始位置</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + mergeSize - <span class="number">1</span>;<span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">if</span> (mid &gt;= arr.length) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.min(mid + mergeSize, arr.length - <span class="number">1</span>);<span class="comment">//右边界</span></span><br><span class="line">            merge(arr, L, R, mid);<span class="comment">//合并排序</span></span><br><span class="line">            L = R + <span class="number">1</span>;<span class="comment">//下一个mergeSize</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止下面的翻倍溢出</span></span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; arr.length / <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSize &lt;&lt;= <span class="number">1</span>;<span class="comment">//Size翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>时间复杂度的函数为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N*log(N))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">))</span></span></span></span></span></p>
<p>空间复杂度 即需要一个相同大小的临时数组</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p>拷贝的时候可以保证相等是先拷贝左再拷贝右 所以是稳定的排序算法</p>
<h2 id="每日一句">每日一句</h2>
<p><strong><em>凭君莫话封候事，一将功成万骨枯</em> ————<a href="https://baike.baidu.com/item/%E6%9B%B9%E6%9D%BE/52063?fromModule=lemma_inlink">曹松</a>《己亥岁二首》</strong></p>
<h2 id="参考">参考</h2>
<ol>
<li>百度百科</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>经典</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>经典</tag>
      </tags>
  </entry>
</search>
