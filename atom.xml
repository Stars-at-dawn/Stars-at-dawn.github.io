<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晨星的博客</title>
  
  
  <link href="https://stars-at-dawn.github.io/atom.xml" rel="self"/>
  
  <link href="https://stars-at-dawn.github.io/"/>
  <updated>2025-06-07T01:57:19.539Z</updated>
  <id>https://stars-at-dawn.github.io/</id>
  
  <author>
    <name>长夜有晨星</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL相关知识点</title>
    <link href="https://stars-at-dawn.github.io/posts/mysql"/>
    <id>https://stars-at-dawn.github.io/posts/mysql</id>
    <published>2025-06-07T01:57:17.000Z</published>
    <updated>2025-06-07T01:57:19.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL知识点">MySQL知识点</h2><p><strong><span id="MySQL">MySQL</span></strong></p><ul><li><strong>存储引擎</strong><ul><li><strong>InnoDB</strong>（ 默认引擎，<strong>支持外键；支持事务；支持在线热备份</strong>）</li><li><strong>MyISAM</strong>（<strong>不支持外键、事务和在线热备份；不支持行锁，只支持表锁；支持压缩表和空间数据索引</strong>）</li><li><strong>Memory</strong>（存在<strong>内存中</strong> 一但机器重启 数据会丢失）</li><li><strong>MERGE</strong>（用于一系列<strong>MyISAM表</strong>以逻辑方式<strong>组合</strong>在一起，作为一个对象去引用。（相当于union all））</li></ul></li><li><strong>事务的四大特性</strong><ul><li><strong>原子性</strong>：所有操作<strong>要么全部成功，要么全部回滚</strong></li><li><strong>一致性</strong>：事务<strong>执行前和执行后必须处于一致性状态</strong></li><li><strong>隔离性</strong>：并发访问数据时，多个<strong>事务互相不干扰</strong></li><li><strong>持久性</strong>：事务一旦提交，<strong>对数据库的更改就是永久</strong>的</li></ul></li><li><strong>事务会出现的问题</strong><ul><li><strong>脏读</strong>：指的是当前事务可以读取到另外事务未提交的数据。</li><li><strong>不可重复读</strong>：同一事务内多次读取同一数据集合，读取到的数据是不一样的情况。</li><li><strong>幻影读</strong>：同一事务连续执行两次同样的 sql 语句，第二次的 sql 语句可能会返回之前不存在的行（<strong>特殊的不可重复读问题</strong>）</li></ul></li><li><strong>四种事务隔离级别</strong><ul><li><strong>未提交读（READ UNCOMMITTED）</strong><ul><li>事务中的修改，即使没有提交，对其他事务也是可见的。</li><li>会出现如下问题：<strong>脏读不可重复读幻读</strong></li></ul></li><li><strong>提交读RC（READ COMMITTED）</strong><ul><li>一个事务所做的修改在提交之前对其他事务是不可见的。</li><li>会出现如下问题：<strong>不可重复读幻读</strong></li></ul></li><li><strong>可重复读RR（REPEATABLE READ）</strong><ul><li>保证在同一个事务中多次读取同样数据的结果是一样的。</li><li>会出现如下问题：<strong>幻读</strong></li></ul></li><li><strong>可串行化（SERIALIZABLE）</strong><ul><li>强制事务串行执行。</li><li>没有问题</li></ul></li></ul></li><li><strong>锁</strong><ul><li><strong>行锁 和 表锁</strong><ul><li><strong>行锁</strong><ul><li><strong>记录锁</strong> （锁定一个记录上的索引，而不是记录本身）</li><li><strong>间隙锁</strong>（锁定索引之间的间隙，但是不包含索引本身）</li><li><strong>临键锁</strong>（它是前两者的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙）</li></ul></li><li><strong>表锁</strong>（<strong>意向锁</strong>（意向共享锁 意向排他锁 共享意向排他锁））</li></ul></li><li><strong>排他锁 和 共享锁</strong><ul><li><strong>排他锁</strong>（其它事务想要读取或者写入一行数据，要等待事务释放锁）<strong>意向排他锁</strong>（获取多个排他锁）</li><li><strong>共享锁</strong>（其它事务只能并行读取一行数据）<strong>意向共享锁</strong>（读取多行数据）</li></ul></li></ul></li><li><strong>事务的实现</strong><ul><li><strong>MVCC</strong>（多版本并发控制）（用于实现<strong>提交读</strong>和<strong>可重复读</strong>这两种隔离级别）<ul><li><strong>相关概念</strong>：<ul><li><strong>版本号</strong>（<strong>系统版本号，事务版本号</strong>）：每有一个事务，系统版本号就会加1；事务版本号指当前事务的版本。</li><li><strong>隐藏的列</strong>：每行记录都有两个<strong>隐藏的列</strong> 存储 <strong>创建版本号</strong> 和 <strong>回滚指针</strong></li><li><strong>Undo 日志</strong>：<strong>快照存储在 Undo 日志中</strong>，通过<strong>回滚指针</strong>把一个数据行的所有快照连接起来</li></ul></li><li><strong>实现可重复读隔离级别</strong>（此时的事务版本号大于所有数据快照的创建版本号）<ul><li><strong>SELECT</strong>：必须读取<strong>小于等于当前事务版本</strong>的数据行快照。<br><strong>INSERT</strong>：将当前系统版本号作为数据行快照的创建版本号。<br><strong>DELETE</strong>：将当前系统版本号作为数据行快照的删除版本号。<br><strong>UPDATE</strong>：将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</li><li><strong>快照读</strong>（读取的是历史数据）：MVCC 的 <strong>SELECT</strong> 操作是<strong>快照中的数据</strong>（所以<strong>不用加锁</strong>）RC中每次都会生成快照</li><li><strong>当前读</strong>（读取的是数据库当前版本的数据）：<br>MVCC 对修改操作（<strong>INSERT、UPDATE、DELETE</strong>）<strong>加锁</strong>，读取<strong>最新的数据</strong>。</li><li><strong>SELECT 操作的不可重复读问题通过 MVCC 得到了解决</strong><br><strong>UPDATE、DELETE 的不可重复读问题通过 记录锁 解决</strong><br><strong>INSERT 的不可重复读问题是通过 临键锁（记录锁 + 间隙锁）解决的。</strong></li></ul></li></ul></li></ul></li><li><strong>索引</strong><ul><li><strong>数据结构</strong>：<strong>B+ Tree</strong>（Balance Tree <strong>平衡树</strong>也是一棵<strong>查找树</strong>，所有叶子节点位于同一层）<ul><li>B+树是B树的一种变形，它是基于B树和叶子节点顺序访问指针进行实现的</li><li><strong>B+非叶子节点不存储数据</strong>，只存储<strong>索引</strong>，<strong>数据都存在叶子节点</strong></li><li><strong>B树</strong>的实现特性：<strong>AVL树，红黑树，跳表</strong></li><li><strong>B+树</strong>能更好的<strong>支持范围查询</strong></li></ul></li><li>InnoDB 的 B+Tree 索引分为<strong>主索引</strong>和<strong>辅助索引</strong><ul><li><strong>主索引</strong>的叶子节点 data 域<strong>记录着完整的数据记录</strong>，这种索引方式被称为<strong>聚簇索引</strong>。</li><li><strong>辅助索引</strong>的叶子节点的 data 域<strong>记录着主键的值</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找，这个过程也被称作<strong>回表</strong>。</li></ul></li><li><strong>哈希索引</strong>：以 O(1) 时间进行查找，但是失去了有序性，无法用于排序、分组和范围查找。</li><li><strong>索引失效</strong>：<ul><li>在进行查询时，<strong>索引列不能是表达式的一部分</strong>，也<strong>不能是函数的参数</strong>，否则无法使用索引。</li></ul></li><li><strong>索引优化：</strong><ul><li><strong>让选择性（区分度）最强的索引列放在前面</strong>。</li><li><strong>前缀索引</strong>（对于 <strong>BLOB、TEXT 和 VARCHAR</strong> 类型的列，必须使用<strong>前缀索引</strong>，只<strong>索引开始的部分字符</strong>。）</li><li><strong>索引覆盖</strong>（索引<strong>包含所有</strong>需要查询的字段的值，则<strong>无需</strong>访问主索引（<strong>回表操作</strong>））</li><li><strong>尽量减少请求的数据量</strong>（只返回必要的列和行）</li><li><strong>将大查询分割</strong></li><li>查询<strong>模糊匹配优化</strong><ul><li><strong>索引下推（ICP）</strong>（只能<strong>用于二级索引</strong>）（核心思想是<strong>将部分过滤条件下推到存储引擎层</strong>）<br>允许 MySQL 在<strong>存储引擎层</strong>（如 InnoDB）直接<strong>利用索引来过滤数据</strong>，而<strong>不是</strong>将所有数据行<strong>全部返回到服务器层</strong>再进行过滤。<strong>减少</strong>从存储引擎到服务器层的<strong>数据传输量</strong>，从而提高查询效率。</li></ul></li><li><strong>最左匹配原则：</strong><br>最左匹配原则要求查询条件必须<strong>从复合索引的最左列开始匹配</strong>，才能有效利用索引</li></ul></li><li>索引<strong>不适合的场景</strong>：<ul><li><strong>数据量过少</strong></li><li><strong>表数据需要频繁的插入删除</strong></li><li><strong>字段区分度很低</strong></li></ul></li><li><strong>索引的优点</strong>：<ul><li>最重要的就是<strong>大大减少了要扫描的数据行</strong></li><li>同时<strong>避免服务器进行排序操作</strong>（索引本身是有序的）</li><li>将<strong>随机I/O</strong>读取变成<strong>顺序I/O</strong>读取（索引中的相邻数据会存储在一起）</li></ul></li></ul></li><li><strong>explain 分析 Select语句</strong></li><li><strong>分库分表数据切分</strong><ul><li><strong>水平切分</strong>：将同一个表中的记录<strong>拆分</strong>到多个<strong>结构相同</strong>的表中。</li><li><strong>垂直切分</strong>：将一张表按列分成多个表，通常是按照<strong>列的关系</strong>（或热度）密集程度进行<strong>切分</strong></li></ul></li><li><strong>主从复制</strong>：binlog 线程、I/O 线程和 SQL 线程。<ul><li><strong>binlog 线程</strong> ：负责将<strong>主服务器</strong>上的数据更改<strong>写入日志</strong>（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上<strong>读取日志</strong>，并<strong>写入从服务器</strong>的<strong>中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并<strong>在从服务器中重放（Replay）</strong>。</li></ul></li><li><strong>读写分离</strong>：<strong>主服务器</strong>处理<strong>写操作</strong>以及<strong>实时性要求比较高的读操作</strong>，而<strong>从服务器</strong>处理<strong>读操作</strong>。</li><li>一句SQL语句的执行过程<ul><li>首先客户端<strong>发送请求</strong>到服务端，<strong>建立连接</strong>。</li><li>服务端先看下<strong>查询缓存</strong>，对于更新某张表的SQL，该表的所有查询缓存都失效。（MySQL8.0取消）</li><li>接着来到<strong>解析器</strong>，进行<strong>语法分析</strong>，一些系统关键字校验，校验语法是否合规。</li><li>然后<strong>优化器</strong>进行<strong>SQL优化</strong>，比如怎么选择索引之类，然后生成执行计划。</li><li><strong>执行引擎去存储引擎查询需要更新的数据</strong>。</li><li>存储引擎判断当前缓冲池中是否存在需要更新的数据，存在就直接返回，否则去从磁盘加载数据。</li><li><strong>执行引擎调用存储引擎API去更新数据</strong>。</li><li>存储引擎<strong>更新数据</strong>，同时<strong>写入undo_log、redo_log信息</strong>。</li><li><strong>执行引擎写binlog</strong>，<strong>提交事务</strong>，流程<strong>结束</strong>。</li></ul></li><li>SQL优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL知识点&quot;&gt;MySQL知识点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;MySQL&quot;&gt;MySQL&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储引擎&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;InnoDB</summary>
      
    
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/categories/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    <category term="MySQL" scheme="https://stars-at-dawn.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关知识点</title>
    <link href="https://stars-at-dawn.github.io/posts/spring"/>
    <id>https://stars-at-dawn.github.io/posts/spring</id>
    <published>2025-06-07T01:52:49.000Z</published>
    <updated>2025-06-07T01:55:42.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring知识点">Spring知识点</h2><ul><li><strong><span id="Spring源码">Spring框架</span></strong><ul><li><p><strong>依赖注入</strong>，<strong>控制反转</strong>的介绍</p><ul><li><strong>控制反转</strong>指的是一个<strong>过程</strong>，将<strong>原本对象自己控制的依赖关系变成外部容器来进行控制</strong>。</li><li><strong>依赖注入</strong>是它的<strong>实现方式</strong>，Spring容器通过构造函数或者setter方法将依赖关系注入到对象中</li></ul></li><li><p><strong>Bean</strong>的<strong>注入方式</strong></p><ul><li><strong>引导加载方式</strong>：通过<strong>Xml文件</strong>或者<strong>Java注解</strong>（@Bean注解）来实现</li><li><strong>自动配置</strong>：即<br><strong>①自动装配</strong>（声明<strong>setter方法</strong>，<strong>@Autowired</strong> 根据类进行匹配，多个则根据名字匹配（设置**@Qualifier<strong>注解可以指定Bean的名称）（设置</strong>required<strong>参数可以让其在找不到时</strong>不报错**），<strong>@Resouce JDK提供的</strong> 查找方式反一下）（在Bean上使用**@Primary<strong>注解可以设置多个匹配时的</strong>主类**。）<br><strong>②组件扫描</strong>（@ComponentScan注解 默认会在当前包路径下扫描）</li><li><strong>自动装配的过程</strong>：再<strong>创建上下文时进行注册Bean定义</strong>，在<strong>Bean的实例化时进行解析</strong>（根据注解类型来选择执行Bean的后置处理器进行解析）</li></ul></li><li><p><strong>Spring IoC容器加载的流程</strong></p><ul><li>注册容器时，会先<strong>注册启动配置类</strong>，然后调用<strong>refresh()<strong>方法</strong>启动容器</strong></li><li><strong>准备初始化</strong>，对其<strong>设置启动日期和状态标志以及初始化监听器容器</strong>等</li><li><strong>初始化Bean工厂</strong>，<strong>加载Bean定义</strong>，<strong>为其设置</strong>类加载器，添加后置处理器，注册系统环境等<strong>必要组件</strong></li><li><strong>postProcessBeanFactory()<strong>留给</strong>子类</strong>的钩子方法，用来<strong>对工厂后处理</strong>，<strong>然后实例化并调用</strong>所有的<strong>工厂后置处理器</strong>。<ul><li><strong>为什么先加载</strong>工厂后置处理器：因为<strong>Bean定义在IoC容器加载时会先进行注册</strong>，而工厂后置处理器要对加载完的Bean定义进行<strong>扩展</strong>用的，所以要先加载。（比如<strong>解析配置类</strong>的<strong>Bean工厂后置处理器</strong>）</li></ul></li><li><strong>国际化消息的相关支持方法</strong>（默认的消息器会将消息传给父类（如果有的话），本身无实际作用）</li><li>初始化Spring容器的<strong>事件广播器</strong>（以支持事件监听）（如果用户<strong>未定义</strong>自己的广播器，则会<strong>创建一个默认的</strong>）。</li><li><strong>onRefresh()<strong>留给子类的</strong>钩子方法</strong>，用以<strong>注册特殊的Bean</strong>等（<strong>如Spring Boot在此注册Servlet容器</strong>）</li><li>注册<strong>事件监听器</strong>，将它们<strong>加入到刚才的事件广播器中</strong>。</li><li><strong>实例化Bean</strong>。</li><li><strong>创建容器完成，发布最终事件。</strong></li></ul></li><li><p>容器加载过程的<strong>扩展点</strong>：postProcessBeanFactory方法，onRefresh()方法</p></li><li><p><strong>Spring启动过程相关的扩展点：</strong></p><ul><li><strong>钩子方法</strong></li><li><strong>Bean工厂加载</strong>过程：<strong>Bean工厂后置处理器，Bean定义后置处理器，环境后置处理器</strong></li><li><strong>ImportSelector接口</strong>返回一个类全限定名称的数组集合，Spring会根据这个数组解析Bean定义</li><li><strong>ImportBeanDefinitionRegistrar接口</strong>，提供Bean定义的注册器，由用户将Bean定义传入</li><li><strong>Bean的加载</strong>过程：<br><strong>① Aware接口</strong>（设置<strong>Bean名字，类加载器，Bean工厂</strong>的方法）。<br><strong>② Bean的后置处理器</strong>（<strong>Bean初始化的前后</strong>进行调用）。<br><strong>③ InitializingBean接口</strong>，在<strong>Bean初始化后</strong>调用。<br><strong>④ @PostConstruct注解</strong>，在<strong>Bean初始化后</strong>调用。<br><strong>⑤ 使用init-method声明了初始化方法</strong>，在<strong>Bean初始化后</strong>调用。<br><strong>⑥ DisposableBean接口</strong>，在<strong>Bean销毁后</strong>调用。<br><strong>⑦ @PreDestroy，在Bean销毁后调用</strong>。<br><strong>⑧ 使用destory-method 声明销毁方法</strong>，在Bean销毁后调用。<br><strong>⑨ FactoryBean</strong>接口：自定义Bean的创建逻辑。</li><li><strong>监听器扩展</strong>，监听Spring中发布的相关事件</li><li><strong>ApplicationRunner / CommandLineRunner接口</strong>，在<strong>上下文刷新后</strong>提供扩展点（Spring Boot）</li></ul></li><li><p><strong>Bean的加载过程</strong></p><ul><li>先判断<strong>Bean是否为单例模式</strong>或者实现了<strong>SmartFactoryBean接口</strong>（FactoryBean的扩展接口）</li><li>判断成功，会去<strong>一二级缓存中找</strong>，找到则返回，如果<strong>三级缓存</strong>中有值，则调用缓存中的工厂方法创建Bean<strong>返回</strong>，如果都没有，则继续执行。</li><li>执行<strong>Bean实例化</strong>后将Bean包装成一个工厂<strong>加入三级缓存</strong></li><li>根据Bean定义<strong>反射</strong>调用<strong>setter方法</strong>进行<strong>属性注入</strong>（此时会实例化别的Bean）<ul><li>如果又再次回到开头，则会调用三级缓存的工厂方法，返回实例化的对象</li></ul></li><li>相关属性注入完成，再次<strong>去一二缓存中找</strong>（没有三），防止重复创建动态代理</li><li>如果没有，则开始<strong>进行初始化流程</strong>，调用相关扩展接口<strong>加入到一级缓存</strong></li></ul></li><li><p><strong>三级缓存</strong>的作用<br><strong>一级缓存</strong>：保存<strong>创建好的Bean</strong><br><strong>二级缓存</strong>：存储已经<strong>实例化但尚未完成初始化的Bean</strong><br><strong>三级缓存</strong>：存储的是<strong>早期的对象工厂</strong></p><ul><li><strong>二级缓存行不行</strong>？<br><strong>Spring中的三级缓存是为了AOP服务的</strong>，如果实现AOP则从<strong>三级缓存</strong>中<strong>拿到</strong>的实例化对象是<strong>AOP代理对象</strong>，如果使用<strong>二级缓存</strong>，则需要在<strong>注入属性时直接注入代理类</strong>，这<strong>不符合Bean的生命周期</strong>，Bean的AOP创建应在<strong>初始化后调用AOP的后置处理器创建代理</strong>。</li><li><strong>多例Bean无法进行循环依赖</strong>：依赖循环没有出口，因为每次都会创建实例。</li><li><strong>构造函数无法进行循环依赖</strong>（Spring无法直接解决）：<br>构造器注入，会在通过构造函数实例化时就直接注入属性<br>此时可以加上**@Lazy注解**，让其注入时<strong>返回一个空对象</strong>，跳出依赖循环即可。</li><li><strong>Bean的并发创建</strong>：<strong>双重检查锁</strong><br><strong>在第一次查找缓存时，会对二三级缓存上锁</strong>（一级缓存不上锁，是为了<strong>减少性能影响</strong>），等线程创建完成对象<strong>加入一级缓存后</strong>，<strong>锁会被释放</strong>，同时唤醒后的线程因为找不到缓存（一级缓存已经找过了），则执行后面的逻辑，在依赖注入完成后，会<strong>再次上锁查找缓存</strong>（名字的由来），<strong>避免重复创建</strong>。</li></ul></li><li><p><strong>加载第三方的Bean：</strong></p><ul><li><strong>@Bean的方式来配置第三方类</strong><br><strong>@Import直接导入类的方式</strong></li></ul></li><li><p><strong>FactoryBean</strong>的作用以及原理</p><ul><li>它是一个接口，其中的<strong>getObject方法</strong>就是用来获取其产生的对象（且是<strong>懒加载</strong>的）</li></ul></li><li><p>Spring相关的重要注解</p><ul><li>常见注解的功能</li></ul></li><li><p><strong>Spring AOP</strong>（运行时增强）（常见的还有AspectJ AOP （编译时增强））</p><ul><li>实现方式：<strong>JDK（针对接口的实现类）<strong>和</strong>CGLib（生成子类去重写）</strong><br>在<strong>配置类中通过注解开启AOP支持</strong>（可以在此处<strong>设置在线程中暴露代理对象</strong>参数，这样就可以<strong>通过AOP的上下文拿到</strong>当前增强的对象，防止出现本<strong>类方法互相调用时AOP失效</strong>问题。）</li><li>具体使用<br><strong>①基于接口的配置。</strong><br><strong>②@AspectJ注解配置。</strong><br>③AspectJ直接实现。</li><li><strong>实现原理</strong>：基于<strong>动态代理</strong>，代理类会封装目标类，并<strong>拦截</strong>被通知的方法的调用，<strong>执行切面</strong>逻辑，再将调用<strong>转发给目标类</strong>。采用责任链的设计模式。<br>当配置类<strong>设置AOP启动参数</strong>，会<strong>注入一个AOP的Bean后置处理器</strong>，在<strong>初始化前会解析切面注解</strong>并缓存，<strong>初始化后</strong>会拿到之前的缓存，<strong>判断</strong>是否被切点命中，<strong>创建代理</strong>。</li><li>失效的原因：<br><strong>–类内部调用方法</strong>失效（<strong>设置线程暴露参数</strong>，或者直接<strong>注入本类，然后调用</strong>）<br>–方法是<strong>private或者static</strong>（无法继承，实际上<strong>除了public都不行</strong>）<br>–目标类没有配置为Bean</li></ul></li><li><p><strong>事务</strong></p><ul><li><strong>四大特性：</strong><br><strong>原子性</strong>：所有操作<strong>要么全部成功，要么全部回滚</strong><br><strong>一致性</strong>：事务<strong>执行前和执行后必须处于一致性状态</strong><br><strong>隔离性</strong>：并发访问数据时，多个<strong>事务互相不干扰</strong><br><strong>持久性</strong>：事务一旦提交，<strong>对数据库的更改就是永久</strong>的</li><li><strong>实现方式</strong>（<strong>编程式事务管理</strong>（编程的方式，灵活但难维护）和<strong>声明式事务管理</strong>（注解或xml配置，清晰方便））<ul><li><strong>传播行为</strong><br>事务的传播行为指的是<strong>当一个事务方法调用另一个事务方法</strong>时，这个事务应该如何运行。<br>通过设置注解中的<strong>propagation</strong>参数，常见有三种：<br><strong>默认的</strong>：<strong>无事务</strong>调用时会<strong>开启新事务</strong>，<strong>有事务</strong>调用时会<strong>融合</strong>外部事务（适合<strong>增删改</strong>）<br><strong>SUPPORTS</strong>：<strong>无事务</strong>调用<strong>不开启</strong>事务，<strong>有事务</strong>调用时会<strong>融合</strong>外部事务（适合<strong>查询</strong>）<br><strong>REQUIRES_NEW</strong>：<strong>无事务</strong>调用和<strong>有事务</strong>调用都会<strong>开启新事务</strong>（<strong>日志</strong>等）</li><li><strong>隔离级别</strong><br>依赖数据库的<strong>事务隔离级别</strong>，通过注解中的<strong>isolation参数</strong>设置（）<br><strong>脏读（RC）</strong><br><strong>不可重复读（RR）</strong><br><strong>幻影读（SERIALIZABLE）</strong></li></ul></li><li><strong>实现原理</strong>（针对声明式事务管理）<br>基于<strong>AOP</strong>实现的（要在<strong>配置类</strong>中通过<strong>注解开启事务注解支持</strong>）<br>会为此类创建一个<strong>代理</strong>，调用会加上<strong>try-catch语句块</strong><br><strong>Spring事务信息存放在ThreadLocal中</strong>，所以一个线程只能有一个事务<ul><li><strong>try：</strong></li><li><strong>判断ThreadLocal</strong>是否有<strong>数据库连接</strong>，如果<strong>有</strong>，说明现在是<strong>内嵌事务</strong>，执行下面语句：<ul><li>如果是<strong>融入</strong>行为：不会重新创建新事务，将<strong>新事务的标志字段改为false</strong></li><li>如果是<strong>创建</strong>行为：会将<strong>事务状态信息暂存后清空</strong>，重写<strong>创建</strong>一个事务</li></ul></li><li>否则<strong>正常创建数据库连接</strong>，并且<strong>修改自动提交为false</strong>，<strong>执行</strong>目标方法</li><li><strong>catch：<strong>出现异常，需要回滚就会</strong>回滚</strong>，否则正常提交</li><li>无异常执行完成，<strong>当新事务标志字段为true</strong>则<strong>提交</strong>事务，<strong>否则恢复被清理的旧事务</strong>。</li></ul></li></ul></li><li><p><strong>事件监听</strong>机制（<strong>观察者设计模式</strong>）</p><ul><li>实现原理：底层通过<strong>事件广播器</strong>来发布事件，可以<strong>自定义事件监听器</strong>，Spring容器会帮我们自动加入进去。</li></ul></li></ul></li></ul><h2 id="Spring-Boot">Spring Boot</h2><ul><li><strong>Spring Boot框架</strong><ul><li>与Spring的主要区别<ul><li><strong>两者关系</strong>：Spring Boot不像Spring，不是一个框架，它<strong>是一个可以快速构建Spring脚手架工具</strong>，为其开发提供便利</li><li>核心注解：<br><strong>@SpringBootApplication</strong>（其为复合注解，还包括**@EnableAutoConfiguration @SpringBootConfiguration**）</li><li><strong>内嵌Servlet容器</strong></li></ul></li><li><strong>Spring Boot的启动流程</strong><ul><li>运行<strong>main方法</strong>，<strong>初始化SpringApplication</strong>（发布事件）</li><li>运行<strong>run方法</strong>，内部会读取环境变量，打印Banner，设置一些参数等（发布事件）</li><li><strong>创建</strong>SpringApplication上下文与<strong>初始化</strong>上下文，<strong>将启动类作为配置类注册</strong></li><li>调用<strong>refresh方法加载IoC容器</strong>（发布事件）<ul><li>解析**@Import加载的所有自动配置类**<br>（<strong>自动配置类</strong>：<strong>目的就是为我们做第三方库的自动配置</strong>）</li><li><strong>onRefresh</strong>方法中会<strong>创建servlet容器</strong></li></ul></li><li><strong>执行扩展接口</strong>（<strong>ApplicationRunner</strong>和<strong>CommandLineRunner</strong>接口）（发布事件）</li><li>执行<strong>异常也会发布事件</strong></li><li>大量利用<strong>监听器</strong>进行<strong>扩展</strong>（监听事件的发布）</li></ul></li><li><strong>自动配置加载的原理：</strong><ul><li>通过**@SpringBootConfiguration<strong>映入了</strong>@EnableAutoConfiguration**注解</li><li>其中使用**@Import<strong>导入了一个</strong>deferredImportSelcetor**</li><li>加载IoC容器时会<strong>解析@Import</strong>注解</li><li>会<strong>读取所有jar包META-INF/spring.factories文件</strong>（SPI），过滤出<strong>所有AutoConfigurationClass类型的类</strong></li><li>通过**@Condition排除无效的自动配置类**</li></ul></li><li><strong>内嵌Servlet容器启动原理</strong>（默认<strong>Tomcat</strong>）<ul><li>当<strong>引用了web的场景启动器</strong>，就会导入<strong>容器启动的自动配置类</strong>，会导入一个Web容器工厂，在OnRefresh方法创建容器</li><li>Jar包能直接运行的原因<ul><li>Spring Boot提供了一个maven插件，此时打包会将依赖的jar包和Spring Boot相关的类一起打包。<br>同时启动时会分别加载依赖的jar包和启动Main函数。</li></ul></li><li><strong>Servlet</strong>相关概念<ul><li><strong>三大组件</strong>：<br><strong>Servlet</strong>：处理客户端请求的核心组件<br><strong>Listener</strong>：用于监听 Web 应用程序中各种事件的组件<br><strong>Filter</strong>：用于在请求到达 Servlet 之前或响应返回客户端之前对请求和响应进行处理的组件</li><li><strong>Spring Boot</strong>可以在<strong>配置类</strong>中的注册 <strong>注册器Bean</strong>，并在其中<strong>注册相关组件</strong></li></ul></li></ul></li><li><strong><span id="日志框架">日志框架和门面</span></strong><ul><li>日志实现的方式有非常多，为了<strong>统一各个日志框架与日志门面</strong>，出现了<strong>适配器</strong>（让<strong>不同日志门面统一实现SLF4J门面</strong>）和<strong>桥接器</strong>（让<strong>不同日志框架实现SLF4J门面</strong>），只需要加入不同的适配器和桥接器就可以实现日志的整合。</li></ul></li><li><strong>Spring MVC测试方法</strong><ul><li><strong>MockMvc</strong>：<ul><li>不需要启动Web应用，可以<strong>对http请求进行模拟</strong>，同时<strong>提供一套验证工具</strong>，在测试类<strong>注入MockMvc对象</strong>，测试类加上**@AutoConfigureMockMvc**即可使用。</li></ul></li><li><strong>RestTemplate</strong><ul><li>主要适用微服务远程调用（本地也行），在普通类中的构造函数可以通过builder构造一个<br>测试类通过TestRestTemplate直接new一个。（使用完整的远程调用请求路径，以及需要使用无参构造函数）</li></ul></li><li>PostMan/<strong>ApiPost</strong>工具</li><li><strong>Swagger</strong> API测试文档</li></ul></li></ul></li></ul><h2 id="SSM">SSM</h2><ul><li><strong>SSM框架</strong><ul><li><strong>Spring MVC</strong><ul><li><strong>工作流程：</strong><ul><li><strong>客户端</strong>向服务器<strong>发送一个HTTP请求</strong></li><li><strong>前端控制器</strong>（<strong>DispatcherServlet</strong>）接收请求</li><li><strong>根据</strong>请求的URL和其他<strong>信息</strong>，通过<strong>HandlerMapping</strong>确定请求应该由哪个**处理器（Controller）**来处理</li><li><strong>确定处理器后</strong>，<strong>DispatcherServlet</strong>会通过<strong>HandlerAdapter</strong>来<strong>调用处理器</strong>。</li><li><strong>处理器（Controller）<strong>具体的</strong>业务逻辑实现类</strong>，它接收请求参数，执行业务逻辑，并返回一个<strong>ModelAndView</strong>对象。</li><li>返回ModelAndView对象后，<strong>DispatcherServlet</strong>会通过**视图解析器（ViewResolver）**解析视图名称，去找到对应视图。</li><li>找到视图资源后，<strong>DispatcherServlet</strong> 会<strong>将模型数据传递给视图</strong>，并进行<strong>渲染</strong>。</li><li>最后，<strong>DispatcherServlet</strong> 将生成的响应内容<strong>发送回客户端</strong>，客户端（如浏览器）会<strong>显示响应内容</strong>。</li></ul></li><li><strong>HandlerInterceptor</strong>：用于<strong>拦截处理请求</strong>，可以在请求处理前、处理中和处理后执行特定逻辑。</li><li><strong>ControllerAdvice</strong>：用于<strong>全局处理控制器的异常、数据绑定和数据校验</strong>。</li></ul></li><li><strong>Spring</strong> <a href="#Spring%E6%BA%90%E7%A0%81">详细戳这</a></li><li><strong>Mybatis</strong></li><li><strong>三层架构</strong><ul><li><strong>表示层</strong></li><li><strong>业务逻辑层</strong></li><li><strong>数据访问层</strong></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring知识点&quot;&gt;Spring知识点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&quot;Spring源码&quot;&gt;Spring框架&lt;/span&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;，&lt;strong&gt;控</summary>
      
    
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/categories/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    <category term="Spring" scheme="https://stars-at-dawn.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM相关知识点</title>
    <link href="https://stars-at-dawn.github.io/posts/jvm"/>
    <id>https://stars-at-dawn.github.io/posts/jvm</id>
    <published>2025-05-18T06:07:47.000Z</published>
    <updated>2025-06-07T01:52:17.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM相关知识点">JVM相关知识点</h2><ul><li>JVM<ul><li><strong>自动内存管理子系统</strong><ul><li><strong>运行时数据区：</strong><ul><li><strong>方法区</strong>（<u>线程共享的</u>）<ul><li>主要存储对象的<strong>元数据信息</strong>（类名，字段信息，方法信息，父类信息等）和<strong>运行时常量池</strong>（字符串（JDK1.7以前是存放的对象，后面改成了存放引用，对象放到堆内存中了）/数值/布尔字面量，符号引用（类全限定名，字段的描述信息，方法的描述信息））</li><li>实现方式<ul><li>JDK1.8以前实现方式是<strong>永久代</strong>（主要为了<strong>适配堆的分代结构</strong>方便垃圾回收器一起管理）</li><li>JDK1.8后采用<strong>元空间</strong>实现（使用<strong>本地内存</strong>来存储，与堆内存分离，内存大小可以动态扩展，大大<strong>减少了内存溢出的风险</strong>）</li></ul></li></ul></li><li><strong>堆</strong>（<u>线程共享的</u>）<ul><li><p><strong>对象的创建过程</strong></p></li><li><p>当JVM遇到一条new语句时，会先去找常量池找到此类的符号引用，并检查它是否已加载，否则执行<strong>类加载过程</strong>，通过后，JVM会为新对象在堆中<strong>分配固定内存</strong>（其大小在类加载完成后便以确定），同时<strong>初始化零值</strong>（对象头除外），接着<strong>设置对象头</strong>（锁状态信息，GC分代年龄，类型指针（指向它的类型元数据的指针）等，如果是数组则还要记录它的长度），在JVM看来此时对象已经真正创建完成；接着将会<strong>执行<init>方法</strong>才按照我们的意愿操作</p></li><li><p><strong>对象的存储布局</strong></p><ul><li>主要由三部分组成：<strong>对象头</strong>（Mark Word（存放对象自身运行时的数据），类型指针（指向它的类型元数据的指针）），<strong>实例数据</strong>（真正有效的信息，自己定义的各种类型字段内容），<strong>对齐填充</strong>（无意义，只是由于HotSpot虚拟机的要求对象的起始地址必须时8字节的整数倍）</li></ul></li><li><p><strong>垃圾回收器</strong></p><ul><li><p><strong>如何判断垃圾</strong>（哪些内存需要回收）</p><ul><li>“垃圾”指的就是那些不可能被使用的对象</li></ul></li><li><p><strong>判断</strong>是否是<strong>垃圾</strong>主要有两种<strong>算法</strong>，分别是</p><ul><li><strong>引用计数算法</strong><ul><li>在对象中添加一个引用计数器，当有引用指向它就+1，只要计数器为0就说明此对象是垃圾，但单纯的此算法无法解决诸如循环引用等问题</li></ul></li><li><strong>可达性分析算法</strong><ul><li>这个算法的核心就是根节点（GC Roots 如在栈帧引用的对象，类静态属性引用的对象，常量引用的对象（字符串等）等），只要通过根节点找不到这个对象，则表示此对象为垃圾。</li><li>finalize()方法（已被官方废弃），在它们被回收时，如果有必要执行此方法（此方法只会执行一次），则会放到一个队列另起一个线程执行，然后再次对此队列进行再次扫描。</li></ul></li><li><strong>Java中的四种引用类型</strong><ul><li><strong>强引用</strong>（传统的引用，不会被回收）、<strong>软引用</strong>（SoftReference 当要发生内存溢出时会尝试二次GC回收这些对象）、<strong>弱引用</strong>（WeakReference下次GC就会直接回收）、<strong>虚引用</strong>（PhantomReference此引用不起实际的作用，不会对对象的生命周期产生影响，其指向的对象回收后会将虚引用加入到指定的队列，可以得到通知）</li></ul></li></ul></li><li><p><strong>垃圾回收算法</strong>（追踪式的）</p><ul><li>首先这个算法基于<strong>分代收集理论</strong>（说是理论实则是统计学的经验法则）即：<ul><li>①大部分对象都是朝生暮死</li><li>②熬过越多次GC的对象就越难消亡</li></ul></li><li>所以Java将堆分成了几个不同的区域：<strong>新生代和老年代</strong><ul><li>我们将会对不同的区域进行垃圾回收；但同时对象不是孤立的，会存在跨代引用，但这只是占极少数，因此我们在新生代上建立一个<strong>数据结构</strong>（<strong>记忆集</strong>）来标识哪些老年代内存需要一起GC</li></ul></li><li>针对这些区域和特点做了相匹配的算法，也就是下面：</li><li><strong>标记-清除算法</strong><ul><li>最基础的版本，分为两个步骤**“标记”“清除”<strong>，首先标记要回收的对象，然后统一回收掉所有被标记的对象。它的</strong>执行效率不稳定**，因为大量对象都需要回收，标记和清除的动作会导致效率很低，同时<strong>产生大量的内存碎片</strong></li><li><strong>标记-复制算法</strong><ul><li>可以解决这两个问题（<strong>适合新生代GC使用</strong>）（<strong>复制过程可以采用并发来加速提高效率</strong>）最早提出的是半区复制，即GC时，将一半空间中存活的对象复制到另一半空间里，不过这会产生大量的<strong>空间浪费</strong>（新生代存活的对象一般不足十分之一），所以就将新生代分为了<strong>Eden区和Survivor区</strong></li><li>新生代：一个较大的Eden区和两个较小的Survivor区（另一个用来存放复制存活的对象），它们默认的大小比例为8：1：1（大大<strong>减少了空间的浪费</strong>）</li></ul></li><li><strong>标记-整理算法</strong><ul><li>标记-复制算法对老年代的存活对象较多的场景不适用（复制的操作过多，且存活对象过多），于是在“标记”后，将<strong>存活的对象向内侧空间移动，然后直接清理掉边界外的内存</strong>（<strong>适用老年代</strong>）</li><li><strong>移动操作</strong>是一项极为负重的操作，因为移动对象必须全程暂停用户线程才能进行，而这种停顿也被我们戏称为**“Stop The World”**（STW）</li></ul></li></ul></li></ul></li><li><p><strong>HotSpot内部的算法实现细节</strong></p><ul><li>GCRoot的相关细节<ul><li><strong>GC Roots枚举</strong><ul><li>要实现找到垃圾的可达性分析，最终要的就是GC Roots的寻找，由于在此时会STW（要做到准确收集），但HotSpot虚拟机会使用一个Map（<strong>OopMap</strong>），会将对象的偏移量计算后写入，来加速扫描过程。</li></ul></li><li><strong>安全点</strong><ul><li>在每个方法都生成OopMaps（记录信息）是不现实的，所以设置了安全点的概念，只在这生成，同时这里会执行全局操作（GC、类卸载等），要确保状态的可预知性，同时不能安全点设置不能太多也不能太少（会设置在方法调用，循环，异常等指令跳转的地方），线程会通过轮询一个标志位判断是否需要中断（或是虚拟机强制中断线程）</li></ul></li><li><strong>记忆集</strong><ul><li>上面讲到为了<strong>解决跨代之间的对象引用</strong>而建立的数据结构（记录的粒度可以是字长，对象，或者“卡”（一个内存区域，卡表独有））</li><li><strong>卡表</strong>作为记忆集的一种实现方式（<strong>一个字节数字</strong>），它以“卡页”作为精度，一个卡页会包含多个对象，如果其中有一个对象的字段存在跨代引用，则表明这个元素<strong>变脏</strong>，其通过<strong>写屏障技术</strong>维护卡表状态（会为所有赋值操作生成相应指令，相当于虚拟机层面的AOP）</li></ul></li></ul></li><li><strong>并发判断是否是垃圾（并发的可达性分析）</strong><ul><li>在此需要引入<strong>三色标记</strong>来帮助理解为什么并发判断垃圾会出现问题</li><li><strong>三色标记</strong>（<strong>白色：未标记，黑色：标记完成的存活对象，灰色：其指向的对象没有标记完</strong>）</li><li>并发标记会出现如下两个问题（<strong>漏标和多标</strong>）<ul><li>当插入一条黑色到白色的引用同时删除所有灰色到此白色的引用，那么白色引用将无法被找到<ul><li>这会直接影响到程序的运行，是不可容忍的</li><li>为了解决这个问题提出了<strong>增量更新</strong>和<strong>原始快照</strong>两种解决方案</li><li><strong>前者是让黑色对象插入白色引用时变为灰色对象。</strong></li><li><strong>后者是在灰色对象删除白色引用时将白色对象变为灰色，重新扫描。</strong></li></ul></li><li>当删除一条黑色到灰色的引用，虚拟机会无法感知，可能出现内存泄漏（浮动垃圾）<ul><li>只需要等到下次GC清理就行</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>不同的GC的特点和使用场景</strong></p><ul><li>经典的GC的组合：<ul><li><strong>Serial + Serial Old</strong>（简单高效，小型机器使用）<ul><li>都是<strong>单线程</strong>垃圾回收器，<strong>全程都需要STW</strong>，<strong>Serial</strong>采用<strong>标记-复制算法</strong>（Eden和Survivor）负责新生代进行回收，<strong>Serial Old</strong>则采用<strong>标记-整理算法</strong>负责老年代GC</li></ul></li><li><strong>ParNew（JDK 7前首选的新生代收集器） + CMS</strong><ul><li><strong>ParNew</strong> 实际上就是<strong>Serial</strong>的<strong>多线程版本</strong>，使用多条线程并行处理垃圾，其它与Serial并无差异</li><li><strong>CMS</strong>负责<strong>老年代</strong>GC，它第一次实现了<strong>并发的垃圾收集</strong>，从名字就可以看出（Concurrent Mark Sweep）它是基于<strong>标记-清除</strong>算法实现，它的执行包含四个步骤</li><li><strong>GC过程：①初始标记。②并发标记。③重新标记。④并发清除</strong>（<strong>①和③仍然需要STW</strong>）</li><li>①只是<strong>标记GC Roots</strong>能直接关联的对象。②是<strong>遍历</strong>整个对象图标记垃圾的过程。<br>③则是<strong>增量更新</strong>的过程。④是<strong>清除</strong>垃圾的过程（不需要移动对象，所以可以并发）</li><li>CMS存在需多问题，最严重的是它<strong>不能处理浮动垃圾和空间碎片</strong>，GC失败后会调用Serial Old</li></ul></li><li><strong>PS</strong>（Parallel Scavenge） + <strong>PO</strong>（Parallel Old）<ul><li>PS是基于<strong>标记-复制算法</strong>的<strong>并发</strong>收集的<strong>新生代GC</strong>，它的主要特点是关注点不同，它关注<strong>吞吐量</strong>（处理器用于业务代码的时间占比）的大小，<strong><u>适合需要后台运行不需要太多交互的应用</u></strong>，它的<strong>标记阶段是并行的</strong>，在清<strong>理垃圾时是STW的</strong>，因为需要移动对象</li><li>PO是PS<strong>老年代</strong>的版本是基于<strong>标记-整理算法</strong>实现的</li></ul></li><li><strong>G1</strong>（Garbage First） （<strong>JDK 9开始是服务端模式下的推荐方案</strong>了，之前是PS + PO）<ul><li>G1是一个<strong>面向全堆的收集器</strong>，它从<strong>整体上</strong>看是<strong>标记-整理算法</strong>实现，从<strong>局部</strong>（两个Region）上看又是基于<strong>标记-复制算法</strong>实现。它第一次提出了基于<strong>Region</strong>的<strong>内存布局</strong>形式。但是G1没有抛弃分代的理念，<strong>每个Region</strong>都可以<strong>根据需要扮演对应的区域</strong>。</li><li>G1的垃圾回收可以<strong>针对任意区域</strong>（一个<strong>回收集</strong>，称为CSet）进行回收，而不是只局限与整个年龄代，根据<strong>回收的收益</strong>来进行回收，这就是它的<strong>Mixed GC模式</strong>，同时可以<strong>做到可控的GC停顿时间</strong>（用户可以通过参数指定）（衰减平均值的概念）</li><li><strong>维护跨Region的引用对象会变得非常复杂</strong>，需要耗费过多的内存来维护，成为额外负担</li><li><strong>GC过程：①初始标记。②并发标记。③最终标记。④筛选回收</strong>（<strong>①和③和④仍然需要STW</strong>）</li><li>①<strong>标记GC Roots</strong>②如果用户<strong>新创建对象</strong>则会在Region中设置<strong>两个指针标记</strong>，加入其中会默认其是<strong>存活</strong>的③是<strong>原始快照</strong>过程。④负责统计Region的回收价值<strong>制定回收计划</strong>，最后把存活的对象<strong>复制</strong>到空的Region中再清理掉旧的Region（此时需要<strong>STW</strong>再多线程执行移动对象）</li></ul></li></ul></li><li>高性能GC：<ul><li><strong>Shenandoah</strong>（非官方的GC）<ul><li><strong>G1的继承者</strong>，不同的是它<strong>支持并发的整理算法</strong>，其次它<strong>抛弃了分代设计</strong>，此外将<strong>记忆集</strong>的实现方式改成了<strong>连接矩阵</strong>的<strong>全局</strong>数据结构。</li><li>**GC过程：**①初始标记。②并发标记。③最终标记。④并发清理。⑤并发回收。<br><strong>⑥初始引用更新。⑦并发引用更新。⑧最终引用更新。⑨并发清理</strong>（<strong>①③⑥⑧需要STW</strong>）</li><li><strong>①②③与G1基本一样</strong>，<strong>④</strong>会<strong>清理没有存活对象的Region</strong>。<strong>⑤</strong>先将存活对象<strong>复制</strong>到一个没有用过的Region中。<strong>⑥</strong>确定一个执行点，<strong>确保⑤已经执行完成</strong>，此时会STW。<strong>⑦</strong>将堆中的所有指向旧对象的指针<strong>指向新地址</strong>。<strong>⑧</strong>修改<strong>GC Root</strong>的引用，此时会STW。<strong>⑨</strong>再次<strong>调用④过程</strong>。、</li><li><strong>并发移动</strong>时，采用<strong>转发指针</strong>来防止访问旧对象（在对象中加入一个新的引用字段，默认指向自己，而在移动后，指向新地址）</li></ul></li><li><strong>ZGC</strong>（它的设计注定它能承受的对象分配速率不会太高）<ul><li>是一款<strong>基于Region内存布局</strong>的，不采用分代设计的GC。其使用<strong>读屏障，染色指针和内存多映射</strong>等技术实现<strong>并发</strong>的<strong>标记-整理算法</strong></li><li>与G1和Shenandoah不同，它的Region具有动态性，分小、中、大三类，对应不同大小的对象</li><li><strong>染色指针</strong>是它的标志（Linux中通过<strong>多重映射</strong>的方式来<strong>支持</strong>），即将<strong>一部分信息存在指针</strong>上（4位，三色标记状态，是否移动等），所以这会导致ZGC可以管理的内存大小不能超过4TB（2^42），同时它也不能支持<strong>指针压缩</strong>（将64位的指针压缩成32位，减少内存消耗），它可以<strong>使Region被移走后直接释放</strong></li><li><strong>GC过程：①并发标记。②并发预备重分配。③并发重分配。④并发重映射。</strong></li><li><strong>①</strong>与G1和Shenandoah一样的<strong>标记过程</strong>。<strong>②</strong>去<strong>扫描</strong>所有的Region（<strong>省去了记忆集</strong>的开销），确定<strong>回收</strong>的Region<strong>的集合</strong>。<strong>③复制</strong>存活对象到新的Region中，并为老Region维护一个<strong>转发表</strong>，当有引用通过转发表进行访问时，会<strong>重新更新它的引用</strong>，减少后续的开销（<strong>指针自愈</strong>）<strong>④</strong>修正整个堆的<strong>旧引用</strong>，与<strong>Shenandoah的⑦</strong>基本一样，不过ZGC会<strong>在并发标记时一起执行</strong>（自愈）</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><strong>栈</strong>（<u>线程私有的</u>）<ul><li><strong>本地方法栈</strong></li><li><strong>虚拟机栈</strong><ul><li><strong>栈帧</strong>（<a href="#%E6%A0%88%E5%B8%A7">详见此处</a>）</li></ul></li></ul></li></ul></li></ul></li><li><strong>执行子系统：</strong><ul><li><strong>Class文件</strong>的结构<ul><li>开头就是魔术与Class文件的版本号，接着就是Class文件的常量池</li></ul></li><li><strong>类加载机制</strong><ul><li><p><strong>执行时机</strong></p><ul><li><strong>①使用new关键词实例化对象时</strong>。<br><strong>②读取或设置类的静态字段时（final修饰，已在编译器放入常量池的静态字段除外）</strong>。<br><strong>③调用一个类的静态方法时</strong>。</li></ul></li><li><p><strong>类的生命周期</strong></p><ul><li><strong>加载、<u>验证、准备、解析（三个步骤被称为连接）</u></strong><br><strong>初始化、使用、卸载</strong></li></ul></li><li><p><strong>类加载过程</strong></p><ul><li><strong>加载阶段：</strong><br><strong>①通过类的全限定名获取字节流</strong>（如果数组的组件类型是引用类型，将会递归执行此过程）<br><strong>②将静态结构转化为方法区的数据结构</strong><br><strong>③在堆中生成一个Class对象（JDK1.8后移动到堆中，逻辑上属于方法区），作为访问入口</strong><ul><li><strong>类加载器</strong><ul><li>加载阶段是可控性最强的阶段，可以重写类加载器的<strong>findClass或者loadClass方法</strong>来修改<strong>获取字节流的方式</strong>，实现自定义获取程序代码。</li><li><strong>双亲委派模型</strong>（指各个类加载器之间的层次关系）<ul><li>除了启动类加载器，其余类加载器都应有自己的父类加载器</li></ul></li><li><strong>双亲委派机制</strong><ul><li>一个类加载器收到类加载请求，它会先委派父类加载器加载，每个加载器都如此，当父类加载器无法加载时，子类加载器才会尝试加载。</li><li>能够避免类的重复加载，同时确保核心类都由虚拟机自行加载，增加了安全性</li></ul></li><li><strong>破坏双亲委派机制</strong><ul><li><strong>重写loadClass方法</strong></li></ul></li></ul></li></ul></li><li><strong>连接（验证，准备，解析）阶段</strong><ul><li><strong>验证</strong>阶段：<strong>确保Class文件的内容符合规范约束</strong>（如果确认了，则此步骤可以通过参数关闭加速启动时间）<br><strong>准备</strong>阶段：正式<strong>为类中定义的变量（即静态变量）分配内存并设置零值</strong>。<br><strong>解析</strong>阶段：是将Class文件的常量池内的<strong>符号引用替换为直接引用</strong>。（此处可能会触发别的类加载）</li></ul></li><li><strong>初始化阶段（类加载过程的最后阶段</strong>）<ul><li><strong>分配对象内存空间</strong><br><strong>初始化对象</strong><br><strong>将指针指向刚才分配的内存空间</strong></li></ul></li></ul></li></ul></li><li><strong>执行代码的过程</strong><ul><li><strong>执行引擎</strong>（虚拟机字节码执行引擎）<br>-<strong>虚拟机</strong>是一个相对<strong>物理机</strong>的概念，物理机的执行引擎直接建立在<strong>硬件和操作系统层面</strong>上的，而虚拟机执行引擎则是由<strong>软件自行实现</strong>，因此可以不受制约实现其它指令集格式。<br>-虚拟机执行引擎在执行字节码时通常会有<strong>解释执行</strong>和<strong>编译执行</strong>两种方式（或同时存在）。<strong>输入</strong>字节码二进制流，<strong>处理</strong>过程就是对字节码的解释执行，<strong>输出</strong>执行结果<ul><li><strong><span id="栈帧">栈帧</span></strong>（Java虚拟机以方法作为最基本的执行单位）<ul><li>其中包括了<strong>局部变量表</strong>，<strong>操作数栈</strong>，<strong>方法返回地址</strong>等信息（其大小一开始就已经确定了，固定的）</li><li><strong>局部变量表</strong>：是<strong>变量的存储空间</strong>（存放方法参数和方法内部定义的局部变量，非静态方法第0位为this变量）<br><strong>操作数栈</strong>：是一个先进后出的栈（栈的最大深度也是一开始就确定了）</li></ul></li><li><strong>方法调用</strong>（只是<strong>确定调用版本</strong>，<strong>并未执行</strong>方法）<ul><li><strong>静态解析</strong>：针对的是<strong>编译期就可知调用版本</strong>的方法，主要是<strong>静态方法</strong>（直接与类相关）和<strong>私有方法</strong>（外部不可访问）两类</li><li><strong>分派</strong>（多态的具体体现）：<ul><li><strong>静态分派</strong>：依赖静态类型来决定执行版本的分派（最典型的就是<strong>方法重载</strong>）<br>对于<strong>Human man = new Man()；Human 为静态类型，Man为实际类型</strong><br>其在<strong>编译期</strong>就会由编译器通过<strong>静态类型</strong>和<strong>参数</strong>确定执行版本，被称为多分派类型</li><li><strong>动态分派</strong>：根据对象的实际类型来执行版本的分派（<strong>方法重写和多态</strong>）<br>在<strong>运行期</strong>才能知道方法的<strong>调用目标</strong>（<strong>实际类型</strong>）<br>只会<strong>根据实际类型</strong>进行分派（此时参数类型已经确认），被称为单分派类型</li><li>动态分派<strong>优化</strong>：由于此操作极其频繁，会在方法区中创建一个虚方法表用来代替元数据的查找。</li></ul></li><li>**Reflection和MethodHandle（java.lang.invoke包）**的区别：反射（Reflection）是重量级操作，是对象的全面映射，而后者则只是包含该方法的相关信息，较之是轻量级操作</li></ul></li></ul></li></ul></li></ul></li><li><strong>编译子系统：</strong><ul><li><strong>前端编译优化</strong><ul><li><s>Javac</s></li><li><strong>语法糖</strong><ul><li><strong>泛型</strong>：Java的泛型实现方式为“<strong>类型擦除式泛型</strong>”，即Java中的<strong>泛型只在源码中出现</strong>，编译后的字节码中都会被替换为<strong>裸类型</strong>，并在相应地方插入<strong>强制转换代码</strong>。（目的就是为了兼容旧版本）</li><li><strong>自动装箱、拆箱</strong>：大量的诸如<strong>Integer.valueOf</strong>的方法，在“==”运算或者equals方法中时不会起作用</li><li><strong>for-each的迭代器；条件不成立的分支自动去除；枚举类、Lambda表达式</strong>等等。</li></ul></li></ul></li><li><strong>后端编译优化</strong><ul><li><strong>解释器</strong>：它可以<strong>直接运行</strong>程序，不需要编译；它还可以<strong>节约内存</strong>；且是编译<strong>优化失败</strong>后的底牌。</li><li><strong>即时编译器</strong>（C1，C2编译器）<ul><li>针对的是<strong>热点代码</strong>（即<strong>多次执行的循环体</strong>或者被<strong>多次调用的方法</strong>）<br>当对循环体优化时，会发生<strong>栈上替换</strong>，在方法运行时就将其替换</li><li>热点探测（有两种方式）<ul><li><strong>基于采样</strong>的热点探测：会周期性的查看各个线程的<strong>栈顶</strong>，如果发现某个方法出现<strong>频率过高</strong>，就是热点；其<strong>缺点</strong>就是<strong>无法准确确认</strong>一个方法的热度，容易受<strong>线程阻塞</strong>或者外界执行的因素的<strong>影响</strong>。</li><li><strong>基于计数器</strong>的热点探测：HotSpot为每个方法准备了两个计数器，<strong>方法调用计数器</strong>和<strong>回边计数器</strong>；当有其中一个超过阈值，则为热点。<br><strong>方法调用计数器</strong>：见名知意，<strong>统计方法调用次数</strong>，在默认情况下，它<strong>统计</strong>的不是绝对次数，而是<strong>相对的频率</strong>，当<strong>一定时间</strong>过后，如果还未到阈值，则会<strong>减少一半</strong>（被称为<strong>热度的衰减</strong>）<br><strong>回边计数器</strong>：它的作用是<strong>统计循环中代码执行的次数</strong>，其没有热度衰减，<strong>统计的是绝对次数</strong>。</li></ul></li><li><strong>分层编译</strong>的概念：<ul><li>主要由于即使编译器编译<strong>需要占用资源</strong>，所以为了<strong>平衡其影响</strong>提出了分层编译的功能<br>（客户端编译器，服务端编译器）</li></ul></li></ul></li><li><strong>提前编译器</strong></li><li><strong>优化技术</strong><ul><li><strong>方法内联</strong>：最基础也是最重要的优化，是<strong>其它优化的基础</strong>。通过<strong>将方法中的代码“复制”到调用的位置</strong>，可以去除调用时的成本，同时<strong>为其它优化奠定基础</strong>。<br><strong>虚方法的内联</strong>：非虚方法没有什么问题，但虚方法则很难确定调用者的类型，如果查询到<strong>只有一个版本</strong>，则将此内联称为<strong>守护内联</strong>（<strong>Java</strong>是<strong>动态连接</strong>的，所以有可能<strong>被打破</strong>）；如果是<strong>多个版本</strong>，则会<strong>去调用方法</strong>，但会使用一个<strong>缓存</strong>来缩减调用开销。</li><li><strong>逃逸分析</strong>：它也是<strong>为其它优化提供基础的分析技术</strong>；通过分析<strong>对象</strong>的动态<strong>作用域</strong>，分为方法逃逸，线程逃逸，以及从不逃逸。<br>据此它分为<strong>三种优化方式</strong><ul><li><strong>标量替换</strong>：将其成员变量的访问<strong>恢复原始对象的访问</strong>，它<strong>不允许逃逸到方法外面</strong>。</li><li><strong>栈上分配</strong>：<strong>分配到栈上</strong>，可以省去GC的开销，随着栈帧的出栈而回收，它<strong>不允许逃逸到线程外面</strong>。</li><li><strong>同步消除</strong>：对<strong>不能逃逸到线程外</strong>面的代码<strong>取消同步措施</strong></li></ul></li></ul></li></ul></li></ul></li><li><strong>高效并发：</strong>（<strong>阿姆达尔</strong>（Amdahl）<strong>定理</strong>代替<strong>摩尔定律</strong>成为计算机性能发展的源动力）<ul><li><strong>Java内存模型：</strong><ul><li><strong>三大特性：</strong><br><strong>原子性</strong>：指此操作不可分割和中断的，对于基本数据类型的访问，读写都具备原子性<br><strong>可见性</strong>：指一个线程修改了共享变量时，其它线程能够立即得知这个修改。<br><strong>有序性</strong>：在线程内观察，所有操作都是有序的，而线程外看起来则是无序的，先行发生原则（happens-before原则）</li><li><strong>乱序执行</strong>：<br>处理器会对输入代码进行乱序执行优化，是<strong>机器级别的优化</strong></li></ul></li><li><strong>线程的运行状态</strong><br><strong>①新建</strong>（创建但尚未运行）<br><strong>②运行</strong>（运行中的线程）<br><strong>③无限期等待</strong>（未设置等待时间的线程，等待唤醒动作）<br><strong>④限期等待</strong>（设置等待时间的线程，等待唤醒动作或者时间）<br><strong>⑤阻塞</strong>（与等待的区别是，它在等待获取一个排他锁的释放）<br><strong>⑥结束</strong>（终止后的线程状态）</li><li><strong>互斥同步：</strong>（互斥是方法，同步是目的）<ul><li><strong>synchronized</strong>：<br>这是一种<strong>块结构</strong>的同步语法，会在<strong>同步代码块前后</strong>生成<strong>monitorenter和monitorexit</strong>这两个字节码指令，其需要明确加锁对象（Java中如果没指定了加锁对象，则根据<strong>锁定方法</strong>来判断是<u>对象实例</u>（<strong>实例方法</strong>）还是<u>Class对象</u>（<strong>类方法</strong>））<ul><li><strong>monitorenter</strong>会去获取对象的锁，如果获取成功，<strong>锁的计数器加一</strong>，monitorexit也是如此，所以其是<strong>可重入锁</strong></li></ul></li><li><strong>Lock接口：</strong>（JUC包下的）<strong>非块结构</strong>来实现互斥同步<ul><li><strong>ReentrantLock</strong>：<strong>重入锁</strong>，和synchronized一样也是可重入的，但其多了三大功能：<strong>等待可中断</strong>（等待的线程可以选择<strong>放弃等待</strong>），<strong>公平锁</strong>（可以按照等待顺序依次获得锁，默认不公平的，开启后会使得性能下降），<strong>锁绑定多个条件</strong>（锁对象可以绑定多个<strong>Condition对象</strong>）。</li></ul></li><li><strong>互斥同步</strong>的<strong>主要问题</strong>是进行<strong>线程阻塞和唤醒</strong>所带来的<strong>开销</strong>，所以诞生了<strong>非阻塞的同步</strong>，<strong>CAS</strong>（比较并交换）就是其中之一。CAS存在一个<strong>ABA问题</strong>（可以通过版本号来解决，但一般此问题对程序不会有大影响）。</li></ul></li><li><strong>锁优化：</strong><ul><li><strong>自旋锁</strong>：<br>互斥同步最大的性能开销就是阻塞，同时共享变量的锁定状态一般<strong>不会持续很久</strong>，所以不需要每次都直接等待挂起，而是让其<strong>进行一个忙循环</strong>（<strong>自旋</strong>）。如果<strong>多次自旋成功</strong>，可能会允许自旋的<strong>次数更多</strong>，反之则可能会直接<strong>略过自旋</strong>避免<strong>浪费处理器资源</strong>（<strong>自适应自旋</strong>）。</li><li><strong>偏向锁</strong>：<br>目的为了<strong>消除无竞争下的同步操作</strong>，它会<strong>偏向于第一个获得它的线程</strong>，如果没有竞争，则此线程无需执行同步操作（在竞争激烈的程序中可以关闭此功能提升性能）。（在<strong>对象头</strong>中设置标志位）<strong>一旦有别的线程尝试获取这个对象的锁</strong>，偏向锁就会结束，<strong>转为轻量级锁</strong>。</li><li><strong>轻量级锁</strong>：<br>在<strong>对象没有被锁定时</strong>，虚拟机会为此对象的Mark Word的<strong>拷贝</strong>，然后通过<strong>CAS</strong>来将<strong>Mark Word更新为指向栈帧的指针</strong>，同时将锁标志位<strong>设置为轻量级锁定</strong>；如果<strong>失败</strong>则意味这有其它线程在竞争，此时需要<strong>膨胀成重量级锁</strong>，将指针更新为<strong>互斥量指针</strong>；<strong>释放锁</strong>也是同理，如果<strong>CAS</strong>更新Mark Word<strong>失败</strong>，则需要<strong>唤醒其它被挂起的线程</strong>。</li><li><strong>锁消除</strong>：主要通过<strong>逃逸分析</strong>的支持，如果无法被其它线程访问到，则可以将它们的<strong>同步语句去除</strong>。</li><li><strong>锁粗化</strong>：有些情况下连续的一串操作中会不停的加锁解锁（一些方法调用时），此时虚拟机会将这<strong>一些零散的加锁</strong>操作变成<strong>一个范围的加锁同步</strong>。</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM相关知识点&quot;&gt;JVM相关知识点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JVM
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自动内存管理子系统&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运行时数据区：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法区&lt;/str</summary>
      
    
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/categories/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="JVM" scheme="https://stars-at-dawn.github.io/tags/JVM/"/>
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>力扣45跳跃游戏 II</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode45"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode45</id>
    <published>2025-04-20T08:00:20.000Z</published>
    <updated>2025-04-20T08:06:42.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><hr><p>与另一个（力扣55）十分相似，最短的跳跃距离，<strong>依旧是贪心</strong>，只要让位置跳的尽量远即可<br>真就贪心，想不到那就做不出来，无语，这种题目是真没意思，不过得注意不像上一题只要维护最大值，现在还要维护最大步长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前步长能走的最大值，也即下次的步长</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stepMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];<span class="comment">//最大步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//超过步长则意味着一步已经走完了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; stepMax) &#123;</span><br><span class="line">                step++;</span><br><span class="line">                stepMax = max;</span><br><span class="line">                max = Math.max(nums[i] + i, max);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没走完则接着找当前步长能走的最远距离</span></span><br><span class="line">                max = Math.max(nums[i] + i, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>改动态规划实现</strong>：</p><p>突发奇想改了个动态规划，不过可惜，超时了，感觉有优化空间，不过懒得管了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//横坐标索引 纵坐标剩余步数 </span></span><br><span class="line">        <span class="comment">//剩余步数其实大小也不应该是n，不过我也不知道写啥</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[n - <span class="number">1</span>][i] = <span class="literal">true</span>;<span class="comment">//到达位置，即 剩余步数为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>; step &lt; n; step++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> n - <span class="number">2</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums[index]; i++) &#123;</span><br><span class="line">                    <span class="comment">//这里应该可以优化赋值阶段的工作</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[index + i][step - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[index][step] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][i]) <span class="keyword">return</span> i;<span class="comment">//从上到下返回第一个（最小步数）可以到达的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;0 索引&lt;/strong&gt;整数数组 &lt;code&gt;nums&lt;/code&gt;。初始位置为 &lt;code&gt;nums[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个元</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣55跳跃游戏</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode55"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode55</id>
    <published>2025-04-20T06:38:57.000Z</published>
    <updated>2025-04-20T06:49:48.626Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><hr><p>经典跳跃小游戏，简单的dp缓存表最好想了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="comment">//缓存表</span></span><br><span class="line"><span class="comment">//dp2是和下面优化的代码有所区分无意义，int类型是因为存三个状态：能到，不能到，未缓存</span></span><br><span class="line"><span class="type">int</span>[] dp2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> f(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="comment">//basecase</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp2[index] != <span class="number">0</span>) <span class="keyword">return</span> dp2[index] &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index + nums[index] &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums[index]; i++) &#123;</span><br><span class="line">            res = res | f(nums, index + i);<span class="comment">//去遍历是否有能到的</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp2[index] = res ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>改动态规划实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];<span class="comment">//dp表</span></span><br><span class="line">        dp[nums.length - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//从后往前填写</span></span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;<span class="comment">//如果可以直接到达则返回true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= i + nums[i]; j++) &#123;</span><br><span class="line">                    <span class="comment">//不能的则去遍历能到的位置中有人能达到吗</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">                        dp[i] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//剪枝优化：如果不行，那他的后面也不用看了</span></span><br><span class="line">                        j += nums[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>额外的，贪心实现：</strong></p><p>既然题目要求我们到达最后一个，实际上就是要我们走的越远越好，即当前位置能跳的距离和前面最远的距离的较大值即为当前位置的最远距离，只要大于数组长度就返回<code>true</code>，反之到不了就返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下 非常短    </span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump3</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;<span class="comment">//当前位置能去的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            max = Math.max(max, i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (max&gt;=nums.length-<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//max能到了，就返回结束程序运行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣189 轮转数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode189"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode189</id>
    <published>2025-04-19T14:01:04.000Z</published>
    <updated>2025-04-20T06:38:48.721Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><hr><p>题目非常简单，分成两段数组分别赋值即可，不过注意是检查的依旧是原数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        k = k % nums.length;<span class="comment">//超过一圈后都是循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - k; i++) &#123;</span><br><span class="line">            nums[i + k] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i - nums.length + k] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>空间复杂度优化</strong></p><p>又是进行复杂度优化，好吧，挺困难的，想了半天憋了个这还写不出来233 &gt;:<br>无所谓了，这里是用循环替代来进行替换（替换到最后会回到原位）<br>不过这里用最大公因数限制次数确实是没想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gcd</span> <span class="operator">=</span> gcd(k, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gcd; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> nums[i];<span class="comment">//为了保留第一个参数</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + k) % n;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t2</span> <span class="operator">=</span> nums[next];</span><br><span class="line">                nums[next] = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (current != i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y &gt; <span class="number">0</span> ? gcd(y, x % y) : x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>不过还有个大神方法：数组反转</strong><br>将全部数组反转，再分别反转前k个和后k个即可完成此效果（因为<strong>反转后即使只有部分再反转，其中的相对顺序保持不变</strong>，根据轮转的效果来看也确实是相对顺序不变，只是分了两块而已）（确实是想不到啊~~）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate5</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k %= n;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//数组前后指针的数字交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">            nums[j--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，将数组中的元素向右轮转 &lt;code&gt;k&lt;/code&gt; 个位置，其中 &lt;code&gt;k&lt;/code&gt; 是非负数。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目非常简单，分成两段数组</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣169 合并两个有序数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode169"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode169</id>
    <published>2025-04-18T12:44:18.000Z</published>
    <updated>2025-04-18T12:55:09.673Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><hr><p>题目非常简单，让我们找出现次数最多的数，使用Hash表应该是最好想到的，不多赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];<span class="comment">//特殊情况，直接返回</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i])) map.put(nums[i], <span class="number">1</span>);<span class="comment">//不存在创建添加</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(nums[i]) &gt; nums.length / <span class="number">2</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>空间复杂度优化</strong>（<strong>难度比较高，感觉有点像贪心</strong>）</p><p>但题目让我们尝试<strong>设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法</strong>解决此问题。而上面的空间复杂度为 O(N)所以我们要优化，只用有限的变量去实现这个记录最大次数，也就是其他参数应该是“无状态的”，至少应该不需要我们去解决，笔者尝试几分钟并没找到解法，看答案才知道，所以给大家写一下我的理解以及怎样有可能能想到这些方法。</p><p>这里要用到的是<strong>摩尔投票</strong>的算法：<br>题目告诉我们有个数出现次数超过n/2，我们称它X，而所谓的算法就是指如果数据进行投票，非X则投反票，X投正票，最后的投票一定是正的。（投票本身不重要，重要的是思想，应该怎样<strong>量化这些数据</strong>）</p><p>如果我指定一个数作为基准，当经过一轮投票后为0，则这轮有一半为此数，但有两种情况：<br><strong>数刚好就X，那无所谓，对最后的结果没影响</strong><br>否则，那此时X可能在另外的数中，但对后面却不影响，因为<strong>最多失去一半X，但同时失去的还有一半其他数</strong>（<strong>由于X的次数已经限定了大于一半，甚至没有等于 233，所以这个分支不会出现在最后一轮</strong>）<br>据此我们可知，<strong>最后一轮我们的选择必定刚好就是X</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement3</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//每一轮假定的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">votes</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//量化其他数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) x = num;<span class="comment">//如果为0 则开启下一轮</span></span><br><span class="line">            votes += x == num ? <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">//数据进行投票</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个大小为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中的多数元素。多数元素是指在数组中出现次数 &lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/c</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣80 删除有序数组中的重复项 II</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode80"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode80</id>
    <published>2025-04-18T01:51:04.000Z</published>
    <updated>2025-04-18T01:59:40.755Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><ul><li><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p></li></ul><hr><p>与leetcode26优化后的结果差不多：<br>我们看看能不能优化一下，依旧是大小不重要，所以依旧在原数组上进行修改遍历，我们可以通过<strong>记录当前应该去重的数据数量</strong>来确定当前数据<strong>如果不重复应该移动的位置</strong>，不过题目要求是重复两次以上，所以额外再加一个变量记录重复次数。</p><p>这样分析会有三种情况</p><p><strong>当前数据位置与索引位置相等：重复次数+1</strong></p><p>​<strong>且数据重复次数大于两次：则应该去重的数量+1</strong><br>​<strong>否则少于两次应该保留：即需要移动数据</strong></p><p><strong>当前数据位置与索引位置不相等：重复次数重置为1，保留（移动）数据</strong></p><p><strong><u>注意的是：移动数据的目的就是为了保留此数据</u></strong>，因为后面的数据不参与答案校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//重复的数据数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//重复次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - res - <span class="number">1</span>]) &#123;</span><br><span class="line">                count++;<span class="comment">//重复次数+1</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    res++;<span class="comment">//重复次数大于两次：要去重的数量+1</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i - res] = nums[i];<span class="comment">//少于两次重复次数应该移动数据进行保留</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i - res] = nums[i];<span class="comment">//不相等，移动数据进行保留</span></span><br><span class="line">                count = <span class="number">1</span>;<span class="comment">//重置重复次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给你一个有序数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣26 合并两个有序数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode26"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode26</id>
    <published>2025-04-18T01:21:12.000Z</published>
    <updated>2025-04-18T01:21:14.021Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><hr><p>创建一个新数组遍历去重就不多说啦<br>我们看看能不能优化一下，依旧是大小不重要，所以依旧在原数组上进行修改遍历，我们可以通过记录当前重复的数据数量来确定当前数据如果不重复应该移动的位置，比如重复了两个数，那么这个位置未重复的数应该前移两个</p><p><strong>注意的是：</strong><br>记录的是当前重复的数据数所以返回时应该用总数减去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//重复的数据数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - count - <span class="number">1</span>]) count++;<span class="comment">//重复+1</span></span><br><span class="line">            <span class="keyword">else</span> nums[i - count] = nums[i];<span class="comment">//非重复移动（没有重复数则原地赋值也不会出错）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - count; <span class="comment">//总数减去重复数即为非重复数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣27 移除元素</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode27"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode27</id>
    <published>2025-04-18T00:59:47.000Z</published>
    <updated>2025-04-18T00:59:48.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> <strong>移除所有数值等于 <code>val</code> 的元素</strong>。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> <strong>不同的元素的数量</strong>。<br>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><hr><p>简单题，不多赘述；（去创建一个数组遍历我想大家都会）<br>不过由于nums的大小不重要，我们会想到能不能在原数组进行操作？这里可以通过<strong>记录非<code>val</code>的数据的数量</strong>来进行优化</p><p><strong>注意的是：</strong></p><p>count为当前非<code>val</code>的数据数量<br>赋值操作不会覆盖未比较的值（因为count永远比当前索引小）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) </span><br><span class="line">            <span class="keyword">if</span> (num != val) </span><br><span class="line">                nums[count++] = num;<span class="comment">//数据为非val 当前位置赋值 且数量+1</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣88 合并两个有序数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode88"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode88</id>
    <published>2025-04-18T00:35:39.000Z</published>
    <updated>2025-04-20T06:38:39.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。<br>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。<br>**注意：**最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><hr><p>经典的<strong>双指针问题</strong>，可以分别从左往右遍历两个数组来按顺序merge<br>简单题，不多赘述</p><p><strong>注意的是：</strong><br>由于校验的是nums1指针指向的数组（不是传统的返回数据校验）<br>所以我们需要修改的是<strong>原指针指向的数组</strong>，开头去创建一个对象复制原数组用做中间量，<strong>原数组当作结果容器</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//nums1是一个指针，对其赋值源对象不会修改，即原调用方无法感知这件事</span></span><br><span class="line">        <span class="type">int</span>[] copyNum1 = Arrays.copyOf(nums1, m);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; m &amp;&amp; j &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copyNum1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                nums1[i + j] = copyNum1[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[i + j] = nums2[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总会有一方未遍历完，继续赋值</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; m; i++) &#123;</span><br><span class="line">            nums1[i + j] = copyNum1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; n; j++) &#123;</span><br><span class="line">            nums1[i + j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你两个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排列的整数数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;，另有两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>常见打字错误拼音记录</title>
    <link href="https://stars-at-dawn.github.io/posts/b6b3d2a3"/>
    <id>https://stars-at-dawn.github.io/posts/b6b3d2a3</id>
    <published>2024-11-04T01:00:07.000Z</published>
    <updated>2024-11-13T07:03:58.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打字网站推荐">打字网站推荐</h2><p><strong>这个网站不错（免费的还可以自己加文章），大家有空可以来测试一下打字速度！</strong></p><p><a href="https://dazi.91xjr.com/?e57bd12b463dbaaf965fbbe68280069c">https://dazi.91xjr.com/?e57bd12b463dbaaf965fbbe68280069c</a></p><h2 id="前后鼻音">前后鼻音</h2><hr><p><strong>馨 xin</strong> | 温馨 wen xin<br><strong>新 xin  欣 xin  心 xin  信 xin  辛 xin</strong><br><strong>星 xing  兴 xing</strong>  杏 xing</p><p><strong>品 pin  聘 pin  拼 pin  频 pin  贫 pin</strong><br><strong>平 | 评 萍 坪 苹 | ping  屏 ping</strong>  凭 ping  瓶 ping</p><p><strong>今 jin  金 jin  尽 jin 进 jin</strong><br><strong>竟 jing  经 jing</strong></p><p><strong>音 yin  吟 yin</strong>  因 yin  <strong>银 yin</strong> <strong>阴 | 荫 yin</strong><br><strong>应 ying</strong>  英 ying  赢 ying  <strong>影 ying</strong>  荧 ying</p><p><strong>亲 qin</strong>  秦 qin  琴qin<br><strong>青 | 请 清 晴 情 | qing  轻 qing</strong>  庆 qing  氢 qing  卿 qing</p><p><strong>林 | 淋 琳 霖 | lin</strong>  |  <strong>粦 | 麟 鳞 磷 粼 | lin  临 lin  邻 lin</strong><br><strong>令 | 岭 零 领 铃 翎 | ling</strong>  |  <strong>夌 | 凌 陵 绫 | ling  另 ling  灵 ling</strong>  菱 ling</p><hr><p><strong>身 shen  深 shen</strong> 神 shen 伸 shen  甚 shen  慎 shen 绅 shen <strong>什 shen</strong><br><strong>声 sheng  生 sheng  盛 sheng</strong>  圣 sheng  升 sheng  <strong>剩 sheng</strong></p><p><strong>真 zhen</strong>  震 zhen  针 zhen  帧 zhen<br><strong>蒸 zheng  争 | 挣 睁 狰| zheng  正 | 证 政 征 症 怔|zheng</strong></p><p><strong>称 chen | 匀称    cheng | 称呼</strong><br><strong>趁 chen  晨 chen</strong>  沉 chen  <strong>陈 chen  尘 chen</strong>  辰 chen  臣 chen<br><strong>成 cheng  乘 cheng  承 cheng  撑 cheng</strong></p><p><strong>艮 | 跟 根 哏 | gen</strong>  <strong>亘 gen</strong><br><strong>更 | 梗 鲠 哽 | geng</strong>  <strong>耕 geng</strong>  庚 geng  羹 geng</p><p><strong>温 wen 文 wen</strong><br><strong>翁 | 嗡 瓮 | weng</strong></p><p><strong>嫩 nen</strong><br><strong>能 neng</strong></p><p><strong>忍 ren 人 ren 任 ren 仁 ren 刃 | 纫 韧 | ren</strong><br><strong>扔 reng 仍 reng</strong></p><p><strong>盆 | 湓 pen  喷 pen</strong><br><strong>朋 peng  碰 peng</strong></p><p><strong>分 | 粉 份 芬 酚 纷 | fen  奋 fen</strong><br><strong>丰 | 封 沣 | feng  夆 | 峰 蜂 逢 缝 | feng  风 feng  枫 feng</strong></p><hr><p><strong>路 lu 录 lu</strong><br><strong>绿 lv 率 lv 律 lv 屡 lv 虑 lv 缕 lv</strong></p><hr><h2 id="容易错的拼音">容易错的拼音</h2><p><strong>推 tui  堆 dui  丢 diu</strong><br><strong>且 qie  别 bie</strong></p><p><strong>卵 luan</strong> <strong>峦 luan | 峰峦</strong><br><strong>么 me | 多么 duo me  呢 ne  我们 wo men</strong><br><strong>袄 ao | 棉袄 偏颇 pian po</strong><br><strong>怜悯 lián mǐn  冷漠 mo 某 mou</strong><br><strong>呻吟 shen yin</strong> <strong>身影 shen ying</strong> <strong>声音 sheng yin</strong><br><strong>应该 ying gai 因为 yin wei 哽咽 geng ye</strong><br><strong>应当 ying dang 努力 nu li</strong></p><hr><p><strong>E</strong> <strong>R T</strong>    ? \ 都是打字容易出错的</p><hr><h2 id="常错字">常错字</h2><p><strong>身 shen  深 shen 今 jin</strong></p><p><strong>努 nu 很 hen 神 shen</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;打字网站推荐&quot;&gt;打字网站推荐&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个网站不错（免费的还可以自己加文章），大家有空可以来测试一下打字速度！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dazi.91xjr.com/?e57bd12b463dbaa</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    <category term="打字" scheme="https://stars-at-dawn.github.io/tags/%E6%89%93%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>马丁·路德·金《我有一个梦想》演讲稿（中英文双版）</title>
    <link href="https://stars-at-dawn.github.io/posts/36b602fd"/>
    <id>https://stars-at-dawn.github.io/posts/36b602fd</id>
    <published>2024-11-04T00:51:20.000Z</published>
    <updated>2024-11-04T01:05:22.956Z</updated>
    
    <content type="html"><![CDATA[<h1>马丁路德金的演讲稿《我有一个梦想》（中英文双版）</h1><p>《我有一个梦想》是1960年代的美国黑人民权运动领袖马丁·路德·金博士一场极为著名演讲的名称，由于他在该次演说中，强力且有说服力地描述他对于黑人与白人有一天能和平且平等共存的远景时，不断重复使用的“I have a dream”一词。演讲在1963年8月28日华盛顿大游行中，于林肯纪念堂前发表。该演讲促使美国国会在1964年通过《1964年民权法案》宣布所有种族隔离和歧视政策为非法政策。</p><h2 id="中文版全文">中文版全文:</h2><h3 id="我有一个梦想">我有一个梦想</h3><p>100年前，一位伟大的美国人签署了解放黑奴宣言，今天我们就是在他的雕像前集会。这一庄严宣言犹如灯塔的光芒，给千百万在那摧残生命的不义之火中受煎熬的黑奴带来了希望。它之到来犹如欢乐的黎明，结束了束缚黑人的漫漫长夜。然而100年后的今天，我们必须正视黑人还没有得到自由这一悲惨的事实。100年后的今天，在种族隔离的镣铐和种族歧视的枷锁下，黑人的生活备受压榨。100年后的今天，黑人仍生活在物质充裕的海洋中一个穷困的孤岛上。100年后的今天，黑人仍然萎缩在美国社会的角落里，并且意识到自己是故土家园中的流亡者。今天我们在这里集会，就是要把这种骇人听闻的情况公诸于众。</p><p>就某种意义而言，今天我们是为了要求兑现诺言而汇集到我们国家的首都来的。我们共和国的缔造者草拟宪法和独立宣言的气壮山河的词句时，曾向每一个美国人许下了诺言，他们承诺给予所有的人以生存、自由和追求幸福的不可剥夺的权利。</p><p>就有色公民而论，美国显然没有实践她的诺言。美国没有履行这项神圣的义务，只是给黑人开了一张空头支票，支票上盖着“资金不足”的戳子后便退了回来。但是我们不相信正义的银行已经破产，我们不相信，在这个国家巨大的机会之库里已没有足够的储备。因此今天我们要求将支票兑现——这张支票将给予我们宝贵的自由和正义的保障。</p><p>我们来到这个圣地也是为了提醒美国，现在是非常急迫的时刻。现在决非侈谈冷静下来或服用渐进主义的镇静剂的时候。现在是实现民主的诺言时候。现在是从种族隔离的荒凉阴暗的深谷攀登种族平等的光明大道的时候，现在是向上帝所有的儿女开放机会之门的时候，现在是把我们的国家从种族不平等的流沙中拯救出来，置于兄弟情谊的磐石上的时候。</p><p>如果美国忽视时间的迫切性和低估黑人的决心，那么，这对美国来说，将是致命伤。自由和平等的爽朗秋天如不到来，黑人义愤填膺的酷暑就不会过去。1963年并不意味着斗争的结束，而是开始。有人希望，黑人只要撒撒气就会满足；如果国家安之若素，毫无反应，这些人必会大失所望的。黑人得不到公民的权利，美国就不可能有安宁或平静，正义的光明的一天不到来，叛乱的旋风就将继续动摇这个国家的基础。</p><p>但是对于等候在正义之宫门口的心急如焚的人们，有些话我是必须说的。在争取合法地位的过程中，我们不要采取错误的做法。我们不要为了满足对自由的渴望而抱着敌对和仇恨之杯痛饮。我们斗争时必须永远举止得体，纪律严明。我们不能容许我们的具有崭新内容的抗议蜕变为暴力行动。我们要不断地升华到以精神力量对付物质力量的崇高境界中去。</p><p>现在黑人社会充满着了不起的新的战斗精神，但是不能因此而不信任所有的白人。因为我们的许多白人兄弟已经认识到，他们的命运与我们的命运是紧密相连的，他们今天参加游行集会就是明证。他们的自由与我们的自由是息息相关的。我们不能单独行动。</p><p>当我们行动时，我们必须保证向前进。我们不能倒退。现在有人问热心民权运动的人，“你们什么时候才能满足？”只要黑人仍然遭受警察难以形容的野蛮迫害，我们就绝不会满足。只要我们在外奔波而疲乏的身躯不能在公路旁的汽车旅馆和城里的旅馆找到住宿之所，我们就绝不会满足。只要黑人的基本活动范围只是从少数民族聚居的小贫民区转移到大贫民区，我们就绝不会满足。只要密西西比仍然有一个黑人不能参加选举，只要纽约有一个黑人认为他投票无济于事，我们就绝不会满足。</p><p>不！我们现在并不满足，我们将来也不满足，除非正义和公正犹如江海之波涛，汹涌澎湃，滚滚而来。</p><p>我并非没有注意到，参加今天集会的人中，有些受尽苦难和折磨，有些刚刚走出窄小的牢房，有些由于寻求自由，曾在居住地惨遭疯狂迫害的打击，并在警察暴行的旋风中摇摇欲坠。你们是人为痛苦的长期受难者。坚持下去吧，要坚决相信，忍受不应得的痛苦是一种赎罪。</p><p>让我们回到密西西比去，回到亚拉巴马去，回到南卡罗来纳去，回到佐治亚去，回到路易斯安那去，回到我们北方城市中的贫民区和少数民族居住区去，要心中有数，这种状况是能够也必将改变的。我们不要陷入绝望而不可自拔。</p><p>朋友们，今天我对你们说，在此时此刻，我们虽然遭受种种困难和挫折，我仍然有一个梦想，这个梦想是深深扎根于美国的梦想中的。</p><p>我梦想有一天，这个国家会站立起来，真正实现其信条的真谛：“我们认为这些真理是不言而喻的，人人生而平等。”</p><p>我梦想有一天，在佐治亚的红山上，从前奴隶的后嗣将能够和奴隶主的后嗣坐在一起，共叙兄弟情谊。</p><p>我梦想有一天，甚至连密西西比州这个正义匿迹，压迫成风，如同沙漠般的地方，也将变成自由和正义的绿洲。我梦想有一天，我的四个孩子将在一个不是以他们的肤色，而是以他们的品格优劣来评价他们的国度里生活。</p><p>我今天有一个梦想。我梦想有一天，亚拉巴马州能够有所转变，尽管该州州长现在仍然满口异议，反对联邦法令，但有朝一日，那里的黑人男孩和女孩将能与白人男孩和女孩情同骨肉，携手并进。</p><p>我今天有一个梦想。我梦想有一天，幽谷上升，高山下降；坎坷曲折之路成坦途，圣光披露，满照人间。这就是我们的希望。我怀着这种信念回到南方。有了这个信念，我们将能从绝望之岭劈出一块希望之石。有了这个信念，我们将能把这个国家刺耳的争吵声，改变成为一支洋溢手足之情的优美交响曲。 有了这个信念，我们将能一起工作，一起祈祷，一起斗争，一起坐牢，一起维护自由；因为我们知道，终有一天，我们是会自由的。</p><p>在自由到来的那一天，上帝的所有儿女们将以新的含义高唱这支歌：“我的祖国，美丽的自由之乡，我为您歌唱。您是父辈逝去的地方，您是最初移民的骄傲，让自由之声响彻每个山岗。”</p><p>如果美国要成为一个伟大的国家，这个梦想必须实现。让自由之声从新罕布什尔州的巍峨的崇山峻岭响起来！让自由之声从纽约州的崇山峻岭响起来！让自由之声从科罗拉多州冰雪覆盖的落基山响起来！让自由之声从加利福尼亚州蜿蜒的群峰响起来！不仅如此，还要让自由之声从佐治亚州的石岭响起来！让自由之声从田纳西州的了望山响起来！ 让自由之声从密西西比的每一座丘陵响起来！让自由之声从每一片山坡响起来。</p><p>当我们让自由之声响起来，让自由之声从每一个大小村庄、每一个州和每一个城市响起来时，我们将能够加速这一天的到来，那时，上帝的所有儿女，黑人和白人，犹太教徒和非犹太教徒，耶稣教徒和天主教徒，都将手携手，合唱一首古老的黑人灵歌：“终于自由啦！终于自由啦！感谢全能天父，我们终于自由啦！”</p><h2 id="英文版全文">英文版全文:</h2><h3 id="I-Have-a-Dream">I Have a Dream</h3><p>I am happy to join with you today in what will go down in history as the greatest demonstration for freedom in the history of our nation.</p><p>Five score years ago, a great American, in whose symbolic shadow we stand today, signed the Emancipation Proclamation. This momentous decree came as a great beacon light of hope to millions of Negro slaves who had been seared in the flames of withering injustice. It came as a joyous daybreak to end the long night of their captivity.</p><p>But one hundred years later, the Negro still is not free. One hundred years later, the life of the Negro is still sadly crippled by the manacles of segregation and the chains of discrimination. One hundred years later, the Negro lives on a lonely island of poverty in the midst of a vast ocean of material prosperity. One hundred years later, the Negro is still languished in the corners of American society and finds himself an exile in his own land. And so we’ve come here today to dramatize a shameful condition.</p><p>In a sense we’ve come to our nation’s capital to cash a check. When the architects of our republic wrote the magnificent words of the Constitution and the Declaration of Independence, they were signing a promissory note to which every American was to fall heir. This note was a promise that all men, yes, black men as well as white men, would be guaranteed the “unalienable Rights” of “Life, Liberty and the pursuit of Happiness.” It is obvious today that America has defaulted on this promissory note, insofar as her citizens of color are concerned. Instead of honoring this sacred obligation, America has given the Negro people a bad check, a check which has come back marked “insufficient funds.”</p><p>But we refuse to believe that the bank of justice is bankrupt. We refuse to believe that there are insufficient funds in the great vaults of opportunity of this nation. And so, we’ve come to cash this check, a check that will give us upon demand the riches of freedom and the security of justice.</p><p>We have also come to this hallowed spot to remind America of the fierce urgency of Now. This is no time to engage in the luxury of cooling off or to take the tranquilizing drug of gradualism. Now is the time to make real the promises of democracy. Now is the time to rise from the dark and desolate valley of segregation to the sunlit path of racial justice. Now is the time to lift our nation from the quicksands of racial injustice to the solid rock of brotherhood. Now is the time to make justice a reality for all of God’s children.</p><p>It would be fatal for the nation to overlook the urgency of the moment. This sweltering summer of the Negro’s legitimate discontent will not pass until there is an invigorating autumn of freedom and equality. Nineteen sixty-three is not an end, but a beginning. And those who hope that the Negro needed to blow off steam and will now be content will have a rude awakening if the nation returns to business as usual. And there will be neither rest nor tranquility in America until the Negro is granted his citizenship rights. The whirlwinds of revolt will continue to shake the foundations of our nation until the bright day of justice emerges.</p><p>But there is something that I must say to my people, who stand on the warm threshold which leads into the palace of justice: In the process of gaining our rightful place, we must not be guilty of wrongful deeds. Let us not seek to satisfy our thirst for freedom by drinking from the cup of bitterness and hatred. We must forever conduct our struggle on the high plane of dignity and discipline. We must not allow our creative protest to degenerate into physical violence. Again and again, we must rise to the majestic heights of meeting physical force with soul force.</p><p>The marvelous new militancy which has engulfed the Negro community must not lead us to a distrust of all white people, for many of our white brothers, as evidenced by their presence here today, have come to realize that their destiny is tied up with our destiny. And they have come to realize that their freedom is inextricably bound to our freedom.</p><p>We cannot walk alone.</p><p>And as we walk, we must make the pledge that we shall always march ahead.</p><p>We cannot turn back.</p><p>There are those who are asking the devotees of civil rights, “When will you be satisfied?” We can never be satisfied as long as the Negro is the victim of the unspeakable horrors of police brutality. We can never be satisfied as long as our bodies, heavy with the fatigue of travel, cannot gain lodging in the motels of the highways and the hotels of the cities. <strong>We cannot be satisfied as long as the negro’s basic mobility is from a smaller ghetto to a larger one. We can never be satisfied as long as our children are stripped of their self-hood and robbed of their dignity by signs stating: “For Whites Only.”</strong> We cannot be satisfied as long as a Negro in Mississippi cannot vote and a Negro in New York believes he has nothing for which to vote. No, no, we are not satisfied, and we will not be satisfied until “justice rolls down like waters, and righteousness like a mighty stream.”</p><p>I am not unmindful that some of you have come here out of great trials and tribulations. Some of you have come fresh from narrow jail cells. And some of you have come from areas where your quest – quest for freedom left you battered by the storms of persecution and staggered by the winds of police brutality. You have been the veterans of creative suffering. Continue to work with the faith that unearned suffering is redemptive. Go back to Mississippi, go back to Alabama, go back to South Carolina, go back to Georgia, go back to Louisiana, go back to the slums and ghettos of our northern cities, knowing that somehow this situation can and will be changed.</p><p>Let us not wallow in the valley of despair, I say to you today, my friends.</p><p>And so even though we face the difficulties of today and tomorrow, I still have a dream. It is a dream deeply rooted in the American dream.</p><p>I have a dream that one day this nation will rise up and live out the true meaning of its creed: “We hold these truths to be self-evident, that all men are created equal.”</p><p>I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood.</p><p>I have a dream that one day even the state of Mississippi, a state sweltering with the heat of injustice, sweltering with the heat of oppression, will be transformed into an oasis of freedom and justice.</p><p>I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character.</p><p>I have a dream today!</p><p>I have a dream that one day, down in Alabama, with its vicious racists, with its governor having his lips dripping with the words of “interposition” and “nullification” – one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers.</p><p>I have a dream today!</p><p>I have a dream that one day every valley shall be exalted, and every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight; &quot;and the glory of the Lord shall be revealed and all flesh shall see it together.&quot;2</p><p>This is our hope, and this is the faith that I go back to the South with.</p><p>With this faith, we will be able to hew out of the mountain of despair a stone of hope. With this faith, we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith, we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day.</p><p>And this will be the day – this will be the day when all of God’s children will be able to sing with new meaning:</p><p>My country 'tis of thee, sweet land of liberty, of thee I sing. Land where my fathers died, land of the Pilgrim’s pride, From every mountainside, let freedom ring!</p><p>And if America is to be a great nation, this must become true.</p><p>And so let freedom ring from the prodigious hilltops of New Hampshire.</p><p>Let freedom ring from the mighty mountains of New York.</p><p>Let freedom ring from the heightening Alleghenies of Pennsylvania.</p><p>Let freedom ring from the snow-capped Rockies of Colorado.</p><p>Let freedom ring from the curvaceous slopes of California.</p><p>But not only that:</p><p>Let freedom ring from Stone Mountain of Georgia.</p><p>Let freedom ring from Lookout Mountain of Tennessee.</p><p>Let freedom ring from every hill and molehill of Mississippi.</p><p>From every mountainside, let freedom ring.</p><p>And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God’s children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual:</p><p>Free at last! Free at last!</p><p>Thank God Almighty, we are free at last!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;马丁路德金的演讲稿《我有一个梦想》（中英文双版）&lt;/h1&gt;
&lt;p&gt;《我有一个梦想》是1960年代的美国黑人民权运动领袖马丁·路德·金博士一场极为著名演讲的名称，由于他在该次演说中，强力且有说服力地描述他对于黑人与白人有一天能和平且平等共存的远景时，不断重复使用的“I ha</summary>
      
    
    
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="书籍" scheme="https://stars-at-dawn.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>PS笔记</title>
    <link href="https://stars-at-dawn.github.io/posts/f2995328"/>
    <id>https://stars-at-dawn.github.io/posts/f2995328</id>
    <published>2024-11-02T02:39:28.000Z</published>
    <updated>2024-11-02T02:40:17.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快捷键">快捷键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">shift + 滚轮  垂直加速移动</span><br><span class="line">ctrl  + 滚轮  水平移动</span><br><span class="line">alt   + 滚轮放大缩小</span><br><span class="line">ctrl  +/-  放大缩小</span><br><span class="line">ctrl + K 首选项</span><br><span class="line"></span><br><span class="line">alt + 选择图层显示（小眼睛） 只显示当前选中图层 隐藏其它图层</span><br><span class="line"></span><br><span class="line">alt + 拖动图层 快速复制图层到指定位置</span><br><span class="line">delete/backspace 删除当前图层</span><br><span class="line">ctrl + J 复制当前选中（或者选区选中的）图层 并放到当前图层上方</span><br><span class="line">ctrl + shift + J 剪切当前选中（或者选区选中的）图层</span><br><span class="line"></span><br><span class="line">ctrl + T 自由变换</span><br><span class="line">ctrl + shift + T 重复上一次的自由变换</span><br><span class="line">ctrl + shift + alt + T 重复上一次的自由变换并复制到新图层 原图层不变</span><br><span class="line"></span><br><span class="line">alt + 选择工具 进行同类型工具的切换</span><br><span class="line"></span><br><span class="line">alt + delete 填充前景色</span><br><span class="line">shift + f5/backspace 快速填充</span><br><span class="line"></span><br><span class="line">ctrl + E 合并图层</span><br><span class="line"></span><br><span class="line">ctrl + G 对选中图层创建组</span><br><span class="line">ctrl + shift + G 对选中组取消组 </span><br><span class="line">ctrl + alt + G 创建剪切蒙版</span><br><span class="line"></span><br><span class="line">ctrl + U 快速打开色相和饱和度调节窗口</span><br><span class="line"></span><br><span class="line">抓手工具：</span><br><span class="line">space 长按可以临时切换抓手工具</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">选择工具（选区线又称蚂蚁线）：</span><br><span class="line"></span><br><span class="line">按V 快速切换选择工具</span><br><span class="line">长按ctrl 临时开启自动选择（工具栏里）功能</span><br><span class="line"></span><br><span class="line">alt 快速移动复制图层</span><br><span class="line">shift 限制移动方向 45°移动或是水平垂直移动</span><br><span class="line"></span><br><span class="line">选择工具选中图层拖拽到别的文件时 按住shift可以按原来位置复制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">选框工具（新增 添加 减去 相交 四种模式）：</span><br><span class="line">按M 快速切换矩形（或圆）选框工具</span><br><span class="line"></span><br><span class="line">选取时 按住shift 正形选取</span><br><span class="line">选取前 按住shift 切换模式（顶上工具栏）新增变成添加模式（其它选择工具同样适用）</span><br><span class="line"></span><br><span class="line">选取时 按住alt   选取（中心放大）（可以和shift合用）</span><br><span class="line">选取前 按住alt   切换模式（顶上工具栏）新增变成减去模式（其它选择工具同样适用）</span><br><span class="line"></span><br><span class="line">ctrl + H 隐藏/显示选区（不是删除）</span><br><span class="line">ctrl + D 取消选区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">套索工具：</span><br><span class="line">按L 快速切换套索工具</span><br><span class="line"></span><br><span class="line">  多边形套索工具： </span><br><span class="line">delete/backspace 撤销上一个点</span><br><span class="line">esc 取消当前操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">魔棒工具：</span><br><span class="line">按W 快速切换魔棒工具</span><br><span class="line"></span><br><span class="line">画笔工具：</span><br><span class="line">按B 快速切换画笔工具</span><br><span class="line">按住 shift 限制方向垂直或水平 或  将上一个点与当前点相连</span><br><span class="line">alt 快速切换吸管工具 同时按下右键可以切换画笔大小</span><br><span class="line">【 】 左右中括号调大小</span><br><span class="line"></span><br><span class="line">橡皮工具：</span><br><span class="line">按E 快速切换橡皮工具</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修复工具：</span><br><span class="line">按J 快速切换修复工具</span><br><span class="line"></span><br><span class="line">油漆桶工具：</span><br><span class="line">按G 快速切换修复工具</span><br><span class="line"></span><br><span class="line">按Q 切换快速蒙版模式</span><br><span class="line"></span><br><span class="line">按P 切换快速钢笔工具</span><br><span class="line">enter 隐藏路径</span><br><span class="line">ctrl 切换选择工具</span><br><span class="line"></span><br><span class="line">camera raw  细节调整时可以按住alt键 显示黑白视图</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="颜色知识">颜色知识</h2><p>**色相 **</p><p><strong>饱和度</strong></p><p><strong>明度</strong></p><h3 id="六大色调">六大色调</h3><p><strong>对应的色板方位</strong>：</p><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><p><strong>纯色调</strong>：<strong>冲击 活力</strong> <u>廉价</u>   促销海报     色板方位：3</p><p><strong>明色调</strong>：<strong>年轻 阳光 活力</strong> <u>平淡缺少格局</u>  大众商品/耐用商品   色板方位：2</p><p><strong>淡色调</strong>：<strong>天真 女性 纤细 轻快 高档</strong>  <u>单薄 软弱</u>  女装/女性消费品  色板方位：1</p><p><strong>白色调</strong>：<strong>文艺 素雅 简洁 干净 高档</strong> <u>单调 缺少个性</u>   色板方位：1</p><p><strong>暗色调</strong>：<strong>品质 高档 历史 力量 厚重 古典 地位</strong> <u>压抑 阴暗 危险</u>  高端奢侈品  色板方位：7</p><p><strong>灰色调</strong>：<strong>成熟 稳重 优雅 文艺</strong> <u>脏</u>  男装/男性消费品  色板方位：5</p><h3 id="六大平衡">六大平衡</h3><p><strong>色调平衡</strong>/深浅平衡：   海报内容/摄像</p><p>使用多种色调来平衡互补<strong>表现力</strong></p><p>颜色是有<strong>重量</strong>的 <strong>差距太小 文字就看不清内容就凸现不出来</strong><br><strong>黄 绿 青 白 偏轻   红 橙 蓝 紫 黑 偏重</strong></p><p><strong>冷暖平衡</strong>：   海报内容/摄像/影视后期/渐变色</p><p>平衡色彩给受众带来的<strong>情感失衡</strong></p><p><strong>互补平衡</strong>：   网页/海报/现实艺术（家装等）</p><p><strong>互补色</strong>平衡</p><p><strong>花色和纯色平衡</strong>：   画面聚焦/缓解视觉疲劳/突出信息/衣服搭配</p><p>当背景很花没有规则时，我们需要用纯色来平衡</p><p><strong>有彩色和无彩色的平衡</strong>：   画面聚焦/缓解视觉疲劳/突出信息/衣服搭配</p><p>打破单调配色 突出主体和文字</p><p><strong>面积平衡</strong>：</p><p>点缀色突出</p><p>有透气 有层次 也就是俗称的 <strong>主色（70%）/辅助色（25%）/点缀色（5%）</strong></p><h3 id="光色原理">光色原理</h3><p><strong>光 产生了 颜色</strong></p><p>颜色不是自发产生的（<strong>颜色是反射光或者产生光</strong> 出现的）</p><p><strong>所以物体的“固有色”</strong>（认知上的颜色 比如黄色的橘子）<strong>是会根据环境而变化的</strong></p><h3 id="情绪化表达">情绪化表达</h3><p><strong>颜色是具有情绪化能量的</strong>：红色对应热情等等</p><h2 id="排版">排版</h2><p><strong>对齐</strong></p><p><strong>对比</strong></p><p><strong>分组</strong></p><p><strong>黄金分割比 1：1.618</strong></p><p><strong>根据行业 用户气质来选择 字体 色彩 体现设计感</strong></p><h2 id="其它">其它</h2><p>仿制图章使用时 按住 shift + alt + &gt;/&lt; 可以<strong>调节仿制图章的角度</strong> <strong>/</strong> 或者在右边的<strong>选项菜单</strong>进行手动调节</p><p>仿制图章右边的<strong>选项菜单</strong> 可以调整水平反向 <strong>用来复制对称图形</strong></p><p><strong>上档</strong>就是<strong>shift</strong>键（切换键），上档是一个从打字机时代遗留的俗称，当时打字机有一个类似的键可以切换上下档位。<br>同理现在换行的<strong>enter</strong>键叫做“<strong>回车</strong>”，也是因为当时打字机的这个键是用来将“车”这个结构回到一行的开始。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快捷键&quot;&gt;快捷键&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    <category term="PS" scheme="https://stars-at-dawn.github.io/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>Excel笔记</title>
    <link href="https://stars-at-dawn.github.io/posts/62923"/>
    <id>https://stars-at-dawn.github.io/posts/62923</id>
    <published>2024-11-02T02:38:04.000Z</published>
    <updated>2024-11-02T02:38:05.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快捷键："><strong>快捷键：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ctrl + E 快速填充</span><br><span class="line">ctrl + Q 快速分析</span><br><span class="line">ctrl + T 对普通区域创建表</span><br><span class="line">ctrl + N 新建工作簿</span><br><span class="line"></span><br><span class="line">ctrl + shift + 上下 快速选中左右列</span><br><span class="line">ctrl + shift + 左右 快速选中左右行</span><br><span class="line">上面两个组合使用也可以快速选中整个表或者多行多列</span><br><span class="line"></span><br><span class="line">ctrl + ； 生成日期</span><br><span class="line">ctrl + shift + ； 生成时间</span><br><span class="line"></span><br><span class="line">tab 下一个单元格</span><br><span class="line">shift + tab 上一个单元格</span><br><span class="line">Enter 下一行（指向上一行最初选中的单元格列）</span><br><span class="line">shift + Enter 上一行</span><br><span class="line">ctrl  + Enter 停留原始单元格光标不再往下 / 原位填充 填充相同内容到所选单元格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f4 输入公式时 选择单元格可以设置锁定列或行</span><br><span class="line">alt + = 快速求和</span><br></pre></td></tr></table></figure><h2 id="输入格式">输入格式</h2><p>分数输入 可以使用小数 或者 以下格式输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1/5  -----&gt; 这样会输入分数 </span><br><span class="line">1/5    -----&gt; 否则就会变成日期</span><br></pre></td></tr></table></figure><p>文本格式输入数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;123456789012345678  -----&gt; 最长只有15位 像身份证18位的就无法存储了</span><br><span class="line"> 123456789012345678  -----&gt; 变成123456789012345000 </span><br><span class="line">                     -----&gt; 抹去后面的位数精度 并采用科学计数法显示</span><br></pre></td></tr></table></figure><h2 id="格式">格式</h2><p>**开始组 ** <strong>格式选项</strong> <strong>中可以调整</strong>   <strong>列宽和行宽</strong></p><p>文本<strong>多列居中</strong>一般不采用合并居中 采用<strong>跨列居中</strong> 在开始组 <strong>对齐选项卡的小三角</strong> 里可以找到</p><p>双击<strong>顶部字母中间</strong>自动调整<strong>宽度</strong> 或者在开始组<strong>单元格格式</strong>下的选项中找到调整<strong>宽度</strong></p><h3 id="自定义数字格式：">自定义数字格式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 代表必须占位符 无则会添加0补齐</span><br><span class="line"># 代表弱占位符， 无则不会填充</span><br><span class="line">？特殊占位符，   无则会补空格</span><br><span class="line">小数位数不够时会自动四舍五入</span><br></pre></td></tr></table></figure><h3 id="文本自定义格式：">文本自定义格式：</h3><p><strong>@表示当前字符串</strong></p><p><strong>可以同时设定四个区域格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0;-0;0;@  正数;负数;零值;文本</span><br><span class="line">[红色]0;-0;0;@  [设置文本颜色]</span><br></pre></td></tr></table></figure><p><strong>条件设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置格式[条件1];设置格式[条件2];设置格式//都不满足则默认</span><br></pre></td></tr></table></figure><h2 id="函数"><strong>函数</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">count 计算数字单元格个数</span><br><span class="line">countA 计算非空单元格个数</span><br><span class="line">countBlank 计算空单元格个数</span><br><span class="line">countif</span><br><span class="line">countifs 多条件都满足的单元格个数</span><br><span class="line"></span><br><span class="line">通配符</span><br><span class="line">* 任意多个字符</span><br><span class="line">? 任意单个字符</span><br><span class="line">~ 转义字符 如 ~* 表示*字符的文本</span><br><span class="line"></span><br><span class="line">&amp; 文本连接符 可以输入单元格而不是变成文本</span><br><span class="line"></span><br><span class="line">VLOOKUP(搜素目标,搜索范围,输出的相对列号,1表示模糊匹配/0表示精确匹配) //搜索范围查找的是第一列</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><s>IF({column1.copplumn2},列范围,列范围) 可以转换列的顺序</s></p><h2 id="其它">其它</h2><p>表格的箭头<strong>右键</strong>可以查看所有表格 <strong>ctrl +左键</strong>转到队尾</p><p>开始选项卡中 <strong>填充</strong>功能可以快速<strong>生成指定序号</strong>等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快捷键：&quot;&gt;&lt;strong&gt;快捷键：&lt;/strong&gt;&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Excel" scheme="https://stars-at-dawn.github.io/tags/Excel/"/>
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PR笔记</title>
    <link href="https://stars-at-dawn.github.io/posts/54ee589c"/>
    <id>https://stars-at-dawn.github.io/posts/54ee589c</id>
    <published>2024-11-02T02:37:16.000Z</published>
    <updated>2024-11-02T02:40:17.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技巧">技巧</h2><p>素材可以进行<strong>子剪辑</strong> 创建选中的片段视频</p><p>高清大素材 可以创建<strong>代理</strong> 加速处理 文件输出会自动采用高清版本输出<br>帧率不固定的素材会出现<strong>音画不同步</strong>（最麻烦的）以及<strong>原素材对不上</strong>（<strong>导出的时候直接选择使用代理不使用原素材了</strong>）的问题</p><p>可以对序列上的一部分内容进行<strong>嵌套</strong> 组合成为一个<strong>新的序列</strong></p><p>右击素材选择<strong>时间重映射</strong>可以进行视频加速播放<br>同时<strong>CTRL 点击素材上的时间线添加关键帧</strong> 拖动时间线进行加速<br>拖动关键帧的标点进行速度的过渡添加</p><p>顶上序列选项中有合并功能，<strong>快速删除多个素材中间的空隙</strong></p><p>注：<strong>Adobe ME 退出软件后渲染的视频是不保存的</strong><br><strong>但暂停是可以的</strong></p><h2 id="快捷键">快捷键</h2><h3 id="常用：">常用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R 比率拉伸工具</span><br><span class="line">V 选择工具</span><br><span class="line">C 裁切工具</span><br><span class="line">A 全选当前位置右边的所有素材</span><br><span class="line"></span><br><span class="line">J预览倒放倍速播放</span><br><span class="line"></span><br><span class="line">L预览正放倍速播放</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ctrl + ~ 全屏显示面板</strong>（常用来预览最终的视频效果）<br>shift + ~ 最大化显示选中的面板</p><p><strong>shift + up/down</strong> 跳转到序列上/下一个<strong>编辑点</strong></p><hr><h2 id="插件内容">插件内容</h2><p><strong>B站有分享插件大全的</strong></p><h3 id="Arctime-Pro字幕软件">Arctime Pro字幕软件</h3><p>【使用教程】<br><a href="http://arctime.cn/zh/guide.html">http://arctime.cn/zh/guide.html</a><br><a href="https://www.bilibili.com/video/av8506209?from=search&amp;seid=8847056251364617663">https://www.bilibili.com/video/av8506209?from=search&amp;seid=8847056251364617663</a><br><a href="https://www.bilibili.com/video/av36162598?from=search&amp;seid=8847056251364617663">https://www.bilibili.com/video/av36162598?from=search&amp;seid=8847056251364617663</a><br><a href="https://search.bilibili.com/all?keyword=PR%20Arctime&amp;from_source=banner_search">https://search.bilibili.com/all?keyword=PR Arctime&amp;from_source=banner_search</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;技巧&quot;&gt;技巧&lt;/h2&gt;
&lt;p&gt;素材可以进行&lt;strong&gt;子剪辑&lt;/strong&gt; 创建选中的片段视频&lt;/p&gt;
&lt;p&gt;高清大素材 可以创建&lt;strong&gt;代理&lt;/strong&gt; 加速处理 文件输出会自动采用高清版本输出&lt;br&gt;
帧率不固定的素材会出现&lt;strong</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    <category term="PR" scheme="https://stars-at-dawn.github.io/tags/PR/"/>
    
  </entry>
  
  <entry>
    <title>记录片推荐</title>
    <link href="https://stars-at-dawn.github.io/posts/9582e118"/>
    <id>https://stars-at-dawn.github.io/posts/9582e118</id>
    <published>2024-11-02T02:32:45.000Z</published>
    <updated>2024-11-02T02:40:17.591Z</updated>
    
    <content type="html"><![CDATA[<h1>记录片</h1><h2 id="科技：">科技：</h2><h2 id="人文：">人文：</h2><h3 id="《天地玄黄》">《天地玄黄》</h3><h3 id="《一百年很长吗》">《一百年很长吗》</h3><p>2024.8</p><p>“家有千金不如朝夕为人”</p><p>以前老师上课时候，讲自己教书育人，是先生。<br>我觉得，这几位老先生，也是有自己风骨的先生。印章用的少了，老先生的字还是有风骨。阿勒泰的马鞍留存在游牧人的马背上，或许人没有感觉差异，但是游牧民族的灵魂看得见。<br>手艺的传承，是几代人口手相传的。一辈子没有那么长，百年以前，也是这样的老先生们，把手艺在瓦缝溜下来的光里，和昏黄的烛台旁边，留存下来。<br>老爷子说以前人活七十古来稀，现在八九十岁也常见。<br>不管是什么手艺，以前会了一门活计是骄傲的，像是武林中的门派，弟子热络不绝。而今青瓦房里，先生们，活的是留存的武林气息。<br>先生，高义。<a href="B%E7%AB%99">^4</a></p><h3 id="《超级顾客-第一季》">《超级顾客 第一季》</h3><p>2024.7</p><p>产品的本质真的像广告宣传所说的那样吗？连锁店的产品价格是一样的吗？大牌产品和不知名的品牌之间有着巨大的价格差异，但是，品质也是相差如此之大吗？性价比呢？你一直使用的所谓优质产品，和别的产品之间有什么不同？为什么不同品牌的产品，有时候你觉得是同样的东西？本节目将深入了解产品内幕，揭开品牌和零售商的假面具，寻找价廉物美的产品，让你先人一步，成为更精明的消费者。<a href="B%E7%AB%99">^4</a></p><h3 id="《无节制消费的元凶》">《无节制消费的元凶》</h3><p>2024.6</p><p>我们为什会买东西？谁让这个世界变得无节制消费？他们如何做到这一点？调查记者雅克•佩雷蒂审视了无节制消费潮流背后的机制，得出了答案。原来，使这个世界变得无节制消费的元凶，并不是人们普遍认为的广告员和市场推广员，而是这诸多表象背后那个首先改变了产品，然后改变我们的人。<a href="B%E7%AB%99">^4</a></p><p>无节制消费的元凶：</p><ol><li><strong>计划报废，规定期限</strong>。演变到瞬间报废（一次性消费）；</li><li>改变消费心理，有序制造不满情绪，<strong>培养淘汰观念</strong></li><li>**恐惧植入，提供解决方案。**商家唤起我们的恐惧和焦虑情绪，对逃避死亡、健康、医疗、美容、灭菌，<strong>利用信用卡延迟消费痛苦</strong>；</li><li><strong>缩减从想要购买到支付的思考时间</strong>，刷脸支付，小额免密码支付。</li><li>从孩童入手，<strong>创造故事，周边购买。从小灌输的消费观念</strong>，动画片《变形金刚》把广告拍成电影。</li><li><strong>营销使成年人变成小孩消费</strong>，漫展和利用孩子反向营销成人（丰田小汽车案例）、</li><li>游戏及时奖励，刺激多巴胺。<br><strong>永远提供更好的产品——无节制消费的元凶</strong></li></ol><h3 id="《美国商业大亨传奇》">《美国商业大亨传奇》</h3><p>2024.6</p><p>那个时代的美国真的很激动人心，<strong>垄断、恶意并购、低价倾销</strong>都是从他们开始的</p><p>一、范德比尔特。铁路大亨<br>创新-运输新货物即石油-敏锐发现市场需要</p><p>二、洛克菲勒。石油大亨-美国标准石油公司<br>相信自己-分析问题-选择低成本业务-效率至上-理论联系实际创造竞争优势：管道运输、提炼出煤油到提炼出汽油。</p><p>三、卡内基。钢铁大亨<br>发现钢-炼造钢-建造桥-建楼<br>搭档：弗里克造成约翰斯顿洪水事件<br>伯乐：斯科特-宾夕法尼亚铁路公司</p><p>四、摩根（约翰·皮尔庞特·摩根）。金融大亨-美国通用电器公司<br>对手：威斯汀豪斯的美国钢铁公司<br>爱迪生vs特斯拉（原来爱迪生也有小人的一面）、麦金莱vs布莱恩、罗斯福上位-反托拉斯（破垄断）</p><p>五、福特。汽车大亨</p><p>要有胆量-满足市场需要</p><p>没有他们可能美国的崛起不会这么快吧<a href="B%E7%AB%99">^4</a></p><h2 id="自然：">自然：</h2><h3 id="《史前星球-第一季》">《史前星球 第一季》</h3><p>2024.6</p><h3 id="《地球脉动-第三季》">《地球脉动 第三季》</h3><p>2024.5</p><p>：由 <a href="https://www.douban.com/personage/27250858/">大卫·爱登堡</a> 主演</p><p>从海洋深处到最偏远的丛林，《地球脉动III》为经典巨制翻开崭新篇章，继续造访地球上众多令人称奇的栖息地，观众将跟随镜头探索这颗星球上最后的天然野境，领略野生动物进化出的绝妙生存策略。同时，也展现出荒野之境和生在其中的野生动物对维持地球健康运转的独特意义，饱含对大自然的敬畏、礼赞与关怀。</p><p>汹涌的海浪淹没冲浪的人，冲毁火烈鸟的巢穴，危机40%人口沿海的家园，却能拯救海滩无助的海龟。 人本位的思维禁锢着世界，我们试图消除一切威胁人类生存的元素，但如果这个世界是鱼本位、鸟本位、鲸本位，甚至是龟本位，地球会不会有所不同？ 地球脉动用别样的视角，探索这个复杂星球上不同物种的生存际遇。当澳大利亚的沙土运到雷恩岛时，海龟会不会感谢人类？我们无从得知，但我们必须清晰地认识到平等的生存关系，人和其它动物是共享这个星球，它们的生存权利并非人类施舍，<strong>是天授</strong>。<a href="%E8%B1%86%E7%93%A3%E7%BD%91">^3</a></p><h3 id="《绿色星球》">《绿色星球》</h3><p>2024.5</p><p>绿色星球节目是首个通过沉浸式的呈现方式聚焦植物的纪录片，为观众们展示了这个低调秘密、不为人知的植物世界。它们既能与动物形成互惠互利的关系，也可以像我们星球上的任何生物一样具有攻击性、竞争性和戏剧性。为争夺光照、空间、营养和为家族开枝散叶的机会，它们会与竞争对手、动物和元素进行致命的斗争。<br>　　本片展示了跨越20多年的新发现，同时揭示了相互紧密联系的植物世界。专业摄像机使我们拥有超越人眼的能力，比以往任何时候都观察的更贴近与深入。<br>　　全新的故事，前所未见的动植物行为，令人惊讶的英雄，带你从植物的角度看地球。<a href="%E8%B1%86%E7%93%A3%E7%BD%91">^3</a></p><p>这部由BBC Studios自然历史部耗时四年完成的作品，被影评人称作**“全球首部沉浸式聚焦植物的纪录片”**。</p><h1>电影</h1><h2 id="戏剧：">戏剧：</h2><h3 id="《城市之光》">《城市之光》</h3><p>2024.8</p><p>​        真是讽刺，盲人心存光明，穷人拥有富人没有的爱情，善良之人锒铛入狱，恶徒却逍遥法外，富人随意漏出来的财富都是穷人用生命也换不来的东西，富人在清醒时永远不会与穷人为伍，人在糊涂时才会有真性情</p><h3 id="《大独裁者》">《大独裁者》</h3><p>2024.8</p><p>​        影片讲述第一次世界大战，托曼尼亚王国独裁者辛格尔（查理·卓别林饰）上台。他的大肆扩张导致战乱不断民不聊生。并且他大搞阴谋政策，煽动民众对犹太人的敌对与仇恨，让犹太人民陷入水深火热的灾难之中。被征入伍的犹太人理发师查理（查理·卓别林饰）更是在这样的高压政策下难逃一劫。当查理逃出边境时，被驻守在这里的军队误认为是独裁者辛格尔，他趁机做了一场“为自由而战斗”的大演说。<a href="%E8%B1%86%E7%93%A3%E7%BD%91">^3</a></p><p><strong>“独裁者会死去，他们从人民手里夺去的权利即将归还人民”。</strong></p><h3 id="《摩登时代》">《摩登时代》</h3><p>2024.8</p><p>​        二十年代的美国处于经济萧条时期，失业率居高不下，工人受尽压榨，成为了大机器生产中的一颗螺丝钉。查理（查理·卓别林 Charles Chaplin 饰）就是一个底层市民，他在一个机器隆隆的厂房里日以继夜地工作，以赚取微薄的收入。重复繁重的工作压得他喘不过气，他把人们的鼻子当成螺丝钉来拧，卷入流水线机器的皮带里，令人苦笑不得。</p><p>​        写到这里，想起影片一开始的片段，第一个镜头是许多羊群争先恐后的挤出羊圈，随后紧接着切入了一个许多工人下班拥挤的走出工厂的镜头。看到这里，我想到了我自己，每天上下班时的地铁站口，我随着成千上万的人群进进出出的场景。我<strong>认为摩登时代一开始的那两个镜头完全有理由成为电影史上最伟大最经典的蒙太奇。</strong><a href="%E8%B1%86%E7%93%A3%E7%BD%91">^3</a><br>​        <strong>正如狄更斯所言，这是最好的时代，这是最坏的时代。</strong></p><h3 id="《指环王》">《指环王》</h3><p>2022</p><h3 id="《熊出没：重返地球》">《熊出没：重返地球》</h3><h2 id="科幻：">科幻：</h2><h3 id="《流浪地球》">《流浪地球》</h3><h3 id="《盗梦空间》">《盗梦空间》</h3><h3 id="《星际穿越》">《星际穿越》</h3><h3 id="《头号玩家》">《头号玩家》</h3><h3 id="《环太平洋2》">《环太平洋2》</h3><h3 id="《哥斯拉2：怪兽之王》">《哥斯拉2：怪兽之王》</h3><h2 id="悬疑：">悬疑：</h2><h3 id="《大侦探福尔摩斯》">《大侦探福尔摩斯》</h3><h3 id="《大侦探福尔摩斯2：诡影游戏》">《大侦探福尔摩斯2：诡影游戏》</h3><h1>参考资料</h1><p><strong>空白为待制作</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;记录片&lt;/h1&gt;
&lt;h2 id=&quot;科技：&quot;&gt;科技：&lt;/h2&gt;
&lt;h2 id=&quot;人文：&quot;&gt;人文：&lt;/h2&gt;
&lt;h3 id=&quot;《天地玄黄》&quot;&gt;《天地玄黄》&lt;/h3&gt;
&lt;h3 id=&quot;《一百年很长吗》&quot;&gt;《一百年很长吗》&lt;/h3&gt;
&lt;p&gt;2024.8&lt;/p&gt;
&lt;p&gt;“家有千金不</summary>
      
    
    
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/tags/%E6%8E%A8%E8%8D%90/"/>
    
    <category term="记录片" scheme="https://stars-at-dawn.github.io/tags/%E8%AE%B0%E5%BD%95%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>金融</title>
    <link href="https://stars-at-dawn.github.io/posts/5d89d8bb"/>
    <id>https://stars-at-dawn.github.io/posts/5d89d8bb</id>
    <published>2024-11-02T02:29:10.000Z</published>
    <updated>2024-11-27T03:01:03.198Z</updated>
    
    <content type="html"><![CDATA[<h1>经济术语分析</h1><hr><h2 id="社会金融"><strong>社会金融</strong></h2><hr><h3 id="社会：">社会：</h3><h4 id="通缩-通胀-滞胀："><strong>通缩|通胀|滞胀：</strong></h4><p><strong>通缩：全称通货紧缩</strong><br>指货币流通数量减少，<strong>指整体物价水平持续下跌的经济现象</strong></p><p>“<strong>好的通缩</strong>”指的是由于劳动生产率提高使总供给增加引起的一般物价水平下降，不会引起“<strong><a href="%E5%9C%A8%E8%B4%A7%E5%B8%81%E5%8D%87%E5%80%BC%E7%9A%84%E9%80%9F%E5%BA%A6%E8%B6%85%E8%BF%87%E5%90%8D%E4%B9%89%E5%80%BA%E5%8A%A1%E5%81%BF%E8%BF%98%E9%80%9F%E5%BA%A6%E7%9A%84%E6%83%85%E5%BD%A2%E4%B8%8B%EF%BC%8C%E5%80%BA%E5%8A%A1%E6%B8%85%E5%81%BF%E4%B8%8D%E4%BD%86%E4%B8%8D%E8%83%BD%E5%BD%BB%E5%BA%95%E5%9C%B0%E6%B8%85%E5%81%BF%E5%80%BA%E5%8A%A1%EF%BC%8C%E5%8F%8D%E8%80%8C%E4%BD%BF%E5%BE%97%E5%B0%9A%E6%9C%AA%E5%81%BF%E8%BF%98%E7%9A%84%E5%90%8D%E4%B9%89%E5%80%BA%E5%8A%A1%E7%9A%84%E7%9C%9F%E5%AE%9E%E8%A7%84%E6%A8%A1%E5%8A%A0%E5%A4%A7%E3%80%82%E8%BF%99%E6%A0%B7%EF%BC%8C%E7%BB%8F%E6%B5%8E%E8%90%A7%E6%9D%A1%E5%8F%AA%E4%BC%9A%E7%BB%A7%E7%BB%AD%E6%81%B6%E5%8C%96%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A5%BD%E8%BD%AC%E3%80%82">债务-通缩</a></strong>”，物价水平的下降也不会带来经济衰退。<br>“<strong>坏的通缩</strong>”是指由于总需求不足引起物价水平下降，而且存在“债务-紧缩”的恶性循环，<strong>最终形成“通缩-经济衰退”的自我强化</strong>。</p><p><strong>通胀：全称通货膨胀</strong><br>物价水平持续上升，钱的购买力下降，钱越来越不值钱</p><p><strong>滞胀：停滞性通货膨胀</strong><br>特指经济停滞（stagnation），失业及通货膨胀（inflation）同时持续高涨的经济现象。</p><hr><h4 id="CPI-PPIPMI："><strong>CPI|PPIPMI：</strong></h4><p><strong>CPI：居民消费价格指数</strong><br>主要从<strong>消费者角度</strong>反映价格总水平的变化。如果CPI升高，说明居民买同样东西支付的货币多了。<br>主要涵盖了<strong>食品</strong>、烟酒、衣服、居住、生活服务、交通通信、教育文娱医疗保健等方面，<strong>反映了经济社会的通货膨胀状态</strong>。</p><p><strong>PPI：生产资料（生产者出厂）价格指数</strong><br>是某个时期内工业产品第一次出售时的价格变动值，<br>从<strong>生产者角度</strong>反映市场价格变化。 如果PPI升高了，说明企业生产成本高了。<br>其调查涵盖了40个工业大类和1300多个基本分类的工业产品价格。PPI可以分为<strong>生产资料和生活资料</strong>两大类。</p><p><strong>PPI与CPI不同的是，</strong><br><strong>影响PPI的主要是生产资料，而影响CPI的主要是食品项，食品项与生活资料关系更密切</strong>。<br>在生产-<strong>需求传导渠道顺畅</strong>的时候，<strong>CPI和PPI的走势自然比较一致</strong>。<br>但是在<strong>需求不旺</strong>时，生产端的价格波动难以向需求端传导，<strong>受损的只能是企业</strong>。</p><p><strong>PMI：采购经理人指数</strong><br>信息量很大，PMI反映的经济信息非常全面，从需求到价格，从价格到生产，从生产到库存，应有尽有。<br><strong>PMI等于50是经济强弱的临界点</strong></p><hr><h4 id="恩格尔系数">恩格尔系数</h4><hr><h4 id="供给侧结构性改革："><strong>供给侧结构性改革：</strong></h4><p>旨在调整经济结构，使要素实现最优配置，提升经济增长的质量和数量。<br><strong>需求侧改革主要有投资、消费、出口三驾马车，</strong><br><strong>供给侧则有劳动力、土地、资本、制度创造、创新</strong>等要素。</p><hr><h4 id="大宗商品"><strong>大宗商品</strong></h4><p>指具有实体，可进入流通领域，但并非在零售环节进行销售，具有商品属性，用于工农业生产和消费使用的大批量买卖的物资商品。<br><strong>作为大类资产配置不可或缺的一环</strong>，其价格波动与股票、债券等资产往往呈现出较低的相关性，能够显著地帮助投资者<strong>分散风险</strong></p><p><strong>大宗商品</strong>的分类：</p><p><img src="https://xqimg.imedao.com/18f0e24010b114923feb8ac0.jpg!800.jpg" alt="img"></p><p><a href="https://xueqiu.com/S/SH510170?from=status_stock_match">商品ETF</a>列表（2024/8）：</p><p><img src="https://xqimg.imedao.com/18f0e2401bf110c13fef16a6.png!800.jpg" alt="img"></p><hr><h4 id="M0-M1-M2"><strong>M0|M1|M2</strong></h4><p><strong>M表示monetary，而M0、M1、M2是货币供应量的三个定义，分别表示流通中的现金、狭义货币供应量与广义货币供应量，俗称货币家族三兄弟。</strong></p><p><strong>M0被称为基础货币</strong>:它指的是在银行体系外流通的现金，也就是大家没有存在银行而是拿在自己手上的钱，是货币构成中流动性最强的部分</p><p><strong>M1是在M0的基础上，加上企业活期存款</strong></p><p><strong>M2则是在M1的基础上，再加上企业定期存款、个人储蓄存款和其它存款</strong>:代表了货币构成中流动性较弱的部分</p><p><strong>M0数值越高，往往说明老百姓手头越宽裕</strong>；<br><strong>M1</strong>因为是随时可取的“活钱”，因此<strong>反映了大家目前的购买力，代表着居民和企业资金松紧变化，是经济周期波动的先行指标</strong>；<br><strong>M2</strong>包含<strong>居民储蓄和企业定期存款</strong>，不是随时可以提取出来使用的，因此<strong>代表的是未来潜在的购买力，反映了社会总需求的变化和未来通货膨胀的压力状况</strong>。</p><p><strong>M2与GDP之比</strong>：<br>M2/GDP是常用的衡量<strong>金融深化</strong>的指标，即广义货币(M2)与国内生产总值(GDP)的比值。比值越大，说明经济货币化的程度越高。</p><hr><h4 id="次贷-次贷危机"><strong>次贷/次贷危机</strong></h4><p><strong>次贷</strong>即“<a href="https://baike.baidu.com/item/%E6%AC%A1%E7%BA%A7%E6%8A%B5%E6%8A%BC%E8%B4%B7%E6%AC%BE/6712821?fromModule=lemma_inlink">次级抵押贷款</a>”（subprime mortgage loan） ，“次”的意思是指：与“高”、“优”相对应的，形容较差的一方，在“次贷危机”一词中指的是信用低，还债能力低。<br><strong>次级抵押贷款</strong>是指一些贷款机构向信用程度较差和收入不高的借款人提供的贷款。</p><p>在2006年之前的5年里，由于美国住房市场持续繁荣，加上前几年美国利率水平较低，美国的次级抵押贷款市场迅速发展。<br>随着美国<strong>住房市场的降温尤其是短期利率的提高，次贷还款利率也大幅上升</strong>，购房者的还贷负担大为加重。同时，住房市场的持续降温也使购房者出售住房或者通过抵押住房再融资变得困难。这种局面直接导致大批次贷的借款人不能按期偿还贷款，银行收回房屋，却卖不到高价，大面积亏损，引发了次贷危机。</p><p><strong>杠杆：</strong><br>许多投资银行为了赚取暴利，采用20－30倍杠杆(Leverage)操作，假设一个银行A自身资产为30亿，30倍杠杆就是900亿。也就是说，这个银行A以30亿资产为抵押去借900亿的资金用于投资，假如投资盈利5%，那么A就获得45亿的盈利，相对于A自身资产而言，这是150%的暴利。反过来，假如投资亏损5%，那么银行A赔光了自己的全部资产还欠15亿。</p><h4 id="CDS合同："><strong>CDS合同：</strong></h4><p>（credit default swap 信用违约互换）<br>由于杠杆操作高风险，所以按照正常的规定，银行不进行这样的冒险操作。所以就有人想出一个办法，把杠杆投资拿去做“保险”。这种保险就叫CDS。比如，银行A为了逃避杠杆风险就找到了机构B。机构B可能是另一家银行，也可能是保险公司，诸如此类。A对B说，你帮我的贷款做违约保险怎么样，我每年付你保险费5千万，连续10年，总共5亿，假如我的投资没有违约，那么这笔保险费你就白拿了，假如违约，你要为我赔偿。A想，如果不违约，我可以赚45亿，这里面拿出5亿用来做保险，我还能净赚40亿。如果有违约，反正有保险来赔。所以对A而言这是一笔只赚不赔的生意。B是一个精明的人，没有立即答应A的邀请，而是回去做了一个统计分析，发现违约的情况不到1%。如果做100家的生意，总计可以拿到500亿的保险金，如果其中一家违约，赔偿额最多不过50亿，即使两家违约，还能赚400亿。A,B双方都认为这笔买卖对自己有利，因此立即拍板成交，皆大欢喜。</p><p><strong>CDS市场：</strong><br>B做了这笔保险生意之后，C在旁边眼红了。C就跑到B那边说，你把这100个CDS单子卖给我怎么样，每个合同给你2亿，总共200亿。B想，我的400亿要10年才能拿到，现在一转手就有200亿，而且没有风险，何乐而不为，因此B和C马上就成交了(相当于C收到300亿保险金，承担保险责任)。 这样一来，CDS被划分成一块块的CDS，像股票一样流到了金融市场之上，可以交易和买卖。实际上C拿到这批CDS之后，并不想等上10年再收取300亿，而是把它挂牌出售，标价220亿；D看到这个产品，算了一下，400亿减去220亿，还有180亿可赚，这是“原始股”，不算贵，立即买了下来(相当于D收到280亿保险金，承担保险责任)。一转手，C赚了20亿。从此以后，这些CDS就在市场上反复的炒，现在CDS的市场总值已经炒到了62万亿美元。</p><p><strong>盈利：</strong><br>上面A,B,C,D,E,F…都在赚大钱，从根本上说，这些钱来自A以及同A相仿的投资人的盈利。而他们的盈利大半来自美国的次级贷款。次贷主要是给了普通的美国房产投资人。这些人的经济实力本来只够买自己的一套住房，但是看到房价快速上涨，动起了房产投机的主意。他们把自己的房子抵押出去，贷款买投资房。这类贷款利息要在8%－9%以上，凭他们自己的收入很难对付，不过他们可以继续把房子抵押给银行，借钱付利息，空手套白狼。此时A很高兴，他的投资在为他赚钱；B也很高兴，市场违约率很低，保险生意可以继续做；后面的C,D,E,F等等都跟着赚钱。</p><p><strong>危机</strong>：<br>房价涨到一定的程度就涨不上去了，后面没人接盘。此时房产投机人急得像热锅上的蚂蚁。房子卖不出去，高额利息要不停的付，终于到了走投无路的一天，把房子甩给了银行。此时违约就发生了。此时A感到一丝遗憾，大钱赚不着了，不过也亏不到那里，反正有B做保险。B也不担心，反正保险已经卖给了C。那么这份CDS保险在那里呢，在G手里。G刚从F手里花了300亿买下了100个CDS(相当于G收到200亿保险金，承担保险责任)，还没来得及转手，突然接到消息，这批CDS被降级，其中有20个违约，大大超出原先估计的1%到2%的违约率。每个违约要支付50亿的保险金，总共支出达1000亿。减去G收到这200亿保险金，G的亏损总计达（800亿）。虽然G是全美排行前10名的大机构，也经不起如此巨大的亏损。因此G濒临倒闭。<br>如果G倒闭，那么A花费5亿美元买的保险就泡了汤，更糟糕的是，由于A采用了杠杆原理投资，根据前面的分析，A赔光全部资产也不够还债。因此A立即面临破产的危险。<br>上面讲到的100个CDS的市场价是300亿。而CDS市场总值是62万亿，假设其中有10%的违约，那么就有6.2万亿的违约CDS。这个数字是300亿的207倍（四舍五入之后）。如果说美国government收购价值300亿的CDS之后要赔出1000亿。那么对于剩下的那些违约CDS，美国government就要赔出20.7万亿。如果不赔，就要看着A21,A22,A23等等一个接一个倒闭。以上计算所用的假设和数字同实际情况会有出入，但美国金融危机的严重性无法低估。<br>因此G,A,A2,…,A20一起来到美国财政部长面前，一把鼻涕一把眼泪地游说，G万万不能倒闭，它一倒闭大家都完了。财政部长心一软，就把G给国有化了，此后A,…,A20的保险金总计1000亿美元全部由美国纳税人支付。<br>说明：<strong>CDS合同和次贷都属于金融衍生产品，而CDS市场就是现在金融体系中一个重要的金融交易体系。</strong></p><hr><h4 id="城投债的概念"><strong>城投债的概念</strong></h4><p><strong>旧预算法禁止地方政府发债融资</strong>，1995年开始施行的旧预算法规定“除法律和国务院另有规定外，地方政府不得发行地方政府债券”，这一规定导致了地方政府无法进行直接融资。</p><p>一方面是基础设施建设的不断发展带来巨大的资金缺口，另一方面的财权的上收、债权的限制导致的地方政府没有资金来源，在这样的背景下：<br><strong>地方城投平台应运而生，城投平台承担了地方基础设施建设的融资、建设等职能</strong><br><strong>而城投平台直接融资发行的债券即是城投债。</strong></p><p>1.城投债信用风险较低<br>城投债由地方支持，与地方政府债券类似，城投债也是地方政府融资的一种方式，<strong>有一定的政府背景，风险较低</strong>。地方财政收入及债券所投项目的经营收益可以为本期债券提供充足的偿还保障。<br>2.收益具有吸引力<br>以近期发行的城投债为例，五年前AA+级城投债发行利率5.04%，比二级市场同等级企业债高出110基点。另外，多数债券利率具有期权特征，投资者具有回售权，发行者具有上调票面利率选择权，对投资者有较好的保护。<br>3.利率市场化<br>对地方政府而言，城投债既不违反现有法律法规，又绕开人大审批，筹集资金更加市场化，相对于5.94%（5年及以上）的贷款利率来说更加节省了融资成本。</p><hr><h4 id="量化宽松的货币政策"><strong>量化宽松的货币政策</strong></h4><p><strong>俗称“印钞票”</strong>，指一国货币当局通过大量印钞，购买国债或企业债券等方式，向市场注入超额资金，旨在降低市场利率，刺激经济增长。该政策通常是往常规货币政策对经济刺激无效的情况下才被货币当局采用，即<strong>存在流动性陷阱</strong>的情况下实施的非常规的货币政策。</p><h4 id="流动性陷阱："><strong>流动性陷阱：</strong></h4><p>流动性陷阱指当名义利率降低到无可再降低的地步，甚至接近于零时，由于人们对于某种“流动性偏好”的作用，宁愿以<strong>现金或储蓄的方式持有财富</strong>，而不愿意把这些财富以资本的形式作为投资，也不愿意把这些财富作为个人享乐的消费资料消费掉。<strong>国家任何货币供给量的增加</strong>，都会以“闲资”的方式被吸收，<strong>仿佛掉入了“流动性陷阱”</strong>，因而对总体需求、所得及物价均不产生任何影响。</p><hr><h4 id="P2P：借贷模式"><strong>P2P：借贷模式</strong></h4><p>P2P是英文peer to peer lending（或peer-to-peer）的缩写，意即个人对个人（伙伴对伙伴）。又称点对点网络借款，<strong>是一种将小额资金聚集起来借贷给有资金需求人群的一种民间小额借贷模式</strong></p><hr><p><strong>市场经济  中央计划经济</strong></p><p><strong>国进民退</strong></p><p><strong>塔西佗陷阱</strong>，得名于古罗马时代的历史学家塔西佗，最初来自塔西佗所著的《塔西佗历史》。后被引申为一种社会现象，指<strong>当政府部门或某一组织失去公信力时，无论说真话还是假话，做好事还是坏事，都会被认为是说假话、做坏事 。</strong><br>塔西佗陷阱，是塔西佗在评价一位罗马皇帝时所说的话：“一旦皇帝成了人们憎恨的对象，他做的好事和坏事就同样会引起人们对他的厌恶。”</p><p><strong>黑天鹅事件</strong>（英文：“Black swan” incidents）指<strong>非常难以预测，且不寻常的事件</strong>，通常会引起市场连锁负面反应甚至颠覆。<br>( 指难以预测，但突然发生时会引起连锁反应、带来巨大负面影响的小概率事件。它存在于自然、经济、政治等各个领域，虽然属于偶然事件，但如果处理不好就会导致系统性风险，产生严重后果 。)<br>一般来说，“黑天鹅”事件是指满足以下三个特点的事件：它具有意外性；它产生重大影响；虽然它具有意外性，但人的本性促使我们在事后为它的发生编造理由，并且或多或少认为它是可解释和可预测的。<br>黑天鹅存在于各个领域，无论金融市场、商业、经济还是个人生活，都逃不过它的控制。<strong>“灰犀牛”是与“黑天鹅”相互补足的概念</strong>，“灰犀牛事件”是<strong>太过于常见以至于人们习以为常的风险</strong>，“黑天鹅事件”则是<strong>极其罕见的、出乎人们意料的风险</strong>。</p><hr><hr><h3 id="股市：">股市：</h3><h4 id="投资-投机"><strong>投资/投机</strong></h4><p><strong>一定要明白投资与投机的区别</strong><br><strong>一定要区分  投资者   和   投机者</strong><br><strong>投资者分为两种  防御和进取</strong><br><strong>短线操作   长线投资</strong></p><ul><li><strong>股票并非仅仅是一个交易代码号或电子信号，而是表明拥有一个实实在在的企业的所有权；企业的内在价值并不依赖于其股票价格。</strong></li><li><strong>市场就像一只钟摆，永远在短命的乐观（它使得股票过于昂贵）和不合理的悲观（它使得股票过于廉价）之间摆动。聪明的投资者则是现实主义者，他们向乐观主义者卖出股票，并从悲观主义者手中买进股票。</strong></li><li><strong>每一笔投资的未来价值是其现在价格的函数。你付出的价格越高，你的回报就越少。</strong></li><li><strong>无论如何谨慎，每个投资者都免不了会犯错误。只有坚持格雷厄姆的所谓“安全性”原则——无论一笔投资看起来多么令人神往，永远都不要支付过高的价格——你才能使犯错误的几率最小化。</strong></li><li><strong>投资成功的秘诀在于你的内心。如果你在思考问题时持批判态度，不相信华尔街的所谓“事实”，并且以持久的信心进行投资，你就会获得稳定的收益，即便是在熊市亦如此。通过培养自己的约束力和勇气，你就不会让他人的情绪波动来左右你的投资目标。说到底，你的投资方式远不如你的行为方式重要。</strong></li><li><strong>忘记过去的人，必将重蹈覆辙</strong></li></ul><p>税（资本收益税等）<br><strong>中国没有资本利得税。</strong><br><strong>但是有证券投资所得税，即从事证券投资所获得的利息、股息、红利收入的征税。</strong></p><p>联接的ETF基金尽量不要买，会收两遍管理费</p><p><strong>股票投资至少应占 25%</strong><br><strong>一般来说应该和债券对半开 灵活调整</strong><br><strong>如果债券对半开综合应有6%税前收益</strong></p><p>券商交易股票有手续费 <strong>万分之五，最低五元</strong><br><strong>所以买就别只买一点，不然很亏</strong></p><hr><p><strong>度量和量化（买的时候问一问自己“它价值几何？”）</strong></p><p><strong>利率 5%</strong>   税款   <strong>高等级债券波动远远低于股票</strong></p><hr><h4 id="公司相关信息"><strong>公司相关信息</strong></h4><p><strong>公司净资产（查看资产负债表右下部分《所有者权益合计》金额）</strong><br><strong>市盈率 =每股市价/每股收益（通常为12个月的时间）</strong></p><p><strong>静态市盈率</strong>=股票现价÷当期每股收益<br><strong>预测市盈率</strong>=股票现价÷未来每股收益的预测值<br><strong>动态市盈率（TTM）</strong>=股价/过去四个季度的EPS</p><p><strong>股息（又译红利）  约3.5-4.5%   股票增值3%</strong>   综合收益7.5%<br>如果债券和股票对半开 综合应该有6%税前收益</p><hr><h4 id="证券-一二级市场"><strong>证券 一二级市场</strong></h4><p>证券：<br><strong>各种金融工具的统称，例如：股票、债券、权证和股票价款缴纳凭证等</strong></p><p><strong>一级市场投资者可以直接购买新股或新基金份额，</strong><br><strong>二级市场是投资者之间进行的股票和基金份额的交易。</strong></p><hr><h4 id="K线图-均线图"><strong>K线图/均线图</strong></h4><p>BV1EuxTe3EB6</p><p><strong>牛熊市</strong>：<br>牛市与熊市是股票市场行情预料的两种不同趋势。<br><strong>牛市是预料股市行情看涨，前景乐观的专门术语，</strong><br><strong>熊市是预料股市行情看跌，前景悲观的专门术语。</strong></p><hr><h4 id="债券"><strong>债券</strong></h4><p>债券，是一种按照国家要求的<strong>标准格式</strong>，经过国家各种部门<strong>审批通过</strong>之后，才发行出来的<strong>标准化借条</strong>。债券上写着：谁借钱、谁出钱、债券啥时候到期、利率是多少、偿还方式是啥、违约了怎么办，等等信息。因为它是标准化的，因而可以进行交易</p><p><strong>按照债券违约风险来分</strong>，可以分为<strong>利率债</strong>和<strong>信用债</strong>。<br><strong>利率债</strong>就像银行存款一样，是国家信用担保，基本不会有违约风险。比如国债，央行票据等，地方债也算是准利率债。<br><strong>信用债</strong>就是企业发的债，根据每个企业的财务状况，风险自然不一样。例如华为发的债就违约风险很小，而如果一个小的公司发行的债券，违约风险自然会大一点。</p><p>第二种分类方式，是根据<strong>交易市场来分</strong>，可以分为<strong>交易所市场和银行间市场</strong>。<br><strong>交易所市场</strong>很好理解就是这种债券会在深交所或者上交所上市，只能通过证券交易软件交易。<br><strong>银行间市场</strong>就是银行之间互相买卖，散户投资者需要500万资金才能有资格通过银行间市场进行买卖债券。</p><p><strong>高等级债券   高等级公用事业债券</strong> <strong>黄金</strong></p><p><strong>高等级债券波动远远低于股票</strong></p><p><strong>利率 5%↓</strong></p><p><strong>债券的牛熊（涨跌）</strong><br>一般不用指数来展示，而是看<strong>十年期国债收益率</strong>（还有十年就到期的国债的年化收益率）。<br><strong>债券的收益率跟十年期国债收益率成反比关系</strong>，这个很好理解，本来发行一个债券，本金是100，利息是7%，如果十年期国债收益率下降，发行个债券，本金100，利息只有5%，那么大家肯定去抢前面的债，使得前面的债价格大于100的面值。</p><hr><h4 id="指数-基金-ETF："><strong>指数|基金|ETF：</strong></h4><p><strong>深证综合指数</strong>是深圳证券交易所编制的，以深圳证券交易所挂牌上市的全部股票为计算范围，以发行量为权数的加权综合股价指数。    0和3开头股票</p><p><strong>创业板指数</strong>就是以起始日为一个基准点，按照创业板所有股票的流通市值，一个个计算当天的股价，再<strong>加权平均</strong>，与开板之日的**“基准点”比较。**<br>3开头股票   <strong>科技，医疗，新能源</strong></p><p><strong>沪深300指数</strong>是上交所和深交所于2005年4月8日联合发布的一个指数，代码为000300，<br><strong>选取了沪深两市市值大、流动性好的300只股票编制而成</strong>，每年调整2次成分股，<br><strong>沪深300指数</strong>是能够<strong>综合反映沪深两市整体走势的跨市场指数</strong><br><strong>沪深300指数</strong>可以体现出沪深两市整体市场的一个行情走势，在各个证券交易软件或支持基金买卖的软件中，经常用来作为收益对比的基准，比如全年收益高于沪深300指数的涨幅，就可以说投资者或基金跑赢了市场。可以说沪深300成分股所在的公司是我国最优质的一批公司了     平常提到的<strong>大白马</strong>概念基本都在这里面。</p><p><strong>ETF：<strong>全称</strong>交易型开放式指数基金</strong>；又被称为<strong>交易所交易基金</strong>；<strong>个人无法购买的基金</strong>；</p><p><strong>基金：</strong></p><p><strong>1.股票型基金</strong><br>股票型基金根据证监会规定，股票持仓必须在80%以上，也就是不管行情好不好，必须买满80%以上的股票，如果基金经理觉得行情不好，想将股票降低仓位到80%以下，抱歉，这是不允许的。所以股票型基金的风险较大，可能亏50%，但是牛市来了，也能翻几倍。</p><p><strong>2.混合型基金</strong><br>故名思意，混合型基金没有股票持仓限制，就看基金经理怎么搭配，股票，债券，货币理财啊 都可以往里面搭配，基金的收益完全看经理的表现。</p><p><strong>3.债券型基金</strong><br>债券持仓量80%以上的都称为债券型基金,根据持仓量多少，可以分为纯债基金和偏债基金，偏债基金有部分投资股票和理财，跟混合型基金有些重合。因为债券都是到期还本付息产品，所以短期亏损风险不大，当然如果只持有几个月到半年，也有短期亏损的风险，不过风险不大，可能一般就亏损3%左右，但是拿个一两年，还是能赚钱的，债券型基金平均年化收益6%-8%左右</p><p><strong>4.货币型基金</strong><br>货币型基金主要投资于债券、央行票据、回购等安全性极高的短期金融品种，我们常用的余额宝也就是其中的一员。目前市场上货币基金有很多个，大多收益2%到3%，相差不会太大。优点是没有短期亏损风险，每天都有收益，想取出特别方便，随存随取。</p><p><strong>5.QDII基金</strong><br>QDII基金是指在一国境内设立，经该国有关部门批准从事境外证券市场的股票、债券等有价证券业务的证券投资基金。我们有外汇管制，如果个人投资国外的股票和债券有很多限制，那么我们就通过QDII基金来进行投资。但是由于信息原因，大家对国外公司研究没有国内公司透彻，因而一般人并不适合投资QDII基金。</p><p><strong>6.指数型基金</strong><br>指数，根据某些采样股票或债券的价格所设计并计算出来的统计数据，用来衡量股票市场或债券市场的价格波动情形。股票型指数基金其实也属于我们上面说的第一种，也就是股票型基金，采取跟踪指数的方式，一般股票的持仓能达到90%以上比例。</p><p><strong>上面这种分类方式是根据基金持仓区分</strong>，除了这种分类方式，还有以下几种分类方式：</p><p><strong>1.根据购买渠道区分</strong><br>通过<strong>银行柜台，天天基金网，支付宝，基金公司APP</strong>购买的基金都叫做<strong>场外基金</strong>，交易对象都是基金公司，你交钱，基金公司给你基金份额。<br>只能<strong>通过证券交易软件的基金</strong>叫<strong>场内基金</strong>，可以向基金公司申购基金，也可以通过交易软件，投资者之间互相买卖。</p><p><strong>2.根据基金是否有固定期限区分</strong><br>可以<strong>随时赎回的叫开放式基金</strong><br>固定时间的叫<strong>封闭式基金</strong>（例如前段时间大热的蚂蚁战略配售基金封闭十八个月才能赎回）</p><p><strong>债券基金</strong><br>根据证监会规定，80%的资金拿来买债券的基金即为<strong>债券基金</strong>。</p><p>根据持有债券的<strong>到期时间</strong>，也可以分为<strong>短期债券基金和中长期债券基金</strong>。<br><strong>短债基金</strong>主要是持有到期时间为397天之内的债券的基金。<br><strong>中长期债券基金</strong>就是超过397天的。<br>短期债券基金的收益一般会低于中长期债券基金的收益<br>但是短期债券基金的波动会比长期债券基金的波动小很多。</p><p>**纯债基金 **这种基金只买债券，不买股票。<br><strong>混合债基</strong> 混合债基是既持有债券，又持有股票。</p><p>债券持有比例大于80%<br><strong>一级债基</strong>是不能到市场去买股票的，但是它可以买可转债，所以看它股票持仓如果有股票，股票是可转债转换而来的。<br><strong>二级债基就是说可以到二级市场买股票</strong>，股票持仓最大可以达到20%。股票的波动会大于债券，因而<strong>二级债基的风险大于一级债基。</strong></p><p><strong>风险性/收益性：短债基金&lt;长债基金&lt;一级债基&lt;二级债基</strong></p><p><strong>管理费和托管费:</strong><br>投资者支付给基金公司的报酬，管理费用是从基金净值中进行提取，按日计算计提，按月支付。<br><strong>基金公司在公布净值时都已经扣除这些费用，所以投资者并不会有直观的感受</strong></p><p><strong>对于货币基金和指数基金这种对基金经理要求不高或者业绩差异不明显的</strong>，省到就是赚到。<br>所以像货币基金就要挑三费（管理费、托管费、销售服务费）低的，<br>而跟踪同一指数的不同基金进行挑选时，也<strong>要把管理费和托管费作为很重要的考量因素</strong></p><hr><h4 id="股票常见操作："><strong>股票常见操作</strong>：</h4><p><strong>重仓|平仓|清仓|轻仓</strong>：<br><strong>重仓</strong>指<strong>将自己的大部分资金用来购卖股票。</strong><br><strong>清仓指（全部卖出）</strong>。<br><strong>平仓指 (卖掉的买回来，买的卖出去。 恢复之前仓位)。</strong><br><strong>轻仓指（一小部分钱买股票）。</strong></p><p><strong>卖空交易</strong>是买空交易的对称，亦称卖空。证券市场上的<strong>证券投机者</strong>利用证券价格飞涨的时机，<br>先<strong>借入大批的证券在市场上高价售出</strong><br>待将来证券价格下跌以后，再低价买回证券，归还所借证券，进而从中获利的一种证券投机交易。</p><p><strong>升水与贴水</strong>：<br><strong>远期汇率与即期汇率的差额</strong>用升水、贴水和平价来表示。<br>升水意味着远期汇率比即期的要高，贴水则反之。<br>一般情况下，利息率较高的货币远期汇率大多呈贴水，利息率较低的货币远期汇率大多呈升水。</p><hr><h4 id="成本平均法-定投"><strong>成本平均法(定投)</strong></h4><p><strong>成本平均法（定期定额策略）<strong>简单的来说就是你把需要投资的本金，分成多个定量的投资资金，并且定时的买入投资物。<strong>在市场上升时买入较少份额的“货”，在市场回落时，买多较多份额“货”</strong>，保证从长期来看，稳定的“囤货”，使得你买入的“货”的成本总体来说较低，最后在市场达到预期目标价格时卖出你的“货”，实现长期的稳定收益。<br>举个例子：如果你有100块的本金，你想要去做个股票的投资，这个时候一股的价钱在20块，你现在一笔投入，你能买到的份额就是5股。如果换个投资策略，你把100块本金分成5等份，每份本金20块，在市场波动到5块时买入4股，在市场波动到10块是买入2股，在市场回升到20块时买入1股，市场价格超过20块时就不买入，那么最终你可以获得的份额是：4+2+1=7股，从长期来讲是更能对抗市场风险的投资策略方法。<br>要注意的一点就是如果你要投资的目标是没有明显的周期性波动，那么DCA投资法可能就不是最合适的。因为DCA的</strong>逻辑就是在市场低谷时多买入，市场上涨时少买入，使得最后买入的平均价格可以较低。</strong><br>比如说一支股票一直涨，并且未来的趋势也是涨势，那么使用DCA策略就完全没有意义。因为在你投入资金确定的情况下，决定你能否囤更多货的关键是在于你是否是在前期价格还没涨起来的时候购入。<br>所以使用DCA投资策略的前提是<strong>要选择有周期性波动的投资物</strong>，这样才能保证长期稳定的收益。</p><hr><h4 id="股息-红利："><strong>股息|红利：</strong></h4><p><strong>股息（又译红利）  约3.5-4.5%</strong><br><strong>股息是股东定期按一定的比率从上市公司分取的盈利</strong><br><strong>红利则是在上市公司分派股息之后按持股比例向股东分配的剩余利润</strong></p><p>一般来讲，上市公司在财会年度结算以后，会根据股东的持股数将一部分利润作为股息分配给股东。<br>上市公司的分红派息工作一般都集中在次年的二、三季度进行。<br><strong>10派1是上市公司的一种股票分红方案，指上市公司按照每10股分给投资者1元分红。</strong><br><strong>而股票分红10派几就是指每10股派多少元的分红。</strong><br><strong>沪深股市的上市企业实行利润分配一般只采用股票红利和现金红利两种，即统称所说的送红股和派现金。</strong><br>持股超过一年的对股息红利所得免征个人所得税；持股1个月至1年的，按10%比例征收；持股1个月以内的，按20%比例征收。<br>所以短期投资者通常会在股权登记日之前卖出持股，除息日至之后再买回，来避免这种分红但还“亏钱”的情况<br><strong>1、计算除息价：</strong><br><strong>除息价＝股息登记日的收盘价－每股所分红利现金额</strong><br>例如:某股票股息登记日的收盘价是4.17元，每股送红利现金0.03元，则其次日股价为：4.17－0.03＝4.14(元)</p><p><strong>2、计算除权价：</strong><br><strong>送红股后的除权价＝股权登记日的收盘价÷(1＋每股送红股数)</strong><br>例如: 某股票股权登记日的收盘价是24.75元，每10股送3股，，即每股送红股数为0.3，则次日股价为：24.75÷(1＋0.3)=19.04(元)<br><strong>配股后的除权价＝(股权登记日的收盘价＋配股价×每股配股数)÷(1＋每股配股数)</strong><br>例如: 某股票股权登记日的收盘价为18.00元，10股配3股，即每股配股数为0.3，配股价为每股6.00元，则次日股价为(18.00＋6.00×0.3)÷(1＋0.3)=15.23(元)</p><p><strong>3、计算除权除息价：</strong><br><strong>除权除息价＝(股权登记日的收盘价－每股所分红利现金额＋配股价×每股配股数)÷(1＋每股送红股数＋每股配股数)</strong><br>例如: 某股票股权登记日的收盘价为20.35元，每10股派发现金红利4.00元，送1股，配2股，配股价为5.50元/股，即每股分红0.4元，送0.1股，配0.2股，则次日除权除息价为(20.35－0.4＋5.50×0.2)÷(1＋0.1＋0.2)＝16.19(元)。</p><hr><h4 id="期货-现货-期权">期货|现货|期权</h4><p><strong>现货</strong>是实实在在可以交易的货（商品）<br><strong>期货</strong>主要不是货，而是以某种大宗产品如棉花、大豆、石油等及金融资产如股票、债券等为标的标准化可交易合约。因此，这个标的物可以是某种商品（例如黄金、原油、农产品），也可以是金融工具。<br>交收期货的日子可以是一星期之后，一个月之后，三个月之后，甚至一年之后。买卖期货的合同或协议叫做期货合约。买卖期货的场所叫做期货市场。投资者可以对期货进行投资或投机。</p><p><strong>期权</strong>：期权交易是指在未来一定时期可以买卖的权利，是买方向卖方支付一定数量的权利金后拥有的在未来一段时间内或未来某一特定日期以事先商定的价格向卖方购买或出售一定数量标的物的权利，但不负有必须买进或卖出的义务。</p><p>按<strong>期权的权利</strong>划分，有<strong>看涨期权</strong>和<strong>看跌期权</strong>两种类型。<br>按<strong>期权的种类</strong>划分，有<strong>欧式期权</strong>和<strong>美式期权</strong>两种类型。<br>按行权<strong>时间</strong>划分，有<strong>欧式期权、美式期权、百慕大期权</strong>三种类型。</p><p>**套期保值 **俗称“海琴” 又称对冲贸易<br><strong>股指期货买入套期保值</strong>是指投资者因担心目标指数或股票组合价格上涨而买入相应股指期货合约进行套期保值的一种交易方式，即在期货市场上首先建立多头交易部位（头寸），在套期保值期结束时再对冲掉的交易行为，因此也称为“多头保值”。指交易人在买进（或卖出） 实际货物的同时，在期货交易所卖出（或买进） 同等数量的期货交易合同作为保值。<br>可买入股指期货合约便能对冲股票价格上涨的风险，由于股指期货交易具有杠杆机制，买入股指期货合约所需的资金量较小。<br><strong>股指期货卖出套期保值是</strong>指投资者以因担心目标指数或股票组合价格下跌而卖出相应股指期货合约的一种保值方式，即在期货市场上先开仓卖出股指期货合约，待下跌后再买入平仓的交易行为，因此又称为“空头保值”。</p><hr><h4 id="股票特殊名称"><strong>股票特殊名称</strong>:</h4><p><strong>白马股</strong>：是指<strong>长期绩优、回报率高并具有较高投资价值的股票</strong>。因其有关的信息已经公开，业绩较为明朗，同时又兼有业绩优良、高成长、低风险的特点，因而具备较高的投资价值，往往为投资者所看好。<br><strong>医药、消费、科技、金融</strong>这四个行业，是最容易出现长线白马股的行业。<br><strong>恒瑞医药、贵州茅台、腾讯控股、中国平安</strong>等四家上市公司都是众人皆知的大白马股。</p><p><strong>蓝筹股(Blue Chips)：是指长期稳定增长的、大型的、传统工业股及金融股</strong>。“蓝筹”一词源于西方赌场，在西方赌场中，有三种颜色的筹码、其中蓝色筹码最为值钱。证券市场上通常将那些经营业绩较好，具有稳定且较高的现金股利支付的公司股票称为“蓝筹股”。</p><p>成长股  龙头股 普通股</p><hr><h3 id="住房">住房</h3><h4 id="租住比-2-300-1"><strong>租住比-2/300:1</strong></h4><h4 id="按揭贷款"><strong>按揭贷款</strong></h4><p><strong>按揭</strong>是指按揭人将房产产权转让按揭，受益人作为还贷保证人在按揭人还清贷款后，受益人立即将所涉及的房屋产权转让按揭人，过程中按揭人享有使用权。<br><strong>按揭贷款</strong>是指以按揭方式进行的一种贷款业务。</p><hr><hr><h2 id="生活金融"><strong>生活金融</strong></h2><h3 id="公司">公司</h3><h4 id="注册企业："><strong>注册企业</strong>：</h4><ul><li>企业名字</li><li>地址</li><li>法人</li><li><strong>经营类型</strong></li><li><strong>企业类型</strong></li></ul><hr><h4 id="ABS融资模式"><strong>ABS融资模式</strong></h4><p>ABS融资模式是以项目所属的资产为支撑的证券化融资方式，即以项目所拥有的资产为基础，以项目资产可以带来的预期收益为保证，通过在资本市场发行债券来募集资金的一种项目融资方式。</p><hr><h4 id="董事会"><strong>董事会</strong></h4><p>董事会是由董事组成的，<strong>对内掌管公司事务、对外代表公司的经营决策和业务执行机构</strong>；<br><strong>董事会  由股东（大）会选举。</strong><br>董事会设董事长一人，副董事长，<br>董事长、副董事长的产生办法由公司章程规定，一般由董事会选举产生。董事任期由章程规定，最长三年，任期届满，可连选连任，董事在任期届满前，股东会不得无故解除其职务。<br>董事会是股东会或股东大会这一权力机关的业务<strong>执行机关</strong>，负责公司或企业和业务经营活动的指挥与管理，对公司股东会或股东大会负责并报告工作。<strong>股东会或股东大会所作的决定，董事会必须执行。</strong></p><hr><h4 id="企业孵化器"><strong>企业孵化器</strong></h4><p>-&gt; <strong>低成本资金</strong><br>企业孵化器在中国也称高新技术创业服务中心，它通过为新创办的<strong>科技型中小企业</strong>提供物理空间和基础设施，提供一系列的服务支持，进而降低创业者的创业风险和创业成本，提高创业成功率，<strong>促进科技成果转化</strong>，培养成功的企业和企业家。在台湾地区叫育成中心，在欧洲一般叫创新中心（innovation center）。</p><h4 id="供应链金融"><strong>供应链金融</strong></h4><p>供应链金融，又称供应商融资或反向保理，是一种<strong>融资</strong>解决方案，<strong>供应商可以通过它提前收到付款。供应链融资降低了供应链中断的风险，使买方和供应商都能优化其营运资本。</strong></p><p>供应链中，买方和供应商存在财务冲突。<strong>买方希望尽可能晚付款，而供应商则希望尽可能早付款。</strong><br>供应链融资的出现，就是为了弥合这些利益冲突，它提供一系列融资和风险缓解方案，旨在优化国内和国际供应链中的<strong>营运资金和流动性</strong>。有些产品直接提供给供应商，有些则通过买方提供。</p><hr><p>实体行业</p><p>工资可以加上特殊部分<br>只能买指定的品牌的生活必需品（自产自销，控制资金流动性）</p><hr><hr><h3 id="经营">经营</h3><p>纳什均衡（博弈论）</p><hr><hr><h3 id="存款"><strong>存款</strong></h3><h4 id="72-70公式"><strong>72/70公式</strong></h4><p>其实所谓的“72法则”就是以1%的<strong>复利</strong>来计息，<strong>经过72年以后，本金会变成原来的一倍</strong>。这个公式好用的地方在于它能<strong>以一推十</strong>，例如：利用8%年报酬率的投资工具，经过9年(72/8)本金就变成一倍；利用12%的投资工具，则要6年左右(72/12)，就能让1元钱变成2元钱。<br>假设最初投资金额为100元，复息年利率9%，利用72法则，将72除以9，得8，即需约8年时间，投资金额滚存至200元，而准确需时为8.0432年。<br>要估计<strong>货币的购买力减半所需时间</strong>，可以把与所应用的法则相应的数字，除以通胀率。若通胀率为3.5%，应用“<strong>70法则</strong>”，每单位之货币的购买力减半的时间约为70/3.5=20年。</p><h4 id="结构性存款"><strong>结构性存款</strong></h4><p>一般来说，结构性存款的高风险部分买的都是金融衍生品，以期权为主。<br>存款那部分的收益，也就是A%。<br>期权这部分猜对了，赚钱了。再加上存款那部分的收益，整个结构性存款的收益就是B%。<br><strong>A%的值越高，B%的值越低；A%的值越低，B%的值越高。</strong></p><h4 id="风险对冲"><strong>风险对冲</strong></h4><p>风险对冲，是指通过投资或购买与标的资产（Underlying Asset）<strong>收益波动负相关的某种资产或衍生产品</strong>，来冲销标的资产潜在的风险损失的一种风险管理策略。</p><hr><h2 id="金融理论"><strong>金融理论</strong></h2><h3 id="凯恩斯主义："><strong>凯恩斯主义</strong>：</h3><p>凯恩斯主义是在肯定市场经济的基础上，主张政府通过增加赤字的方法称为市场的重要参与者，在经济谷底阶段起到增加总需求的作用。 计划经济是否认市场经济的，主张整个社会就是一家大工厂，全部经济单位都在中央统一协调下从事生产和获得的分配。<br>凯恩斯主义，是在1929年美国大萧条后，为了解决经济危机，而被凯恩斯提出来的一个刺激经济的理论。 该理论主张国家采用扩张性的经济政策，通过增加需求促进经济增长。即扩大政府开支，实行赤字财政，刺激经济，维持繁荣。</p><h3 id="弗里德曼理论-：">**弗里德曼理论 **：</h3><p>弗里德曼在理论上有三大贡献，首先是提出<strong>现代货币数量论</strong>，即<strong>通货膨胀起源于“太多的货币追逐太少的商品”</strong>。政府可以通过控制货币增长来遏制通胀。这被视为现代经济理论的一场革命。<br>其次，他创立消费函数理论，对凯恩斯经济理论中的边际消费递减规律进行驳斥。凯恩斯认为，随着社会财富和个人收入的增加，人们用于消费方面的支出呈递减趋势，与此同时储蓄则越来越多。因此政府可以通过增加公共支出来抵消个人消费的减少，从而保证经济的持续增长。弗里德曼指出，这一理论站不住脚，<strong>因为人们的欲望实际上永无止境，原有的得到满足后，新的随即产生。</strong><br>1968年，弗里德曼与美国哥伦比亚大学经济学家菲尔普同时提出“自然率假说”理论。他们发现，**长期来看，失业率与通货膨胀并没有必然联系。自然失业率永远存在，是不可消除的。**因此政府的宏观调控政策长期来看是不起任何作用的。</p><h3 id="熊彼得理论："><strong>熊彼得理论</strong>：</h3><p>(熊彼得商业周期理论)<br>熊彼特指出，每个长周期包括六个中周期，每个中周期包括三个短周期。短周期约为40个月，中周期约为9—10年，长周期为48-60年。他以重大的创新为标志划分。根据创新浪潮的起伏，熊彼特把资本主义经济的发展分为三个长波：<strong>（1）1787—1842年是产业革命发生和发展时期；（2）1842—1897年为蒸汽和钢铁时代；（3）1898年以后为电气、化学和汽车工业时代。</strong></p><hr><hr><h1>宜居城市分析</h1><h2 id="桂林">桂林</h2><p><strong>技术——解决别人的问题</strong></p><h3 id="目前处于通缩">目前处于<strong>通缩</strong></h3><p>现在满足通缩五个条件，也就是属于通缩状态，通缩状态调整需要债务落地，也就是正在落地中，未来会有一波大萧条，这个时候我们应该减少投资，购买一定的国债或者持有现金；待到债务落地，政府救急后降息印钞，这个时候就从通速改为通胀，通胀前期可以利用原有的现金购买低价商品，购买低价股票，坐收政府救急红利</p><h3 id="利用人性赚钱"><strong>利用人性</strong>赚钱</h3><p>利用<strong>人性</strong>赚钱。因地制宜<br><strong>男人最怕虚，希望买到强壮的身体；</strong><br><strong>女人最怕丑，希望买到脸蛋和身材；</strong><br><strong>小孩最怕笨，希望能买到知识；</strong><br><strong>老人最怕死，希望能买到健康。</strong></p><hr><h3 id="其它名句">其它名句</h3><p>（来自网络）</p><p>芒格说：”如果我知道我会死在哪里，那我就永远不会去那个地方！“</p><p>句句不谈薪资，条条不离奉献，桩桩不谈好处，事事皆讲境界。<br>一谈文化五千年，一说工业刚开始，一讲经济说总量，一问发展才起头。<br>工资确实低，物价确实高，福利确实少生活确实甜。</p><p>从前，有一个劫匪劫了一群人，让大家排队交钱，第一个交一百、第二个交两百，以此类推；<br>于是大家纷纷排队，第一个人得意的说：“看，哥交的比你们都少。”<br>最后大家争先恐后地交钱，连反抗都忘了。（爱情公寓·吕小布）</p><p><strong>跳蚤的来吮血，虽然可恶，而一声不响地就是一口，何等直截爽快。</strong><br><strong>蚊子便不然了，一针叮进皮肤，自然还可以算得有点彻底的，但当未叮之前，要哼哼地发一篇大议论，</strong><br><strong>却使人觉得讨厌。如果所哼的是在说明人血应该给它充饥的理由，那可更其讨厌了，幸而我不懂。</strong></p><p>一位记者到美国工厂采访，<br>记者问“工厂是谁的？”<br>工人们说“资本家的”<br>记者“那门口的汽车呢？”<br>工人“那是我们上下班开的”<br>这位记者又来到苏联工厂采访<br>记者同样问“这工厂是谁的”<br>工人们说“是我们全民所共有的！”<br>记者又问“那门口的汽车呢？”<br>工人们说“哦，那是厂长和书记们的”</p><p>还有人信他们不择手段爬上去就是为了给你当公仆的？</p><p><strong>“如果动物光吃不胖，它的肚子里一定有寄生虫；如果人民勤劳却无法致富，那个社会一定有吸血鬼。”</strong><br><strong>一鲁迅《狂人日记》</strong></p><hr><h3 id="没有管理费的大类资产配置方法">没有管理费的大类资产配置方法</h3><p><strong>来自B站评论：</strong></p><p>我列举没有管理费的大类资产配置方法：</p><ol><li>记账式中国国债，没有管理费，没有门槛。短期国债可以代替货币基金，你可以把它理解为现金。<strong>长期国债波动较大，但和股指有较好的对冲效果</strong>。</li><li>股指期货。包括上证50、沪深300、中证500、中证1000，我只推荐沪深300。50万门槛，可以借钱开户，之后还回去。<br>你可以加杠杆，小仓位做多。比如2倍杠杆，20%仓位的沪深300，这样相对于总资金，你购买了40%的沪深300。而指数不可能在短期下跌50%，所以你并没有真的加杠杆。而你多出来20%资金可供利用。<br>如果你做多长债，认为风险较大，那么多出来的20%资金可以用来购买无风险收益，比如短债。<br>选择贴水购买，可以进行无风险套利，不要选择升水承担溢价。不断展期，即可实现长线投资。<br>我斗胆说一句：【在货币不断贬值，流动性泛滥的年代，最大的风险就是承担的风险不够。只要精确计算了自己的承受的风险，你应该寻找一切方法给自己加杠杆。】<br>你那多出来的现金，要么拿去上课、买书、买生产力工具，要么拿去投资，要么等待加仓；留着只会贬值，不能给你提供你需要的安全。</li><li>指数ETF期权，50万门槛。最常用的做法是在牛市末期买put预防突然下跌，我推荐学习。</li><li>国债期货。同上。</li><li>标普和纳指的股指期货，没有门槛。<br>【<strong>标普可以理解为人类文明集体的增速。纳指可以理解为人类文明科技的增速。</strong>】<br>如果你主动投资，但跑输了这两个指数，那你有90%的可能不适合主动投资。</li><li>美股指数ETF期权，没有门槛。</li><li>美股的指数基金是可以购买的，QQQM是0.15%，SPY是0.1%，并不贵。但依然，没有送钱的理由。</li><li>美债、美债ETF期权、美债期货。而不是选择美债ETF。没有门槛，就占外汇额度。</li><li>黄金期货，门槛10万。美国交易商没有门槛。<br>【<strong>黄金代表人类货币流动性的增速。</strong>】<br>如果你跑赢了通胀，但没有跑赢黄金。这证明你的钱依然贬值了。</li><li>实物金条，回收没有折损，相对于沪金期货溢价不足1%。</li><li>BTC，而不是BTC ETF。没有门槛。不同交易所手续费不同，Robinhood免手续费。最大问题是人民币购买稳定币的巨大溢价。</li><li>BTCDOM指数合约，没有管理费。同上。</li><li>外汇，建议用IBKR，没有门槛。<br>叠甲：不懂就不要做，对自己的钱负责。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;经济术语分析&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;社会金融&quot;&gt;&lt;strong&gt;社会金融&lt;/strong&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&quot;社会：&quot;&gt;社会：&lt;/h3&gt;
&lt;h4 id=&quot;通缩-通胀-滞胀：&quot;&gt;&lt;strong&gt;通缩|通胀|滞胀：&lt;/strong&gt;&lt;/h4&gt;
</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>旅游地点记录</title>
    <link href="https://stars-at-dawn.github.io/posts/62bf27e9"/>
    <id>https://stars-at-dawn.github.io/posts/62bf27e9</id>
    <published>2024-11-02T02:27:26.000Z</published>
    <updated>2024-11-02T02:31:13.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="村寨">村寨</h2><p><strong>安徽 西递村</strong>   ☆☆☆☆</p><p>建议时间：2-5月份</p><p>徽派建筑 画画圣地 有许多过来画画的学生</p><p><strong>四川甘孜 丹巴藏寨</strong> ☆☆☆</p><p>一般 景点少50一张票自己开进去 路不好开 风景挺好看的</p><p><strong>西江 千户苗寨</strong> ☆☆</p><p>民风不纯朴，宰客严重！<br>票价也不值得，没有宣传的那样好！建议不要来<br>老年人免费的可以来看，年轻人这个票价不值得<br>其它的商业化严重什么的，大家都知道了。旺季住半山民宿一晚1500</p><p><strong>湖南 皇都侗寨</strong></p><p><strong>福建 田螺坑村</strong> ☆☆☆☆</p><p>客家土楼 值得一去的</p><p><strong>福建 永定 集庆楼/承启楼</strong> ☆☆☆☆</p><p>客家土楼 值得一去的</p><p><strong>山西洪洞 大槐树</strong> ☆☆</p><p>寻根问祖（对同一个姓的人说的客套话：<strong>五百年前是一家</strong>。一说出处就是在这里）<br><strong>情怀价值无限</strong><br>但<strong>旅游游玩价值无</strong>，就是引诱外地人 来此参观现代建设的情怀建筑<br>成人门票80，儿童，60岁老人半价 军人，1.2米以下，65岁以上免费 洪洞本地身份10元，开年3 4月淡季有免费的</p><p><strong>陕西 青木川古镇</strong> ☆☆☆☆☆</p><p>休闲游的好地方，安静，环境好，适合散心，就是没有高速，山路过去有点距离<br>就是卖东西的特别多！翟家大院可以看看！魏氏宅院也行！游客服务中心旁边有个旅拍店价格合适服务很好！<br>从游客中心停车场后面可以爬个小山头，回龙寺（全程木栈道500米左右，爬升约50米）老少皆宜。车子只能停到游客中心停车场，步行二百米就进去小镇了。<br>套票网购54元，是三个地方：老宅、烟馆、荣盛魁），老宅单独参观是30元。</p><p><strong>山西 碛口古镇</strong> ☆☆☆</p><p>“九曲黄河第一镇”<br>商业化太严重到处是客栈民宿 真正的古建筑没多少 没啥看的<br>无门票停车场免费，景区免费公交接送</p><p><strong>西藏 嘎拉桃花村</strong>  ☆☆☆☆</p><p>素享“西藏江南”美誉<br>盛开时间最早，从三月中旬到四月上旬。<br>驱车沿318国道往东南方向行驶十几分钟，就来到了嘎拉村</p><p><strong>四川 曾达村</strong></p><p>特别好看的梨花</p><p><strong>山西 王家大院</strong> ☆☆☆☆</p><p>“民间故宫”、“山西紫禁城”等美誉<br>总面积就达到25万平方米，据说是中国最大的私人豪宅之一，其规模之大令人叹为观止。<br>院内房屋密集，布局有序，整体呈上坡状，气势恢宏<br>一砖一瓦，处处都是历史；一匾一联，字字皆为文化。注意避开旅游旺季，不然举步维艰</p><p><strong>浙江 诸葛八卦村</strong> ☆☆☆☆</p><p>名人加持<br>带有古风，具有江南风味的建筑</p><p><strong>浙江 南浔古镇</strong> ☆☆☆☆☆</p><p>景区不要门票。9点钟到，刚好南门有表演。个别参观要门票，看自愿。<br>停车场停7个小时，25块钱。还可以。<br>吃的东西不少，下午到晚上，人山人海。下午两点多，去买3块钱的船票，</p><p><strong>浙江南浔 小莲庄</strong> ☆☆☆☆</p><p>南浔古镇门票免费，可以坐水上巴士游览，还可以在水上游览，<br>古镇里有很多美食，定胜糕和梅花糕口味不错。还有百间楼-丝绸码头头。</p><p><strong>浙江 乌镇</strong> ☆☆☆☆</p><p>江南六大古镇<br>特色菜可以但要花很多钱。除了逛街，其他活动很费钱。<br>白天、晚上各有各的特色</p><p><strong>浙江温岭 石塘镇</strong></p><p>渔村</p><p>**浙江温州 永嘉 苍坡古村 **☆☆☆☆<br>正在装修中，古建筑数量有限，水体污染严重，且大部分设施未开放，建议免费停车后从旁门进入，但需注意安全卫生问题。<br>苍坡古镇景色非常漂亮，大晴天拍照特别好看，基本上30分钟就能逛完，如果走走拍拍照，1个小时也足够了。<br>村子以文房四宝作为型来构建村子</p><p><strong>浙江长兴 方一村</strong></p><p><strong>浙江富阳 龙门古镇</strong> ☆☆</p><p>70门票太贵了<br>没必要门票，全是小路能进，村子里也能进，一些要门票的小房间没啥看点<br>商业化没有那么严重的一个小镇，去的人不多，小镇本身得人也不多。</p><p><strong>浙江丽水市松阳县 杨家堂村</strong></p><p>**浙江武义 郭洞村景区 **☆☆</p><p>车比人多。门票30￥，还有小收费点<br>值得去一下，顺便尝竹筒饭。<strong>下去五分钟车程有个水库，那里很好</strong></p><p><strong>安徽 黄山 宏村镇</strong>☆☆☆☆</p><p>绝对超级美丽的一个地方，一半是诗情画意，一半是人间烟火，要好好保护好这个村落，不输土耳其的任何一个小镇，中国的古镇那是真正的古镇，马头墙，青砖灰瓦的特色房屋，到处都是服装写生的学生和艺术家，没事去这里住两天，发发呆，看看山景，让生活慢下来，虽然不可避免的商业化，但随处可见的原住居民的日常劳作与游客的旅途漫游是如此的和协与相得益彰。</p><p><strong>广西 黄姚古镇</strong> ☆☆☆</p><p>门票价格太贵（88￥），商业味道太浓，没有文化气息。<br>黄姚古镇依山傍水，山水相映成趣，让人心旷神怡。 风景不错</p><p><strong>福建 龙海 埭美古村</strong> ☆☆</p><p><strong>河南 陕州 地坑院</strong> ☆☆☆</p><p>“没有建筑的建筑”（地坑）<br>去了一个坑一个坑看，变成小饰品步行街了。<br>没意思。啥也没有。商业化太严重。晚上看灯有特色，不带无人机不要去了。<br>交通挺便利，历史建筑，门边不贵，周边餐饮配套很多</p><p><strong>福建龙海 埭美古村</strong></p><p><strong>湖南 勾蓝瑶寨</strong> ☆☆☆</p><p>适合养老的优美环境</p><p><strong>云南 丽江束河古镇</strong> ☆☆☆☆</p><p>除了丽江古城外，每次我都会来这里，它没有丽江大研喧嚣，商业化更少一些，慵懒是这里的代名词，小桥流水，石板小道，它却一样都不少。束河古镇一直给我一种宁静舒适，一幅我所向往生活的模样。这里不必跟随着人们的脚步去走，随心便是最好的生活模式，早上在古城里逛逛，看看繁花盛开的静谧街巷，中午的一碗米线，人间至味仅仅不过是古镇里不起眼的米线小店。阳光正好的午后随便找一家咖啡店，让书本、音乐和浓郁的咖啡香陪伴一下午，晚上去看看四方街的篝火晚会，与纳西人围着篝火载歌载舞的欢乐，伴随着繁星点点的星空，束河的夜也是醉人。<br>📍地址：云南丽江束河古镇  💰门票：0元  🕐开放时间：全天开放<br>👉🏻束河古镇游玩推荐：<br>📍哈里谷：这个片区都是一些仿古建筑，亭台楼阁，小桥流水很适合拍中式风格。<br>📍四方听音广场：晚上有篝火表演，广场一旁有一个雪山观景台，走上去可以看到雪山。<br>📍飞花触水：这里聚集了很多餐厅、酒吧。<br>📍聚宝山：可以打卡束河古镇全貌</p><p><strong>吉林图们 白龙村</strong></p><p>边境</p><p>北京市门头沟区斋堂镇 爨柏景区（<strong>爨底下村</strong>）☆☆☆</p><p>景区比较小游玩时间一小时左右，可以了解一下明清时期的山里民居，但大部分的房子都改民宿了。<br>目前雁翅镇到景区的路正在施工路况不好，驾车出游多注意安全。（2024-03-15）</p><p><strong>新疆布尔津 乔木村</strong> ☆☆☆☆</p><p>05月01日至10月15日 08:00-22:00<br>早穿棉袄午穿纱，早上只有10度以下了，羽绒服真的得安排<br>夏天晚上8点半都还没有天黑，温度不冷不热刚刚好，风景很好，远远看村子确实有种中国小瑞士的感觉</p><p><strong>广东 千年瑶寨（连南瑶寨）</strong> ☆</p><p>巴掌大一块地方全是卖东西的门票一百多就连演出也是卖字画的真的太不值了</p><p><strong>辽宁沈阳 东陵公园</strong> ☆☆☆☆<br>清福陵，东陵公园内，是清太祖努尔哈赤和皇太极生母叶赫那拉氏的陵墓，另有努尔哈赤的后妃叶赫那拉氏、乌拉那拉氏等人葬于此处。 福陵是清太祖努尔哈赤及其孝慈高皇后叶赫纳喇氏的陵墓。<br>与沈阳市的昭陵、新宾县永陵合称“关外三陵”、“盛京三陵”。<br>东陵公园始建于公元1629年(天聪三年)，到公元1651年基本建成。后经清朝顺治、康熙、乾隆年间的多次修建，形成了规模宏大、设施完备的古代帝王陵墓建筑群。距今已有三百六十余年历史。崇德元年(公元1636年)大清建国，定陵号为“福陵”，1929年被当时奉天当局辟福陵为东陵公园。</p><p><strong>辽宁沈阳 盘古台村</strong></p><hr><h2 id="公园-景区">公园 景区</h2><p><strong>浙江桐庐 瑶琳国家森林公园</strong> ☆☆☆☆</p><p>溶洞，人少，游览路线也非常舒服</p><p><strong>浙江桐庐 瑶琳仙境</strong> ☆☆☆☆</p><p>溶洞</p><p><strong>浙江桐庐 垂云通天河景区</strong> ☆</p><p>管理非常混乱 面积很小 很贵<br>玻璃栈道现场感受并不好 高度并不高 玻璃很脏 下方的景色很差<br>拍照免费，实际20元带走<br>所谓的漂流，并不是天然的河道，而是一个带水的人造滑梯。</p><p><strong>浙江桐庐 大奇山国家森林公园</strong> ☆☆☆</p><p>人多 路少 风景还可以</p><p><strong>浙江桐庐 严子陵钓台景区</strong> ☆</p><p>125元的门票(含摆渡船票)，简直就是在抢钱！完全不值。<br>而且，满是铜臭的门票经济，对于自由脱俗的严子陵，实在就是莫大的讽刺</p><p><strong>浙江桐庐 芦茨湾</strong> ☆☆☆☆</p><p>（接上一段）<strong>果断开车掉头，开车十多分钟就能到芦茨湾，顺着著名的马岭古道，逛吃到茆坪村、深奥古村、石舍村，景色好、人文佳、还免费，那才是旅游该有的感觉</strong></p><p><strong>浙江温州 江心屿</strong> ☆☆☆☆☆</p><p>南宋开国皇 帝在江心屿避过难。民族英雄文天祥也在此地逗留过一段时间。<br>浙江省温州市鹿城区江心屿，有一旅游景点，四面环水，乘游轮可达，名曰江心寺，历史悠久。<br>进入景点，但见水光山色，宝刹庄严，金碧辉煌，一派佛光普照。<br>大门立柱上有一对长联： <strong>云朝朝朝朝朝朝朝朝散， 潮长长长长长长长长消。</strong> 此联是南宋温州状元王十朋所撰，具有深厚的文化底蕴和禅意。 重字联中“朝”和“长”为多音字，跌宕起伏，灵活互动，妙趣横生，实为古今一大奇联。 据说，能读懂了的都是高人。</p><p><strong>浙江 莫干山风景区</strong> ☆☆☆☆</p><p>国内四大避暑胜地之一。<br><strong>附近有车的可以去，外地的就别去了，就是普通度假村</strong>，而且当地网约车和出租车都要加价30多才载你<br>风景不错，空气新鲜，都是山里人家和民宿，度假放松好去外！</p><p><strong>浙江 雁荡山</strong> ☆☆☆</p><p><strong>景点分散还很小。</strong><br>各景点停车虽然免费，但门票价太贵。<br>如果开车路过大龙湫的瀑布还值得一看。<br>去过黄山，华山或泰山的，这里完全可以不用来了。神农架也秒杀这里。</p><p><strong>浙江 千岛湖</strong> ☆☆☆☆</p><p>被誉为“天下第一秀水”<br>又称新安江水库，我国最大的人工湖，其水质为国家一级水体<br>千岛湖很大，水非常干净，湖面上星罗棋布着很多小岛，青山绿水，很美，<br>商业气息严重，处处消费，不尊重历史古迹，不过自然风光可以，去了的话可以<strong>步行环岛观光风景（路线在下面），不建议消费</strong></p><p><strong>崇左中越边境 德天跨国瀑布</strong> ☆☆</p><p>能做竹排 雨季瀑布挺好看<br>其它没东西看 瀑布非雨季水很小<br>115￥太贵 坐摆渡车太长</p><hr><h2 id="自然风景">自然风景</h2><p><strong>靖西 三叠岭瀑布 ☆☆☆☆</strong></p><p>野生瀑布 无门票 路边 可接近</p><p><strong>云南金平县 勐拉温泉</strong><br>G219<br>天然野温泉，一棵大榕树伸出茂密的枝叶把温泉整个盖住，温泉含有特殊矿物（有利健身），温泉边上有傣族MM伺候你烧烤、小酒，甚是享受</p><p><strong>云南 金平蝴蝶谷</strong><br>G219<br>每年3~10月是游览佳期。7月份那真是漫天蝴蝶</p><p><strong>浙江 朱家尖风景名胜区</strong> ☆☆☆☆<br>大青山100，观音圣坛，南沙70RMB，都不错<br>乌石塘40 东沙35 白山20<br>去普陀山一定要从这里经过 打卡沙雕</p><hr><h2 id="游玩路线"><strong>游玩路线</strong></h2><h3 id="自驾游路线">自驾游路线</h3><p><strong>浙东沿海之旅：</strong><br>盐官古镇—杭州湾跨海大桥—宁波—朱家尖景区—东钱湖—象山石浦—<a href="https://www.zhihu.com/search?q=%E5%89%8D%E7%AB%A5%E5%8F%A4%E9%95%87&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3473056091%7D">前童古镇</a>—温岭石塘—雁荡山—<a href="https://www.zhihu.com/search?q=%E6%A5%A0%E6%BA%AA%E6%B1%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3473056091%7D">楠溪江</a></p><p><strong>千岛湖环湖游：</strong><br>千岛湖大桥—<a href="https://www.zhihu.com/search?q=%E5%A4%A9%E5%B1%BF%E5%B1%B1%E8%A7%82%E6%99%AF%E5%8F%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3473056091%7D">天屿山观景台</a>—温馨岛—骑龙巷—啤酒小镇—洲际灯塔—石林火车公园—下姜村—千岛湖大峡谷—<a href="https://www.zhihu.com/search?q=%E8%8A%B9%E5%B7%9D%E5%8F%A4%E6%9D%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3473056091%7D">芹川古村</a>—文渊狮城—千岛湖大桥</p><p>G219：<br>云南段 <strong>河口</strong>—<strong>云南金平县 勐拉温泉</strong>—<strong>云南 金平蝴蝶谷</strong>—接着再往铜厂乡走去往元阳梯田，一路美景。</p><h3 id="其它">其它</h3><p><a href="https://space.bilibili.com/297136">@孙探长笔记</a>离开河口还走G219的话，一定要去一下金平县的勐拉温泉，天然野温泉，一棵大榕树伸出茂密的枝叶把温泉整个盖住，温泉含有特殊矿物（有利健身），温泉边上有傣族MM伺候你烧烤、小酒，甚是享受！扎营就在温泉边。另外还有金平蝴蝶谷，每年3~10月是游览佳期。7月份那真是漫天蝴蝶，现在去嗨能赶个尾巴吧（不确定）。<br>接着再往铜厂乡走去往元阳梯田，一路美景。</p><hr><h2 id="备注">备注</h2><p>无评分的 即部分非旅游景点或者比较冷门的景点 且没什么评价的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;村寨&quot;&gt;村寨&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安徽 西递村&lt;/strong&gt;   ☆☆☆☆&lt;/p&gt;
&lt;p&gt;建议时间：2-5月份&lt;/p&gt;
&lt;p&gt;徽派建筑 画画圣地 有许多过来画画的学生&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四川甘孜 丹巴藏寨&lt;/strong&gt; ☆☆☆&lt;/p</summary>
      
    
    
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/tags/%E6%8E%A8%E8%8D%90/"/>
    
    <category term="旅游" scheme="https://stars-at-dawn.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>语句记录</title>
    <link href="https://stars-at-dawn.github.io/posts/b213807a"/>
    <id>https://stars-at-dawn.github.io/posts/b213807a</id>
    <published>2024-11-02T02:24:43.000Z</published>
    <updated>2024-11-02T02:31:13.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语句记录"><strong>语句记录</strong></h2><p><strong>人民万岁！</strong></p><p><strong>懦者从不启程，弱者退与途中。</strong></p><p><strong>唯有遍历星河，才知人间值得。</strong></p><p><strong>只是糟糕的一天，不是糟糕的一生</strong></p><p><strong>你是在拜佛，还是在拜自己的欲望？</strong></p><hr><h3 id="俗语：">俗语：</h3><p>赔本赚吆喝</p><p><strong>工具没有好坏之分</strong></p><p>不要想的比做的多</p><p><strong>君子不立危墙之下</strong></p><p>君子怕小人，<strong>小人怕狠人</strong></p><p><strong>永远不要去挣最后一个铜板</strong></p><p><strong>透明和政府</strong>这两个词本身就是矛盾的</p><p>在一个拿锤子的人看来，任何东西都像钉子</p><p>先去做，做的过程再去想问题的解决办法</p><p>都快打到柏林了，还以为自己形势大好呐</p><p>阿Q挨了一巴掌，他没胆量打回去，只能骂一句儿子打老子，骂完之后他的脸仿佛不这么疼了</p><hr><h3 id="长句："><strong>长句：</strong></h3><p><strong>是俗是雅, 我已经分不清了, 我只知道月亮正圆,我若不看一眼, 倒显得我不解风情了。</strong></p><p>学校要求我们把头发剪了，我剪了头发，顿时觉得一股清流，再摸摸后脑勺，不知何时生出一只辫子</p><p>圆规为什么可以画圆? 因为<strong>脚在走，心不变。</strong><br>你为什么不可以圆梦? 因为<strong>心不定，脚不动。</strong></p><p>生而为人，要么就努力到能力出众，要么就懒得乐天知命。<br>最怕你是见识打开了，可努力又跟不上；<br>骨子里清高至极，性格上又软弱无比。</p><p><strong>当你将所有努力压在一件事情上，</strong><br><strong>那做完这件事等待你的将会是无尽的空虚</strong></p><p><strong>鲁莽者要学会思考，善思者要克服的是犹豫。</strong><br><strong>目的渴求完美，举步之际则无需周全。</strong></p><p><strong>平行的两只眼睛，却不平等看人</strong><br><strong>生在左右两只耳朵，却总听一面之词；</strong><br><strong>只有一张嘴，却总能说出两面话。</strong></p><p>你的迷茫，大多都是因为<strong>想得太多、做得太少</strong>。<br>还没开始，就担心前路太崎岖、害怕难关过不去。<br>与其思虑过度，不如脚踏实地。<br><strong>舍得逼自己一把，才能知道自己究竟能走多远。</strong></p><p>“怎样算欺凌?”<br>“十人欺负一人算。一百人欺负一人也算。”<br>“那么一万个人呢?”<br>“那是<strong>正义</strong>啊。”</p><p>一群连街边小偷都不敢呵斥的人，<br>却勇于高呼灭了敌国，<br>一帮连活着的人民的痛苦，都漠不关心的人，<br>却有脸说不忘死去的同胞。<br>——王朔</p><p><strong>你说的话里，藏着你读过的书，走过的路，爱过的人，</strong><br><strong>把自己变得丰富，才是你无惧一切的底气。</strong><br><strong>人们不在乎真相,只相信自己愿意相信的真相，谁给他们提供幻觉，谁就能轻易成为他们的主人</strong></p><p>跳蚤的来吮血，虽然可恶，而一声不响地就是一口，何等直截爽快。<br>蚊子便不然了，一针叮进皮肤，自然还可以算得有点彻底的，但当未叮之前，要哼哼地发一篇<br>大议论，却使人觉得讨厌。如果所哼的是在说明人血应该给它充饥的理由，那可更其讨厌了，幸而我不懂。</p><p>我正要出门，只看一个小狗乌咽亨即的躺在路旁，约莫是断了腿我于是请了兽医来。<br>他好一番检查，又从随身的包里摸出几个针线，不等我开口，只自顾自的缝了小狗的嘴起来。<br>我于是不见哀豪声了，它大抵是被医好了</p><p>中国人躺在儒家挖的大坑里几千年爬不上来，读书根本就不是为学习知识，掌握真理或探索宇宙奥妙，<br>读的好点的，参加科举，当个官，做做人上人；读的差的，混口饭吃仅此而已！<br>**人与人之间始终学不会平等的相处。**所以，至今仍然与现代文明格格不入（徐志摩）</p><hr><h3 id="名言："><strong>名言：</strong></h3><p>在无权、无势、善良的人身上挑毛病。<br>在有权、有势、缺德的人身上找优点。——莫言</p><p>上善若水，水善利万物而不争。——《道德经》</p><p><strong>毁掉我们的不是我们所憎恨的，恰恰是我们所热爱的。——《娱乐至死》</strong></p><p><strong>为了那些想象中的离奇故事，观众奉献了太多的笑声和泪水。——《乌合之众》</strong></p><p><strong>多数人在25岁时就死了，一直到75岁才埋葬。——富兰克林</strong></p><p>优于别人，并不高贵，<strong>真正的高贵是优于过去的自己</strong>。——海明威</p><p>如果印钞票能消除贫困的话，那么印文凭也就可以消除愚蠢了。——阿根廷总统 米莱</p><p>“<strong>屏蔽力</strong>”是一个人最顶级的能力。任何消耗你的人和事，多看一眼都是你的不对。——罗素</p><p>那些不能过公共生活，或者可以自给自足不需要过公共生活，因而不参与社会的，要么是兽类，要么是<strong>上帝</strong>。 ——亚里士多德</p><p><strong>“我们走后，他们会给你们修学校和医院，会提高你们的工资，这不是因为他们良心发现，也不是因为他们变成了好人，而是因为我们来过”</strong> ——切·格瓦拉</p><p><strong>“如果动物光吃不胖，它的肚子里一定有寄生虫；如果人民勤劳却无法致富，那个社会一定有吸血鬼。”</strong><br><strong>一鲁迅《狂人日记》</strong></p><hr><h3 id="短语：">短语：</h3><p><strong>行百里者半九十</strong></p><p><strong>不以物喜，不以己悲</strong></p><p>思接千载，视通万里</p><p>小惠未遍，民弗从也</p><p><strong>门客三千</strong>，古来已久（孟尝君食客三千）</p><p><strong>由俭入奢易，由奢入俭难</strong></p><p>**知行合一。**知进退，明得失。</p><p>流水不腐，户枢不蠹，<strong>动也。</strong></p><p><strong>谋爱前，先谋生，爱人前，先爱己。</strong></p><p>君子 <strong>藏器于身，待时而动；以钝示人，以锋策己。藏锋慰忠骨，出鞘镇河山。</strong></p><hr><h2 id="其它语句记录">其它语句记录</h2><h3 id="散文"><strong>散文</strong></h3><p><strong>黑瓦白墙的江南</strong></p><p>远处夜莺正在歌唱，<strong>引人入梦，扰人思绪</strong></p><p><strong>人生就像一盒多味巧克力，人们永远都不知道下一颗是什么味道，就好像你这颗，很甜。</strong></p><p><strong>身临其境，如一篇“桃花源记”</strong><br><strong>回首向望，是一卷“富春山居”</strong></p><p><strong>在他身上以妙不可言的比例结合在一起</strong></p><p>两年，是什么概念？<br>是把等待日出前的每一场黑夜凝铸，铸成一块徽墨，待东升之时，从容写下眼中最险峻的峰峦与路尽头最静谧的山林。<br>也是把穿透云海时每一抹水汽凝聚，聚成一股涓流，待云烟腾起，悄然晕染天边最壮观的云海与青瓦下最温柔的露珠。</p><p>——来自 摄影师独自一人耗时两年拍摄，这是你梦里的「徽州」吗？评论区</p><p>“<strong>地球这样的行星，是产生不了重元素的</strong>，你身体里的铁，来自璀璨的超新星爆炸”<br>“血液里的锌，源自两次中子星对撞后喷射向宇宙的尘埃”<br>“那微量的铜，更是需要见证一颗白矮星的死亡，即使是最微不足道的钴，也源自几十亿光年外的星云”<br>“某种意义上讲，人类对星空怀有好奇，是正常的。”<br><strong>“渴望见证星河大海的极限，因为我们本就是星辰之子。”</strong><br>“我们DNA里的氮元素，我们牙齿里的钙元素，我们血液里的铁元素，还有我们吃掉的东西里的碳元素，都是曾经大爆炸时的万千星辰散落后组成的，所以我们每个人都是星辰，你我皆为星辰之子，每一个细胞都书写着整个宇宙的历史，当你凝视自己，也望见了宇宙的轮廓”<br><strong>一切生命都是星海的孩子，我们将回归星空</strong></p><p>黄金的体积每年要磨去一千四百分之一，这就是所谓“损耗”。因此全世界流通的十四亿金子每年要损耗一百万。这一百万黄金化作灰尘，飞扬飘荡，变成轻的能够吸入呼出的原子，这种吸入剂像重担一样，压在人的良心上，跟灵魂起了化学作用，<strong>使富人变得傲慢，穷人变得凶狠。</strong><br>——雨果</p><p>“它身上的每一块钢铁、每一部零件，从原料的开采到冶炼，再到浇筑，无不由凡人进行——我们会使用机械代劳。”<br>“孩子，你要知道，这些生产机器的初步构思源于科研人员的头脑、基本架构诞生于设计师的纸笔，而它们的原型机来自于工匠们并不精湛的手艺。<strong>没有神赐，没有神谕</strong>，它们<strong>开始发动的轰鸣之声足以埋葬整个神话时代</strong>。”<br>“这些源于平凡的机器能够改变一个国家乃至世界、能够打碎神明引以为傲的资本，尽管它们无法与神正面媲美。”<br>“但它们却能让我们不再需要‘神’——<strong>至少,让我们拥有选择的权力</strong>。”</p><hr><h3 id="诗句"><strong>诗句</strong></h3><p>蒹葭苍苍，白露为霜。<br><strong>所谓伊人，在水一方</strong></p><p><strong>但愿人长久，千里共婵娟</strong></p><p><strong>郎骑竹马来，绕床弄青梅。</strong><br><strong>同居长干里，两小无嫌猜。</strong></p><p>故人轻抚今人眉，为尔散去半生灾</p><p><strong>纸上得来终觉浅，绝知此事要躬行</strong></p><p>凭君莫话封候事，一将功成万骨枯。</p><p><strong>年年岁岁花相似，岁岁年年人不同。</strong></p><p><strong>回首向来萧瑟处，也无风雨也无晴。</strong></p><p><strong>曾经沧海难为水，除却巫山不是云。</strong></p><p>天街小雨润如酥，草色遥看近却无。</p><p>最是一年春好处，绝胜烟柳满皇都。</p><p><strong>若非脚踏方寸土，不觉此身在人间。</strong></p><p><strong>应是补天余此物，险峰凝雪锢飞霞。</strong></p><p>天若有情天亦老，<strong>人间正道是沧桑</strong>——毛泽东</p><p>忽如一夜春风来，千树万树梨花开（描写雪的）<br>忽如一夜北风来，千树万树雪花白（仿写 描绘梨花开）</p><p><strong>欲买桂花同载酒，终不似，少年游</strong></p><p>“白雪纷纷何所似？”<br>“撒盐空中差可拟。”<br>“未若柳絮因风起。”</p><p>明天会变成什么？<br>会变成一束鲜花，一颗流星，一个愿望<br>会变成一个誓言，一句祝福<br>明天会变成你余下生命的第一天<br>——黑塞</p><p>如梦令·常记溪亭日暮【宋】李清照</p><p>常记溪亭日暮，沉醉不知归路。<br>**兴尽晚回舟，误入藕花深处。**争渡，争渡，惊起一滩鸥鹭。</p><p>青玉案·元夕 南宋 辛弃疾</p><p>**东风夜放花千树。**更吹落，星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。</p><p>蛾儿雪柳黄金缕。笑语盈盈暗香去。<strong>众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。</strong></p><p>宋·苏轼《前赤壁赋》：<br><strong>惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，</strong><br><strong>取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。</strong></p><p>《春江花月夜》 张若虚  称为&quot;孤篇压全唐&quot;<br>……<strong>江畔何人初见月？江月何年初照人？</strong><br>……<strong>白云一片去悠悠，青枫浦上不胜愁。</strong><br>……<strong>谁家今夜扁舟子？何处相思明月楼？</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;语句记录&quot;&gt;&lt;strong&gt;语句记录&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;人民万岁！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;懦者从不启程，弱者退与途中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;唯有遍历星河，才知人间值得。&lt;/str</summary>
      
    
    
    
    <category term="记录" scheme="https://stars-at-dawn.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="书籍" scheme="https://stars-at-dawn.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="记录" scheme="https://stars-at-dawn.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
