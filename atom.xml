<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晨星的博客</title>
  
  
  <link href="https://stars-at-dawn.github.io/atom.xml" rel="self"/>
  
  <link href="https://stars-at-dawn.github.io/"/>
  <updated>2025-10-29T07:59:37.767Z</updated>
  <id>https://stars-at-dawn.github.io/</id>
  
  <author>
    <name>长夜有晨星</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ini制作-记录按键触发次数</title>
    <link href="https://stars-at-dawn.github.io/posts/6008957b"/>
    <id>https://stars-at-dawn.github.io/posts/6008957b</id>
    <published>2025-10-29T07:58:33.000Z</published>
    <updated>2025-10-29T07:59:37.767Z</updated>
    
    <content type="html"><![CDATA[<h3 id="按键触发次数"><strong>按键触发次数</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;攻击检测键（实际就是鼠标左键）</span><br><span class="line"><span class="variable language_">global</span> $key1 = <span class="number">0</span></span><br><span class="line">;记录上一帧的 $key1 状态</span><br><span class="line"><span class="variable language_">global</span> $key1_last = <span class="number">0</span></span><br><span class="line">;触发次数</span><br><span class="line"><span class="variable language_">global</span> $count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Key</span> key1]</span><br><span class="line">condition = $object_detected</span><br><span class="line">key = <span class="variable constant_">NO_CTRL</span> <span class="variable constant_">NO_ALT</span> <span class="variable constant_">VK_LBUTTON</span></span><br><span class="line">type = cycle</span><br><span class="line">$key1 = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Present</span>]</span><br><span class="line">; 检测 key1 从 <span class="number">0</span> 变成 <span class="number">1</span></span><br><span class="line">; 直接检测$key1 == <span class="number">1</span> $count就会不停的增加</span><br><span class="line"><span class="keyword">if</span> $key1 == <span class="number">1</span> &amp;&amp; $key1_last == <span class="number">0</span></span><br><span class="line">    $count = $count + <span class="number">1</span></span><br><span class="line">endif</span><br><span class="line">; 更新上一帧状态</span><br><span class="line">$key1_last = $key1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;按键触发次数&quot;&gt;&lt;strong&gt;按键触发次数&lt;/strong&gt;&lt;/h3&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="鸣潮模组" scheme="https://stars-at-dawn.github.io/categories/%E9%B8%A3%E6%BD%AE%E6%A8%A1%E7%BB%84/"/>
    
    
    <category term="INI制作" scheme="https://stars-at-dawn.github.io/tags/INI%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>模组制作注意事项-整合版-v1.0</title>
    <link href="https://stars-at-dawn.github.io/posts/70ad3282"/>
    <id>https://stars-at-dawn.github.io/posts/70ad3282</id>
    <published>2025-10-29T07:58:33.000Z</published>
    <updated>2025-10-29T07:59:42.820Z</updated>
    
    <content type="html"><![CDATA[<p>; 本文档由晨星制作<br>; 我的B站链接：<a href="https://space.bilibili.com/95747099">https://space.bilibili.com/95747099</a><br>; 我的Youtube：<a href="https://www.youtube.com/channel/UC9maLE-2mYDlZbDNWrX5dxA">https://www.youtube.com/channel/UC9maLE-2mYDlZbDNWrX5dxA</a><br>; 我的爱发电：<a href="https://afdian.com/a/MorningStar?tab=home">https://afdian.com/a/MorningStar?tab=home</a> （现在也没发啥，应该也没人支持吧(＠_＠;)）<br>; 我的香蕉网账号：<a href="https://gamebanana.com/members/2798606">https://gamebanana.com/members/2798606</a><br>; 非我的渠道下载 还收费的，那你就是被骗了！ 记得帮我点点举报（免费分享且标注链接的没有关系）<br>; 我的QQ群：1029406436（欢迎一起聊天吹牛逼，一起玩 ~）</p><p><strong>基本知识</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;表示这行是注释，不会加载</span><br><span class="line"></span><br><span class="line">;[]表示一个对象（更像是一个语句块）？ 差不多也是一个变量，是可以传递的</span><br><span class="line"></span><br><span class="line">;drawindexed表示你的模型组件（一个组件可以包含多个模型 <span class="number">.001</span> <span class="number">.002</span>等等）</span><br><span class="line"></span><br><span class="line">;<span class="variable language_">global</span> $key = <span class="number">0</span> 全局临时变量</span><br><span class="line">;<span class="variable language_">global</span> persis $key = <span class="number">0</span> 全局存储变量（变量存储在<span class="variable constant_">XXMI</span> <span class="title class_">Launcher</span>\<span class="variable constant_">WWMI</span>\d3dx_user.<span class="property">ini</span>文件中）</span><br><span class="line"></span><br><span class="line">;$\<span class="variable constant_">XXX</span>\xxx</span><br><span class="line">;第一个<span class="variable constant_">XXX</span>标识命名空间（有C语言经验的应该很容易明白）</span><br><span class="line">;会有一个对应的<span class="variable constant_">INI</span>文件头部会有下面这句话</span><br><span class="line">namespace = <span class="variable constant_">XXX</span></span><br><span class="line">;第二个xxx表示那个命名空间对应的变量名</span><br></pre></td></tr></table></figure><h2 id="材质-按键">材质/按键</h2><h3 id="透明材质替换"><strong>透明材质替换</strong></h3><p><strong>全透明的材质替换成RabbitFX，不要使用这个</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;任意位置新建这段内容</span><br><span class="line">;[括号里的标识符内容是可以改的，因为你可能不止一个透明材质]</span><br><span class="line">[<span class="title class_">CustomShaderTransparency</span>]</span><br><span class="line">blend = <span class="variable constant_">ADD</span> <span class="variable constant_">BLEND_FACTOR</span> <span class="variable constant_">INV_BLEND_FACTOR</span></span><br><span class="line">blend_factor[<span class="number">0</span>] = <span class="number">0.0</span>-<span class="number">1.0</span></span><br><span class="line">blend_factor[<span class="number">1</span>] = <span class="number">0.0</span>-<span class="number">1.0</span></span><br><span class="line">blend_factor[<span class="number">2</span>] = <span class="number">0.0</span>-<span class="number">1.0</span></span><br><span class="line">blend_factor[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">handling = skip</span><br><span class="line">;要替换的模型，可以在下面[<span class="title class_">TextureOverrideComponentX</span>]里找到这些变量</span><br><span class="line">drawindexed = <span class="number">66666</span>, <span class="number">666</span>, <span class="number">666</span></span><br><span class="line"></span><br><span class="line">;;;替换材质步骤</span><br><span class="line">;找到你刚才的那行数据[drawindexed = <span class="number">66666</span>, <span class="number">666</span>, <span class="number">666</span>]</span><br><span class="line">;替换成对应的run=<span class="title class_">CustomShaderTransparency</span>（你刚才命名的数据）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RabbitFX-透明贴图"><strong>RabbitFX&amp;透明贴图</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;创建原始的光照贴图（<span class="variable constant_">RGB</span>控制颜色，A控制亮度）</span><br><span class="line">[<span class="title class_">ResourceLegEffectMap</span>]</span><br><span class="line">filename = <span class="title class_">Textures</span>/light.<span class="property">dds</span></span><br><span class="line"></span><br><span class="line">;创建原始的透明贴图(根据透明度来判断)</span><br><span class="line">[<span class="title class_">ResourceTransparencyMask</span>]</span><br><span class="line">filename = <span class="title class_">Textures</span>/<span class="title class_">Transparency</span>.<span class="property">dds</span></span><br><span class="line"></span><br><span class="line">;找到你要发光的组件</span><br><span class="line">[<span class="title class_">TextureOverrideComponentX</span>]</span><br><span class="line">...</span><br><span class="line">        run = <span class="title class_">CommandListTriggerResourceOverrides</span></span><br><span class="line">        run = <span class="title class_">CommandListOverrideSharedResources</span></span><br><span class="line">        </span><br><span class="line">        ;主要添加的语句块（<span class="variable constant_">HSV</span>调色板，有兴趣可以看一下，很多调色软件也有这玩意）</span><br><span class="line">        $\rabbitfx\h = <span class="number">0</span></span><br><span class="line">        $\rabbitfx\s = <span class="number">0</span></span><br><span class="line">        $\rabbitfx\v = <span class="number">0</span></span><br><span class="line">        $\rabbitfx\brightness = <span class="number">10</span></span><br><span class="line">        $\rabbitfx\interpolate = <span class="number">1</span></span><br><span class="line">        <span class="title class_">Resource</span>\<span class="title class_">RabbitFX</span>\<span class="title class_">GlowMap</span> = ref <span class="title class_">ResourceLegEffectMap</span></span><br><span class="line">        ;这是透明效果的写法</span><br><span class="line">        ;<span class="title class_">Resource</span>\<span class="title class_">RabbitFX</span>\<span class="title class_">FXMap</span> = ref <span class="title class_">ResourceTransparencyMask</span></span><br><span class="line">        run = <span class="title class_">CommandList</span>\<span class="title class_">RabbitFX</span>\<span class="title class_">Run</span></span><br><span class="line">        ;------------------------------------------</span><br><span class="line"></span><br><span class="line">        ;加载模型</span><br><span class="line">        drawindexed = <span class="number">28770</span>, <span class="number">106563</span>, <span class="number">0</span></span><br><span class="line">        run = <span class="title class_">CommandListCleanupSharedResources</span></span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="按键切换模型"><strong>按键切换模型</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;新建变量</span><br><span class="line"><span class="variable language_">global</span> persis $key1 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">;任意位置新建这段内容</span><br><span class="line">;[括号里的标识符内容是可以改的，因为你可能不止一个切换按钮]</span><br><span class="line">[<span class="title class_">Key</span> key1]</span><br><span class="line">condition = $object_detected</span><br><span class="line">;按键可以是英文也可以是特殊按键，像手柄之类的</span><br><span class="line">key = <span class="variable constant_">NO_CTRL</span> <span class="variable constant_">NO_ALT</span> <span class="variable constant_">VK_DOWN</span></span><br><span class="line">type = cycle</span><br><span class="line">;切换的数量：可以往后写 <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>……</span><br><span class="line">$key1 = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;切换步骤</span><br><span class="line">;找到你要切换的模型，可以在[<span class="title class_">TextureOverrideComponentX</span>]里找到这些模型</span><br><span class="line">;找到组件渲染的那行代码 drawindexed = <span class="number">66666</span>, <span class="number">666</span>, <span class="number">666</span></span><br><span class="line"><span class="keyword">if</span> $key1 == <span class="number">0</span></span><br><span class="line">; <span class="title class_">Draw</span> <span class="title class_">Component</span> <span class="number">2</span></span><br><span class="line">drawindexed = <span class="number">66666</span>, <span class="number">666</span>, <span class="number">666</span></span><br><span class="line">; 也可以像透明材质一样写这句话</span><br><span class="line"> ; run=<span class="title class_">CustomShaderTransparency</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> $key1 == <span class="number">1</span></span><br><span class="line">; <span class="title class_">Draw</span> <span class="title class_">Component</span> <span class="number">2.001</span></span><br><span class="line">drawindexed = <span class="number">77777</span>, <span class="number">777</span>, <span class="number">777</span></span><br><span class="line">endif</span><br><span class="line">;这里很重要，endif不加,语序会识别错误，会导致模型加载混乱抽搐，很多时候找不到问题就是这个原因</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="按键切换贴图"><strong>按键切换贴图</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span> $active = <span class="number">0</span></span><br><span class="line">;新建变量</span><br><span class="line"><span class="variable language_">global</span> persis $key = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Key</span> key]</span><br><span class="line">;切换条件，可以是别的条件,也可以不加</span><br><span class="line">;condition = <span class="variable language_">global</span> $active = <span class="number">1</span></span><br><span class="line">key = <span class="variable constant_">NO_CTRL</span> <span class="variable constant_">NO_ALT</span> <span class="variable constant_">VK_UP</span></span><br><span class="line">type = cycle</span><br><span class="line">;更多的切换和模型切换同理</span><br><span class="line">$key = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">ResourceTextureX</span>]</span><br><span class="line">filename = <span class="title class_">Textures</span>/<span class="title class_">Components</span>-<span class="number">2</span> t=xxx.<span class="property">dds</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">ResourceTextureX</span>-<span class="number">1</span>]</span><br><span class="line">filename = <span class="title class_">Textures</span>/xxx.<span class="property">dds</span></span><br><span class="line">;这里的xxx.<span class="property">dds</span>是你自己新建的贴图放在<span class="title class_">Textures</span>文件夹里的</span><br><span class="line"></span><br><span class="line">[<span class="title class_">TextureOverrideTextureX</span>]</span><br><span class="line">hash = 225aad5a</span><br><span class="line">match_priority = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> $key == <span class="number">0</span></span><br><span class="line"><span class="variable language_">this</span> = <span class="title class_">ResourceTextureX</span></span><br><span class="line">;我知道你想说什么，没有打错，就是elif</span><br><span class="line">elif $key == <span class="number">1</span></span><br><span class="line"><span class="variable language_">this</span> = <span class="title class_">ResourceTextureX</span>-<span class="number">1</span></span><br><span class="line">endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="按键触发次数"><strong>按键触发次数</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;攻击检测键（实际就是鼠标左键）</span><br><span class="line"><span class="variable language_">global</span> $key1 = <span class="number">0</span></span><br><span class="line">;记录上一帧的 $key1 状态</span><br><span class="line"><span class="variable language_">global</span> $key1_last = <span class="number">0</span></span><br><span class="line">;触发次数</span><br><span class="line"><span class="variable language_">global</span> $count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Key</span> key1]</span><br><span class="line">condition = $object_detected</span><br><span class="line">key = <span class="variable constant_">NO_CTRL</span> <span class="variable constant_">NO_ALT</span> <span class="variable constant_">VK_LBUTTON</span></span><br><span class="line">type = cycle</span><br><span class="line">$key1 = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Present</span>]</span><br><span class="line">; 检测 key1 从 <span class="number">0</span> 变成 <span class="number">1</span></span><br><span class="line">; 直接检测$key1 == <span class="number">1</span> $count就会不停的增加</span><br><span class="line"><span class="keyword">if</span> $key1 == <span class="number">1</span> &amp;&amp; $key1_last == <span class="number">0</span></span><br><span class="line">    $count = $count + <span class="number">1</span></span><br><span class="line">endif</span><br><span class="line">; 更新上一帧状态</span><br><span class="line">$key1_last = $key1</span><br></pre></td></tr></table></figure><h3 id="按键长按触发">按键长按触发</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title class_">Constants</span>]</span><br><span class="line"><span class="variable language_">global</span> $hold = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">KeyClick1</span>]</span><br><span class="line">;启动条件（可以是检测变量等）</span><br><span class="line">condition = $\<span class="title class_">Mod009</span>\enable_mods</span><br><span class="line">;切换键，别的也行（此处是鼠标左键）</span><br><span class="line">key = no_ctrl no_shift alt <span class="variable constant_">VK_LBUTTON</span></span><br><span class="line">;关键,切换的类型（长按）</span><br><span class="line">type = hold</span><br><span class="line">;切换的变量</span><br><span class="line">$hold = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="模型检测切换"><strong>模型检测切换</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">;新建切换变量</span><br><span class="line">persist <span class="variable language_">global</span> $key = <span class="number">0</span></span><br><span class="line">;新建检测变量</span><br><span class="line"><span class="variable language_">global</span> $attack = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Key</span> key]</span><br><span class="line">;条件是检测到物体生成</span><br><span class="line">condition = $object_detected == <span class="number">1</span></span><br><span class="line">key = <span class="variable constant_">NO_CTRL</span> <span class="variable constant_">NO_ALT</span> <span class="variable constant_">VK_DOWN</span></span><br><span class="line">type = cycle</span><br><span class="line">;要切换的部件使用的变量（使用参考“切换模型”篇）</span><br><span class="line">$key = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">;找到[<span class="title class_">Present</span>]代码</span><br><span class="line">;帧计算代码</span><br><span class="line">[<span class="title class_">Present</span>]</span><br><span class="line"><span class="keyword">if</span> $object_detected</span><br><span class="line"><span class="keyword">if</span> $mod_enabled</span><br><span class="line">post $object_detected = <span class="number">0</span></span><br><span class="line">run = <span class="title class_">CommandListUpdateMergedSkeleton</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> $mod_id == -<span class="number">1000</span></span><br><span class="line">run = <span class="title class_">CommandListRegisterMod</span></span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line">;加上这两句，即模型加载完毕后执行变量赋值操作</span><br><span class="line">$key = $attack</span><br><span class="line">$attack = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">;新建<span class="title class_">TextureOverri</span>语句块</span><br><span class="line">;<span class="variable constant_">IB</span>（<span class="title class_">Hash</span>）通过游戏中手动筛选查找</span><br><span class="line">[<span class="title class_">TextureOverrideA</span>]</span><br><span class="line">hash = xxx</span><br><span class="line">;出现模型对应的hash就会影响变量，key也会随之改变</span><br><span class="line">;直接赋值key的话，物品消失后就无法重置</span><br><span class="line">$attack = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">TextureOverrideB</span>]</span><br><span class="line">hash = xxx</span><br><span class="line">$attack = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">;索引切换代码（参考模型切换或者贴图切换）</span><br><span class="line">[<span class="title class_">TextureOverrideComponentX</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="控制模型权重">控制模型权重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title class_">TextureOverrideComponentX</span>]</span><br><span class="line">;控制这句话是否执行即可（应该是合并骨骼？）</span><br><span class="line">;注意不执行后会保留那一瞬间的状态（所以不能一开始就关闭，不然模型会出问题）</span><br><span class="line">;这行代码注释只能控制这个模型组件的权重影响</span><br><span class="line">run = <span class="title class_">CommandListMergeSkeleton</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="合并用到的贴图"><strong>合并用到的贴图</strong></h3><p>在需要烘焙的模型上新建一个UV（名称需一样）</p><p>选中所有的需要烘焙的物体，再选中你新建的UV，然后在UV视图点击顶部的UV选项，选择重排孤岛，或者智能UV投射，别的都行，这步就是让UV不重叠，手动排都行</p><p>模型的材质中都需要新建一个纹理贴图（其中的图片就是最终输出的材质，所以必须都是同一张贴图）</p><p>然后右边选中渲染选项（小电视图标），选中Cycles模式，<br>采样选项卡中的渲染选项，将降噪关了，采样改成10（不改也没事，就是慢一点）；烘焙类型选择漫射（漫反射贴图，需要什么选什么），将直接光、间接光关闭（会渲染环境光，看你的需求）边距给8-32px（看你贴图的大小，8K的建议32，1K就8就行了）</p><p>最后烘焙之前一定要保证3D视图选中所有的模型，所有模型的材质视图选中新建的那个纹理节点，然后选中新建的UV，点击烘焙按钮等待一个个烘焙到那个贴图即可，然后保存贴图，使用新的UV和材质即可</p><hr><h2 id="UI">UI</h2><h3 id="显示文本"><strong>显示文本</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; 打印文本（默认屏幕中央且为黑底白字）</span><br><span class="line">[<span class="title class_">CommandListPrintText</span>]</span><br><span class="line">; <span class="title class_">Input</span>:</span><br><span class="line">; <span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">Text</span></span><br><span class="line">; <span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">TextParams</span></span><br><span class="line">;</span><br><span class="line">; 使用示例</span><br><span class="line"><span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">Text</span> = ref <span class="title class_">ResourceTextExample</span></span><br><span class="line"><span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">TextParams</span> = ref <span class="title class_">ResourceTextParamsExample</span></span><br><span class="line">run = <span class="title class_">CommandList</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">PrintText</span></span><br><span class="line"></span><br><span class="line">;文本内容</span><br><span class="line">[<span class="title class_">ResourceTextExample</span>]</span><br><span class="line">type = <span class="title class_">Buffer</span></span><br><span class="line">data = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">;文本格式</span><br><span class="line">[<span class="title class_">ResourceTextParamsExample</span>]</span><br><span class="line">type = <span class="title class_">StructuredBuffer</span></span><br><span class="line">array = <span class="number">1</span></span><br><span class="line">data = <span class="variable constant_">R32_FLOAT</span>  -<span class="number">0.25</span> +<span class="number">0.15</span> +<span class="number">0.25</span> -<span class="number">0.05</span>   <span class="number">1.00</span> <span class="number">1.00</span> <span class="number">1.00</span> <span class="number">1.00</span>   <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.95</span>   <span class="number">0.02</span>  <span class="number">0.05</span>   <span class="number">2</span> <span class="number">1</span>   <span class="number">1</span>   <span class="number">1.0</span></span><br><span class="line">;                x1-^  y1-^  x2-^  y2-^   | R-^  G-^  B-^  A-^  | R-^  G-^  B-^  A-^  | ^-H    V-^ | ^ ^ | ^- text <span class="attr">alignment</span>: <span class="number">0</span>=left <span class="number">1</span>=center <span class="number">2</span>=right | ^- font scale</span><br><span class="line">;                <span class="title class_">Rectangle</span> (range -<span class="number">1</span>:+<span class="number">1</span>)  | <span class="title class_">Text</span> <span class="title class_">Color</span>          | <span class="title class_">Background</span> <span class="title class_">Color</span>    | <span class="title class_">Border</span>     |  ^- h/v-<span class="attr">anchor</span>: <span class="number">0</span>=none <span class="number">1</span>=left/top <span class="number">2</span>=center <span class="number">3</span>=right/bottom </span><br><span class="line"></span><br><span class="line">;运行语句</span><br><span class="line">run = <span class="title class_">CommandListPrintText</span></span><br><span class="line"></span><br><span class="line">;代码案例来自文件： ..\<span class="variable constant_">XXMI</span> <span class="title class_">Launcher</span>\<span class="variable constant_">WWMI</span>\<span class="title class_">Core</span>\<span class="variable constant_">WWMI</span>\<span class="title class_">WuWa</span>-<span class="title class_">Model</span>-<span class="title class_">Importer</span>.<span class="property">ini</span></span><br></pre></td></tr></table></figure><h3 id="滑块UI使用"><strong>滑块UI使用</strong></h3><p>默认滑块的使用需要<strong>按住ALT键拖动</strong>（当然你也可以改成别的键）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">;此滑块工具主要代码来自momo制作</span><br><span class="line">;使用方式</span><br><span class="line"></span><br><span class="line">;滑块工具的<span class="variable constant_">INI</span>---------------------------------------------------</span><br><span class="line">[<span class="title class_">Present</span>]</span><br><span class="line">;是否启动滑块页面检测</span><br><span class="line"><span class="keyword">if</span> ($\<span class="title class_">ModXXX</span>\enable_mods)</span><br><span class="line">…… </span><br><span class="line">;输出变量参数到模组<span class="variable constant_">INI</span>中（乘几可以自己改，slider_value变量值为[<span class="number">0</span> - <span class="number">1</span>]）</span><br><span class="line">$\<span class="title class_">ModXXX</span>\mod_val = $slider_value * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;模组<span class="variable constant_">INI</span>---------------------------------------------------------</span><br><span class="line">;顶部中添加命名空间（名称随意，这里只是方便区分）</span><br><span class="line">namespace=<span class="title class_">ModXXX</span></span><br><span class="line"></span><br><span class="line">;启动滑块变量</span><br><span class="line"><span class="variable language_">global</span> $enable_mods=<span class="number">0</span></span><br><span class="line">;接收滑块的参数（形态键的值）</span><br><span class="line"><span class="variable language_">global</span> $mod_val=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Key</span> enable_mods]</span><br><span class="line">condition = $object_detected</span><br><span class="line">;按键可以是英文也可以是特殊按键，像手柄之类的</span><br><span class="line">key = <span class="variable constant_">NO_CTRL</span> <span class="variable constant_">NO_ALT</span> <span class="variable constant_">VK_DOWN</span></span><br><span class="line">type = cycle</span><br><span class="line">$enable_mods = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">;参考上面的自定义形态键</span><br><span class="line">[<span class="title class_">CommandListSetShapeKey</span>]</span><br><span class="line">……</span><br><span class="line">;形态键的值使用传入的变量</span><br><span class="line">$\<span class="title class_">WWMIv1</span>\shapekey_value = $mod_val</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="模型">模型</h2><h3 id="模型大小"><strong>模型大小</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;<span class="variable constant_">WWMI</span> 的核心机制之一: 模型是通过骨架合并，在 <span class="variable constant_">GPU</span> 中统一缩放到对应的顶点位置</span><br><span class="line"></span><br><span class="line">[<span class="title class_">TextureOverrideMyCharacter</span>]</span><br><span class="line">;需要指定放大物品的 <span class="title class_">Hash</span></span><br><span class="line">hash = c7aae00c</span><br><span class="line">;放大倍率</span><br><span class="line">$\<span class="title class_">WWMIv1</span>\custom_mesh_scale = <span class="number">0.5</span></span><br><span class="line">run = $\<span class="title class_">WWMIv1</span>\<span class="title class_">CustomShaderSkeletonMerger</span></span><br><span class="line"></span><br><span class="line">;记得把这里的这句话删掉（改这里也能实现这个效果，但是是整体的）</span><br><span class="line">[<span class="title class_">CommandListMergeSkeleton</span>]</span><br><span class="line">;$\<span class="title class_">WWMIv1</span>\custom_mesh_scale = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="自定义形态键"><strong>自定义形态键</strong></h3><p><strong>有形态键的组件才能自定义形态键</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;根据<span class="title class_">WuWa</span>-<span class="title class_">Model</span>-<span class="title class_">Importer</span>.<span class="property">ini</span>给出的[<span class="title class_">CommandListSetShapeKey</span>]参考</span><br><span class="line">;得出如下使用方式（名称可以自定义，不一定是<span class="title class_">CommandListSetShapeKey</span>）</span><br><span class="line">[<span class="title class_">CommandListSetShapeKey</span>]</span><br><span class="line">; <span class="title class_">Usage</span> example</span><br><span class="line">; 这里是形态键对应的<span class="variable constant_">ID</span>（blender中形如 <span class="title class_">Deform</span> <span class="variable constant_">XXX</span>）</span><br><span class="line">; 序号记得改大点,不要和原模型的重复（一般都是<span class="number">105</span>以后就没了）</span><br><span class="line">$\<span class="title class_">WWMIv1</span>\shapekey_id = <span class="number">105</span></span><br><span class="line">; 给的形态键的值,与blender中形态键的值一样</span><br><span class="line">$\<span class="title class_">WWMIv1</span>\shapekey_value = <span class="number">2</span></span><br><span class="line">cs-u5 = <span class="title class_">ResourceCustomShapeKeyValuesRW</span></span><br><span class="line">run = <span class="title class_">CommandList</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">SetShapeKey</span></span><br><span class="line">$shapekey_mode = <span class="number">0</span></span><br><span class="line">run = <span class="title class_">CustomShaderShapeKeySetter</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Present</span>]</span><br><span class="line"><span class="keyword">if</span> $object_detected</span><br><span class="line">    <span class="keyword">if</span> $mod_enabled</span><br><span class="line">        post $object_detected = <span class="number">0</span></span><br><span class="line">        run = <span class="title class_">CommandListUpdateMergedSkeleton</span></span><br><span class="line">        ;每一帧都检测形态键的变化？（反正就是运行它）</span><br><span class="line">    run = <span class="title class_">CommandListSetShapeKey</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="留下指定的形态键"><strong>留下指定的形态键</strong></h3><p>需复制出一个你已经调整好的物体</p><p>然后将原来的物体应用所有的形态键</p><p>选中复制物体中 你需要导出的形态键，然后选中复制的物体，和原来的物体，在原来物体的形态键选项框右边点击“V”小三角，再选择传递形态键即可将你选中的形态键传递过来</p><h3 id="角色检测：模型替换"><strong>角色检测</strong>：模型替换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title class_">Constants</span>]</span><br><span class="line">;检测变量</span><br><span class="line"><span class="variable language_">global</span> $ModActive = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">TextureOverrideYangyangPosition</span>]</span><br><span class="line">;检测语句，加载贴图的<span class="title class_">Hash</span>（角色里随便选一个就行）</span><br><span class="line">hash = aa467d8c</span><br><span class="line">$ModActive = <span class="number">2</span></span><br><span class="line">match_priority = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">Present</span>]</span><br><span class="line">; 保证只存活 <span class="number">1</span> 帧</span><br><span class="line">post $ModActive = $ModActive - <span class="number">1</span></span><br><span class="line">; 只有当 $ModActive &gt; <span class="number">0</span> 时才打开总开关【检测-关闭模组】</span><br><span class="line"><span class="keyword">if</span> $ModActive &gt; <span class="number">0</span></span><br><span class="line">    $object_detected = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    $object_detected = <span class="number">0</span></span><br><span class="line">endif</span><br><span class="line">; …………原来的逻辑</span><br><span class="line"></span><br><span class="line">; 【检测-关闭模组】</span><br><span class="line">; 如果说要关闭模组需要在所有的[<span class="title class_">TextureOverrideComponentX</span>]中添加下面的代码</span><br><span class="line">[<span class="title class_">TextureOverrideComponent0</span>]】</span><br><span class="line">; $object_detected = <span class="number">1</span> 这行改成下面的代码</span><br><span class="line">; 先判断是不是目标角色</span><br><span class="line"><span class="keyword">if</span> $Mod010Active &gt; <span class="number">0</span></span><br><span class="line">    $object_detected = <span class="number">1</span></span><br><span class="line">endif</span><br><span class="line">; <span class="keyword">if</span> $mod_enabled 这行改成下面的</span><br><span class="line"><span class="keyword">if</span> $mod_enabled &amp;&amp; $object_detected</span><br><span class="line">; …………原来的逻辑不变</span><br><span class="line"></span><br><span class="line">; 【检测-替换贴图】</span><br><span class="line">; 找到你要替换贴图的地方</span><br><span class="line">[<span class="title class_">TextureOverrideTexture3</span>]</span><br><span class="line">hash = 8c2f4684</span><br><span class="line">match_priority = <span class="number">0</span></span><br><span class="line">; 这里写 == <span class="number">1</span> 也是可以的</span><br><span class="line"><span class="keyword">if</span> $ModActive &gt; <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span> = <span class="title class_">ResourceTexture3</span></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><h3 id="动画制作"><strong>动画制作</strong></h3><p>这是针对<strong>不改变模型面数</strong>的动画制作</p><p><strong>复杂的模型只能通过大量的IF去判断帧数执行对应的渲染了</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title class_">Constants</span>] </span><br><span class="line"><span class="variable language_">global</span> $frame = <span class="number">0</span> </span><br><span class="line">;速度变量（等会要用）</span><br><span class="line"><span class="variable language_">global</span> persist $speed = <span class="number">0.5</span> </span><br><span class="line">;起始帧</span><br><span class="line"><span class="variable language_">global</span> $start_frame = <span class="number">0</span> </span><br><span class="line">;结束帧</span><br><span class="line"><span class="variable language_">global</span> $end_frame = <span class="number">30</span> </span><br><span class="line">;规整化（等会要用）</span><br><span class="line"><span class="variable language_">global</span> $frame_value = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">[<span class="title class_">Present</span>] </span><br><span class="line">;在帧运算中加入如下代码：</span><br><span class="line"><span class="keyword">if</span> $frame &gt; $end_frame </span><br><span class="line">$frame = $start_frame </span><br><span class="line">endif </span><br><span class="line">; 规整化，防止出现渲染半帧的情况（如果不影响整体效果，则不添加也没事）</span><br><span class="line"><span class="keyword">if</span> $frame_value &gt;= <span class="number">1</span></span><br><span class="line">$frame = $frame + <span class="number">1</span></span><br><span class="line">$frame_value = <span class="number">0</span></span><br><span class="line">endif</span><br><span class="line">$frame_value = $frame_value + $speed</span><br><span class="line">;可以设置切换键，暂停动画播放（可以参考按键切换模型内容）</span><br><span class="line"><span class="keyword">if</span> $key == <span class="number">1</span> </span><br><span class="line">$frame = $start_frame </span><br><span class="line">endif </span><br><span class="line"></span><br><span class="line">[<span class="title class_">TextureOverrideComponentN</span>]</span><br><span class="line">;找到加载的模型语句</span><br><span class="line">; <span class="title class_">Draw</span> <span class="title class_">Component</span> <span class="number">2.</span><span class="variable constant_">XXX_001</span></span><br><span class="line">drawindexed = <span class="number">2304</span>, <span class="number">137607</span>, <span class="number">0</span></span><br><span class="line">; <span class="title class_">Draw</span> <span class="title class_">Component</span> <span class="number">2.</span>烟雾<span class="number">1_002</span></span><br><span class="line">drawindexed = <span class="number">2304</span>, <span class="number">139911</span>, <span class="number">0</span></span><br><span class="line">……</span><br><span class="line">;你会发现它们的面数是等差数列</span><br><span class="line">;所以就有了如下写法</span><br><span class="line">;使用第一个模型为模板，然后通过帧数和面数（差值）的乘积逐级递增</span><br><span class="line">;即可做到模型按顺序渲染的效果（动画）</span><br><span class="line">drawindexed = <span class="number">2304</span>, <span class="number">137607</span> + $frame * <span class="number">2304</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">; 带按键切换动画且能倒放的制作 --------------------------------------------------------</span><br><span class="line">[<span class="title class_">Present</span>] </span><br><span class="line">;在帧运算中加入如下代码：</span><br><span class="line">;初始态：按下按键,且动画未播放完，则进入语句播放至结尾</span><br><span class="line"><span class="keyword">if</span> $key1 == <span class="number">1</span> &amp;&amp; $frame &lt; $end_frame </span><br><span class="line">; 规整化，防止出现渲染半帧的情况</span><br><span class="line"><span class="keyword">if</span> $frame_value &gt;= <span class="number">1</span></span><br><span class="line">$frame = $frame + $frame_value</span><br><span class="line">$frame_value = <span class="number">0</span></span><br><span class="line">endif</span><br><span class="line">$frame_value = $frame_value + $speed</span><br><span class="line">endif </span><br><span class="line"></span><br><span class="line">;倒放态：按下按键,且动画已经播放一段时间，则进入语句倒放至开头</span><br><span class="line"><span class="keyword">if</span> $key1 == <span class="number">0</span> &amp;&amp; $frame &gt; <span class="number">0</span></span><br><span class="line">; 规整化，防止出现渲染半帧的情况</span><br><span class="line"><span class="keyword">if</span> $frame_value &gt;= <span class="number">1</span></span><br><span class="line">$frame = $frame - <span class="number">1</span></span><br><span class="line">$frame_value = <span class="number">0</span></span><br><span class="line">endif</span><br><span class="line">$frame_value = $frame_value + $speed</span><br><span class="line">endif </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自定义骨骼">自定义骨骼</h3><hr><h2 id="着色器">着色器</h2><h3 id="着色器颜色修改">着色器颜色修改</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float4 v1 :  <span class="variable constant_">XXXX</span></span><br><span class="line">out float4 o0 :  <span class="variable constant_">XXXX</span></span><br><span class="line">;float 代表 参数类型：<span class="number">4</span> 代表其有四个组件（x,y,z,w）</span><br><span class="line">;x,y,z：代表<span class="variable constant_">RGB</span> | w 代表着色范围？</span><br><span class="line">;v1（vX）: 输入值</span><br><span class="line">;o0（oX）: 输出值</span><br><span class="line"></span><br><span class="line">;赋值语句</span><br><span class="line">o0.<span class="property">x</span> = <span class="number">0.2</span></span><br><span class="line">o0.<span class="property">x</span> -= <span class="number">0.1</span></span><br><span class="line">o0.<span class="property">xyz</span> = <span class="title function_">float3</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">;<span class="attr">t0</span>: 纹理</span><br><span class="line">;<span class="attr">r0</span>: 寄存器——存放临时变量</span><br><span class="line">;<span class="attr">cb0</span>: 常量缓冲区——游戏内部的值，如时间、位置等</span><br><span class="line"></span><br><span class="line">  o0.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">  o0.<span class="property">y</span> = <span class="number">0</span></span><br><span class="line">  o0.<span class="property">z</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="着色器检测触发"><strong>着色器检测触发</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 着色器代码 ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 注册变量“ACTIVE”在第160的位置上（只有一个x组件）</span></span><br><span class="line">#define <span class="variable constant_">ACTIVE</span> <span class="title class_">IniParams</span>[<span class="number">160</span>].<span class="property">x</span> </span><br><span class="line"><span class="comment">// 注意main方法的位置</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最底下（要在return的前面）</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">ACTIVE</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// 根据你想要的输出参数来写</span></span><br><span class="line">o0.<span class="property">xyzw</span> = <span class="title function_">float4</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">o0.<span class="property">xyzw</span> = <span class="title function_">float4</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">;模组<span class="variable constant_">INI</span>代码 ---------------------------------------------------------------</span><br><span class="line">[<span class="title class_">Constants</span>]</span><br><span class="line">;特效着色器检测键</span><br><span class="line"><span class="variable language_">global</span> $ShaderKey = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="title class_">ShaderOverride</span>]</span><br><span class="line">;你的着色器的<span class="title class_">Hash</span>（如 55ee3565231ff874-ps_replace <span class="title class_">Hash</span>就是前面那串字符）</span><br><span class="line">hash = 55ee3565231ff874</span><br><span class="line">;刚才你注册的变量位置</span><br><span class="line">x160 = $ShaderKey</span><br></pre></td></tr></table></figure><h3 id="着色器指定dump"><strong>着色器指定dump</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;在\<span class="variable constant_">XXMI</span> <span class="title class_">Launcher</span>\<span class="variable constant_">WWMI</span>\d3dx.<span class="property">ini</span>文件中将下面这行话注释掉</span><br><span class="line">;这句话是转储所有的纹理和缓冲</span><br><span class="line">;analyse_options = dump_rt dump_tex dump_cb dump_vb dump_ib buf txt</span><br><span class="line"></span><br><span class="line">;在<span class="title class_">Mod</span>文件夹任意位置中创建一个<span class="variable constant_">INI</span></span><br><span class="line">[<span class="title class_">ShaderOverrideGlider</span>]</span><br><span class="line">;通过小键盘<span class="number">0</span> 开启狩猎模式 <span class="number">1</span> / <span class="number">2</span> 控制着色器 <span class="number">3</span> 复制着色器<span class="title class_">Hash</span></span><br><span class="line">;获取到你需要的着色器（对应的物体消失，或是没有贴图）</span><br><span class="line">hash = 7191d68ad7775895</span><br><span class="line">;加上转储的语句，就会将此着色器影响的物体dump下来</span><br><span class="line">analyse_options = dump_rt dump_tex dump_cb dump_vb dump_ib buf txt dds</span><br><span class="line">;如果发现dump都不完整，可以将多个着色器一起启用</span><br><span class="line">;或者直接恢复d3dx文件的语句执;行全dump</span><br></pre></td></tr></table></figure><h2 id="其它内容">其它内容</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">;这句话控制模组的执行</span><br><span class="line">run = <span class="title class_">CommandListUpdateMergedSkeleton</span></span><br><span class="line"></span><br><span class="line">;可以直接通过cursor_x和cursor_y获取鼠标的位置</span><br><span class="line"></span><br><span class="line">;time表示游戏开始后经过的秒数</span><br><span class="line"></span><br><span class="line">[present]</span><br><span class="line">;表示每帧都进行运算</span><br><span class="line"></span><br><span class="line">[<span class="title class_">TextureOverrideXXX</span>]</span><br><span class="line">;游戏运行的物体hash</span><br><span class="line">hash = xxx</span><br><span class="line">;运行的内容: 如着色器等</span><br><span class="line">run = xxx</span><br><span class="line">;替换的内容: 如贴图等</span><br><span class="line"><span class="variable language_">this</span> = xxx</span><br><span class="line">;跳过绘制</span><br><span class="line">handling = skip </span><br><span class="line"></span><br><span class="line">;转储的文件，文件名开头的 <span class="number">6</span> 位数字字符串，代表纹理绘制的顺序</span><br><span class="line">;deduped中的文件: 结构为哈希-文件类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;常用例：</span><br><span class="line">;[<span class="title class_">Constants</span>]--每一个ini为独立的命名空间，该段配置该空间内的全局变量</span><br><span class="line"></span><br><span class="line">;[<span class="title class_">Present</span>]--每一帧都会执行该段内的代码，用于变量初始化和动态变化</span><br><span class="line"></span><br><span class="line">;[<span class="title class_">Key</span>*]--按键检测，触发相应按键时执行代码</span><br><span class="line">  </span><br><span class="line">;[<span class="title class_">TextureOverride</span>*]--用于匹配和覆盖贴图、模型资源，匹配到相应资源时执行</span><br><span class="line"></span><br><span class="line">;[<span class="title class_">ShaderOverride</span>*]--用于匹配和覆盖着色器资源，匹配到时执行.......等等</span><br><span class="line">  </span><br><span class="line">;[<span class="title class_">CustomShader</span>*]--用于加载和配置自定义着色器文件，需用run=*段名*执行</span><br><span class="line"></span><br><span class="line">;[<span class="title class_">CommandList</span>*]--用于自定义代码块，可以将需要多次执行的代码块变量定义、 初始化、判断等等</span><br><span class="line">;操作放到一个段内，需要的时候用run=*段名*执行</span><br><span class="line">  </span><br><span class="line">;有两种着色器</span><br><span class="line">  ;<span class="variable constant_">VS</span>（顶点着色器）：控制物体绘制的位置</span><br><span class="line">  ;<span class="variable constant_">PS</span>（像素着色器）：控制物体绘制的外观</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">;ini顶部的[<span class="title class_">Constants</span>]定义模型的面数等数据不要修改</span><br><span class="line">;修改模型后一定要自动生成<span class="variable constant_">INI</span>，保证下面数据的准确</span><br><span class="line">[<span class="title class_">Constants</span>]</span><br><span class="line"><span class="variable language_">global</span> $required_wwmi_version = <span class="number">0.91</span></span><br><span class="line"><span class="variable language_">global</span> $object_guid = <span class="number">200604</span></span><br><span class="line"><span class="variable language_">global</span> $mesh_vertex_count = <span class="number">56382</span></span><br><span class="line"><span class="variable language_">global</span> $shapekey_vertex_count = <span class="number">30463</span></span><br><span class="line">[<span class="title class_">TextureOverrideComponentX</span>]</span><br><span class="line">match_first_index = <span class="number">14907</span></span><br><span class="line">match_index_count = <span class="number">13692</span></span><br><span class="line"></span><br><span class="line">; 使用一个未定义的变量默认值是<span class="number">1</span>（很多时候切换键有问题就是因为这个）</span><br></pre></td></tr></table></figure><h4 id="VK虚拟键码">VK虚拟键码</h4><p>为什么要用这个？个人觉得还是主要因为这个区分度高？</p><p>实际上直接写 up 与 VK_UP 的效果是一样的（不过我没试过手柄，可能和这有关系）</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes">https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes</a></p><h4 id="WWMI-Tools">WWMI-Tools</h4><p>工具对应的中文名称</p><ol><li><strong>为具有形状键的对象应用修改器</strong>（脸部模型删除骨骼时使用）</li><li>合并顶点组</li><li>填充顶点组中的间隙</li><li>删除未使用的顶点组（方便刷权重）</li><li>删除所有顶点组（点一下就好了，挺快的）</li><li>创建合并对象</li><li>应用合并的对象雕刻</li></ol><h4 id="导出选项">导出选项</h4><p>导出选项对应的中文名称</p><ol><li>Partial Export——部分导出</li><li><strong>Mirror Mesh——镜面网格导出（那导入也要镜像）</strong></li><li>Ignore Nested Collections ——忽略嵌套集合</li><li>Ignore Hidden Objects——忽略隐藏的对象</li><li>Ignore Muted Shape Keys——忽略形态键</li><li>Apply All Modifiers——应用所有修改器</li></ol><h4 id="鼠标指针">鼠标指针</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Wuthering Waves Game\Client\Content\Aki\Cursor</span><br></pre></td></tr></table></figure><p>像素大小：48607296</p><h4 id="blender默认布局">blender默认布局</h4><p>在顶部“文件”选项中的“默认”选项中，找到“保存启动文件”按钮，点击即可保存当前布局</p><h3 id=""></h3><p>; 本文档由晨星制作<br>; 我的B站链接：<a href="https://space.bilibili.com/95747099">https://space.bilibili.com/95747099</a><br>; 我的Youtube：<a href="https://www.youtube.com/channel/UC9maLE-2mYDlZbDNWrX5dxA">https://www.youtube.com/channel/UC9maLE-2mYDlZbDNWrX5dxA</a><br>; 我的爱发电：<a href="https://afdian.com/a/MorningStar?tab=home">https://afdian.com/a/MorningStar?tab=home</a> （现在也没发啥，应该也没人支持吧(＠_＠;)）<br>; 我的香蕉网账号：<a href="https://gamebanana.com/members/2798606">https://gamebanana.com/members/2798606</a><br>; 非我的渠道下载 还收费的，那你就是被骗了！ 记得帮我点点举报（免费分享且标注链接的没有关系）<br>; 我的QQ群：1029406436（欢迎一起聊天吹牛逼，一起玩 ~）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;; 本文档由晨星制作&lt;br&gt;
; 我的B站链接：&lt;a href=&quot;https://space.bilibili.com/95747099&quot;&gt;https://space.bilibili.com/95747099&lt;/a&gt;&lt;br&gt;
; 我的Youtube：&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="鸣潮模组" scheme="https://stars-at-dawn.github.io/categories/%E9%B8%A3%E6%BD%AE%E6%A8%A1%E7%BB%84/"/>
    
    
    <category term="INI制作" scheme="https://stars-at-dawn.github.io/tags/INI%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>合并用到的贴图</title>
    <link href="https://stars-at-dawn.github.io/posts/85b738d1"/>
    <id>https://stars-at-dawn.github.io/posts/85b738d1</id>
    <published>2025-10-29T07:58:33.000Z</published>
    <updated>2025-10-29T07:59:12.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并用到的贴图"><strong>合并用到的贴图</strong></h3><p>在需要烘焙的模型上新建一个UV（名称需一样）</p><p>选中所有的需要烘焙的物体，再选中你新建的UV，然后在UV视图点击顶部的UV选项，选择重排孤岛，或者智能UV投射，别的都行，这步就是让UV不重叠，手动排都行</p><p>模型的材质中都需要新建一个纹理贴图（其中的图片就是最终输出的材质，所以必须都是同一张贴图）</p><p>然后右边选中渲染选项（小电视图标），选中Cycles模式，<br>采样选项卡中的渲染选项，将降噪关了，采样改成10（不改也没事，就是慢一点）；烘焙类型选择漫射（漫反射贴图，需要什么选什么），将直接光、间接光关闭（会渲染环境光，看你的需求）边距给8-32px（看你贴图的大小，8K的建议32，1K就8就行了）</p><p>最后烘焙之前一定要保证3D视图选中所有的模型，所有模型的材质视图选中新建的那个纹理节点，然后选中新建的UV，点击烘焙按钮等待一个个烘焙到那个贴图即可，然后保存贴图，使用新的UV和材质即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;合并用到的贴图&quot;&gt;&lt;strong&gt;合并用到的贴图&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在需要烘焙的模型上新建一个UV（名称需一样）&lt;/p&gt;
&lt;p&gt;选中所有的需要烘焙的物体，再选中你新建的UV，然后在UV视图点击顶部的UV选项，选择重排孤岛，或者智能UV投射，别的都行</summary>
      
    
    
    
    <category term="鸣潮模组" scheme="https://stars-at-dawn.github.io/categories/%E9%B8%A3%E6%BD%AE%E6%A8%A1%E7%BB%84/"/>
    
    
    <category term="blender" scheme="https://stars-at-dawn.github.io/tags/blender/"/>
    
  </entry>
  
  <entry>
    <title>标题</title>
    <link href="https://stars-at-dawn.github.io/posts/b5a0661a"/>
    <id>https://stars-at-dawn.github.io/posts/b5a0661a</id>
    <published>2025-10-27T09:15:29.000Z</published>
    <updated>2025-10-27T09:16:48.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RabbitFX-透明贴图"><strong>RabbitFX&amp;透明贴图</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;创建原始的光照贴图（<span class="variable constant_">RGB</span>控制颜色 A控制亮度）</span><br><span class="line">[<span class="title class_">ResourceLegEffectMap</span>]</span><br><span class="line">filename = <span class="title class_">Textures</span>/light.<span class="property">dds</span></span><br><span class="line"></span><br><span class="line">;创建原始的透明贴图(通过黑白控制，只有全透明和不透明)</span><br><span class="line">[<span class="title class_">ResourceTransparencyMask</span>]</span><br><span class="line">filename = <span class="title class_">Textures</span>/<span class="title class_">Transparency</span>.<span class="property">dds</span></span><br><span class="line"></span><br><span class="line">;找到你要发光的组件</span><br><span class="line">[<span class="title class_">TextureOverrideComponentX</span>]</span><br><span class="line">...</span><br><span class="line">        run = <span class="title class_">CommandListTriggerResourceOverrides</span></span><br><span class="line">        run = <span class="title class_">CommandListOverrideSharedResources</span></span><br><span class="line">        </span><br><span class="line">        ;主要添加的语句块（<span class="variable constant_">HSV</span>调色板，有兴趣可以看一下，很多调色软件也有这玩意）</span><br><span class="line">        $\rabbitfx\h = <span class="number">0</span></span><br><span class="line">        $\rabbitfx\s = <span class="number">0</span></span><br><span class="line">        $\rabbitfx\v = <span class="number">0</span></span><br><span class="line">        $\rabbitfx\brightness = <span class="number">10</span></span><br><span class="line">        $\rabbitfx\interpolate = <span class="number">1</span></span><br><span class="line">        <span class="title class_">Resource</span>\<span class="title class_">RabbitFX</span>\<span class="title class_">GlowMap</span> = ref <span class="title class_">ResourceLegEffectMap</span></span><br><span class="line">        ;这是透明效果的写法</span><br><span class="line">        ;<span class="title class_">Resource</span>\<span class="title class_">RabbitFX</span>\<span class="title class_">FXMap</span> = ref <span class="title class_">ResourceTransparencyMask</span></span><br><span class="line">        run = <span class="title class_">CommandList</span>\<span class="title class_">RabbitFX</span>\<span class="title class_">Run</span></span><br><span class="line">        ;------------------------------------------</span><br><span class="line"></span><br><span class="line">        ;加载模型</span><br><span class="line">        drawindexed = <span class="number">28770</span>, <span class="number">106563</span>, <span class="number">0</span></span><br><span class="line">        run = <span class="title class_">CommandListCleanupSharedResources</span></span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;RabbitFX-透明贴图&quot;&gt;&lt;strong&gt;RabbitFX&amp;amp;透明贴图&lt;/strong&gt;&lt;/h3&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="鸣潮模组" scheme="https://stars-at-dawn.github.io/categories/%E9%B8%A3%E6%BD%AE%E6%A8%A1%E7%BB%84/"/>
    
    
    <category term="INI制作" scheme="https://stars-at-dawn.github.io/tags/INI%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>显示文本</title>
    <link href="https://stars-at-dawn.github.io/posts/9aedfc2c"/>
    <id>https://stars-at-dawn.github.io/posts/9aedfc2c</id>
    <published>2025-10-27T09:14:02.000Z</published>
    <updated>2025-10-27T09:16:48.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="显示文本"><strong>显示文本</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; 打印文本（默认屏幕中央且为黑底白字）</span><br><span class="line">[<span class="title class_">CommandListPrintText</span>]</span><br><span class="line">; <span class="title class_">Input</span>:</span><br><span class="line">; <span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">Text</span></span><br><span class="line">; <span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">TextParams</span></span><br><span class="line">;</span><br><span class="line">; 使用示例</span><br><span class="line"><span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">Text</span> = ref <span class="title class_">ResourceTextExample</span></span><br><span class="line"><span class="title class_">Resource</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">TextParams</span> = ref <span class="title class_">ResourceTextParamsExample</span></span><br><span class="line">run = <span class="title class_">CommandList</span>\<span class="title class_">WWMIv1</span>\<span class="title class_">PrintText</span></span><br><span class="line"></span><br><span class="line">;文本内容</span><br><span class="line">[<span class="title class_">ResourceTextExample</span>]</span><br><span class="line">type = <span class="title class_">Buffer</span></span><br><span class="line">data = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">;文本格式</span><br><span class="line">[<span class="title class_">ResourceTextParamsExample</span>]</span><br><span class="line">type = <span class="title class_">StructuredBuffer</span></span><br><span class="line">array = <span class="number">1</span></span><br><span class="line">data = <span class="variable constant_">R32_FLOAT</span>  -<span class="number">0.25</span> +<span class="number">0.15</span> +<span class="number">0.25</span> -<span class="number">0.05</span>   <span class="number">1.00</span> <span class="number">1.00</span> <span class="number">1.00</span> <span class="number">1.00</span>   <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">0.95</span>   <span class="number">0.02</span>  <span class="number">0.05</span>   <span class="number">2</span> <span class="number">1</span>   <span class="number">1</span>   <span class="number">1.0</span></span><br><span class="line">;                x1-^  y1-^  x2-^  y2-^   | R-^  G-^  B-^  A-^  | R-^  G-^  B-^  A-^  | ^-H    V-^ | ^ ^ | ^- text <span class="attr">alignment</span>: <span class="number">0</span>=left <span class="number">1</span>=center <span class="number">2</span>=right | ^- font scale</span><br><span class="line">;                <span class="title class_">Rectangle</span> (range -<span class="number">1</span>:+<span class="number">1</span>)  | <span class="title class_">Text</span> <span class="title class_">Color</span>          | <span class="title class_">Background</span> <span class="title class_">Color</span>    | <span class="title class_">Border</span>     |  ^- h/v-<span class="attr">anchor</span>: <span class="number">0</span>=none <span class="number">1</span>=left/top <span class="number">2</span>=center <span class="number">3</span>=right/bottom </span><br><span class="line"></span><br><span class="line">;运行语句</span><br><span class="line">run = <span class="title class_">CommandListPrintText</span></span><br><span class="line"></span><br><span class="line">;代码案例来自文件： ..\<span class="variable constant_">XXMI</span> <span class="title class_">Launcher</span>\<span class="variable constant_">WWMI</span>\<span class="title class_">Core</span>\<span class="variable constant_">WWMI</span>\<span class="title class_">WuWa</span>-<span class="title class_">Model</span>-<span class="title class_">Importer</span>.<span class="property">ini</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;显示文本&quot;&gt;&lt;strong&gt;显示文本&lt;/strong&gt;&lt;/h3&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="鸣潮模组" scheme="https://stars-at-dawn.github.io/categories/%E9%B8%A3%E6%BD%AE%E6%A8%A1%E7%BB%84/"/>
    
    
    <category term="INI制作" scheme="https://stars-at-dawn.github.io/tags/INI%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Excel笔记</title>
    <link href="https://stars-at-dawn.github.io/posts/62925"/>
    <id>https://stars-at-dawn.github.io/posts/62925</id>
    <published>2025-07-23T02:57:14.000Z</published>
    <updated>2025-07-23T03:10:59.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Excel-批量填充单元格">Excel 批量填充单元格</h3><p>软件：Microsoft Office Excel</p><p>关于在Excel中进行批量填充单元格的操作</p><p>在Excel表格操作时，我们通常会遇到一列中许多连续数据需要填充，而这时直接填充会出现只能选择某一个数据填充所有。数据如下图所示</p><img src="C:\Users\R_F\AppData\Roaming\Typora\typora-user-images\image-20250723105813760.png" alt="image-20250723105813760" style="zoom:50%;" /><p>1.我们只需要选择第一列，通过快捷键Ctrl + H 将“-”替换成空值</p><p>2.选中第一列，使用快捷键Ctrl + G ，点击“定位条件”，选择“空值”，定位空值的单元格</p><p>3.点击上方的内容输入列，输入第一个空值单元格中的公式（“=上一个单元格”）（等会需要用来给后面的数据填充使用）。如图：</p><img src="C:\Users\R_F\AppData\Roaming\Typora\typora-user-images\image-20250723110943426.png" alt="image-20250723110943426" style="zoom:50%;" /><p>4.然后使用<strong>Ctrl + D</strong>快捷键 进行<strong>填充</strong>就完成填充数据（此时所有的空的单元格的数据会指向上一个单元格的内容）</p><p>5.（额外的）<strong>如果不想要公式</strong>，可以将这列的数据复制到别的行，然后在通过数值粘贴以达到纯数据的形式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Excel-批量填充单元格&quot;&gt;Excel 批量填充单元格&lt;/h3&gt;
&lt;p&gt;软件：Microsoft Office Excel&lt;/p&gt;
&lt;p&gt;关于在Excel中进行批量填充单元格的操作&lt;/p&gt;
&lt;p&gt;在Excel表格操作时，我们通常会遇到一列中许多连续数据需要填充，</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Excel" scheme="https://stars-at-dawn.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Excel 批量合成单元格</title>
    <link href="https://stars-at-dawn.github.io/posts/61000"/>
    <id>https://stars-at-dawn.github.io/posts/61000</id>
    <published>2025-07-21T01:32:57.000Z</published>
    <updated>2025-07-23T03:24:27.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="批量合并一列的相同单元格">批量合并一列的相同单元格</h3><p>软件：Microsoft Office Excel</p><p>关于在Excel中进行批量合并单元格的操作</p><p>在Excel表格操作时，我们通常会遇到许多数据连续一致，这时我们需要合并这些单元格，例如下面的表格我们需要合并人员相同的单元格，同时将工作单位一并合并。</p><img src="https://pic1.zhimg.com/80/v2-7c217aaf8acfd1a9c2287ac27b54652a_1440w.webp?source=d16d100b" style="zoom:50%;" /><ol><li>此时只需要选中人员列（不包括标题）</li><li>选择 <strong>“数据”–&gt;“分类汇总”</strong></li><li>得到如下图表<br><img src="https://picx.zhimg.com/80/v2-2173ba5d7904fb5a98352614c5fac203_1440w.webp?source=d16d100b" style="zoom:50%;" /></li><li>接着选中最左列，通过<strong>Ctrl + G快捷键</strong>，选择<strong>空值</strong>查找，如图所示：<img src="https://picx.zhimg.com/80/v2-81df44c302ef065d76db673714240739_1440w.webp?source=d16d100b" alt="image-20250721151656784" style="zoom: 33%;" /></li><li>筛选出对应的<strong>空值单元格</strong>（即要合并的列）</li><li>同时点击**“开始”–&gt;“合并后居中”**</li><li>再次选择最左列，此时再点击**“开始”–&gt;“格式刷”**，将格式刷到需要对应格式的列<img src="https://picx.zhimg.com/80/v2-e38c5b745fccd2fea6cbbab958889d37_1440w.webp?source=d16d100b" alt="image-20250721152043556" style="zoom:33%;" /></li><li>再次在最左列使用Ctrl + G快捷键，选择常量查找</li><li>此时右击选中的单元格，点击“删除”，选择整行，合并就算完成了，<strong>如有其它行需要，格式相同的可以使用格式刷</strong>，不同的则可以再次采用此方法。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;批量合并一列的相同单元格&quot;&gt;批量合并一列的相同单元格&lt;/h3&gt;
&lt;p&gt;软件：Microsoft Office Excel&lt;/p&gt;
&lt;p&gt;关于在Excel中进行批量合并单元格的操作&lt;/p&gt;
&lt;p&gt;在Excel表格操作时，我们通常会遇到许多数据连续一致，这时我们需要合</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Excel" scheme="https://stars-at-dawn.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>MySQL相关知识点</title>
    <link href="https://stars-at-dawn.github.io/posts/mysql"/>
    <id>https://stars-at-dawn.github.io/posts/mysql</id>
    <published>2025-06-07T01:57:17.000Z</published>
    <updated>2025-06-07T01:57:19.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL知识点">MySQL知识点</h2><p><strong><span id="MySQL">MySQL</span></strong></p><ul><li><strong>存储引擎</strong><ul><li><strong>InnoDB</strong>（ 默认引擎，<strong>支持外键；支持事务；支持在线热备份</strong>）</li><li><strong>MyISAM</strong>（<strong>不支持外键、事务和在线热备份；不支持行锁，只支持表锁；支持压缩表和空间数据索引</strong>）</li><li><strong>Memory</strong>（存在<strong>内存中</strong> 一但机器重启 数据会丢失）</li><li><strong>MERGE</strong>（用于一系列<strong>MyISAM表</strong>以逻辑方式<strong>组合</strong>在一起，作为一个对象去引用。（相当于union all））</li></ul></li><li><strong>事务的四大特性</strong><ul><li><strong>原子性</strong>：所有操作<strong>要么全部成功，要么全部回滚</strong></li><li><strong>一致性</strong>：事务<strong>执行前和执行后必须处于一致性状态</strong></li><li><strong>隔离性</strong>：并发访问数据时，多个<strong>事务互相不干扰</strong></li><li><strong>持久性</strong>：事务一旦提交，<strong>对数据库的更改就是永久</strong>的</li></ul></li><li><strong>事务会出现的问题</strong><ul><li><strong>脏读</strong>：指的是当前事务可以读取到另外事务未提交的数据。</li><li><strong>不可重复读</strong>：同一事务内多次读取同一数据集合，读取到的数据是不一样的情况。</li><li><strong>幻影读</strong>：同一事务连续执行两次同样的 sql 语句，第二次的 sql 语句可能会返回之前不存在的行（<strong>特殊的不可重复读问题</strong>）</li></ul></li><li><strong>四种事务隔离级别</strong><ul><li><strong>未提交读（READ UNCOMMITTED）</strong><ul><li>事务中的修改，即使没有提交，对其他事务也是可见的。</li><li>会出现如下问题：<strong>脏读不可重复读幻读</strong></li></ul></li><li><strong>提交读RC（READ COMMITTED）</strong><ul><li>一个事务所做的修改在提交之前对其他事务是不可见的。</li><li>会出现如下问题：<strong>不可重复读幻读</strong></li></ul></li><li><strong>可重复读RR（REPEATABLE READ）</strong><ul><li>保证在同一个事务中多次读取同样数据的结果是一样的。</li><li>会出现如下问题：<strong>幻读</strong></li></ul></li><li><strong>可串行化（SERIALIZABLE）</strong><ul><li>强制事务串行执行。</li><li>没有问题</li></ul></li></ul></li><li><strong>锁</strong><ul><li><strong>行锁 和 表锁</strong><ul><li><strong>行锁</strong><ul><li><strong>记录锁</strong> （锁定一个记录上的索引，而不是记录本身）</li><li><strong>间隙锁</strong>（锁定索引之间的间隙，但是不包含索引本身）</li><li><strong>临键锁</strong>（它是前两者的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙）</li></ul></li><li><strong>表锁</strong>（<strong>意向锁</strong>（意向共享锁 意向排他锁 共享意向排他锁））</li></ul></li><li><strong>排他锁 和 共享锁</strong><ul><li><strong>排他锁</strong>（其它事务想要读取或者写入一行数据，要等待事务释放锁）<strong>意向排他锁</strong>（获取多个排他锁）</li><li><strong>共享锁</strong>（其它事务只能并行读取一行数据）<strong>意向共享锁</strong>（读取多行数据）</li></ul></li></ul></li><li><strong>事务的实现</strong><ul><li><strong>MVCC</strong>（多版本并发控制）（用于实现<strong>提交读</strong>和<strong>可重复读</strong>这两种隔离级别）<ul><li><strong>相关概念</strong>：<ul><li><strong>版本号</strong>（<strong>系统版本号，事务版本号</strong>）：每有一个事务，系统版本号就会加1；事务版本号指当前事务的版本。</li><li><strong>隐藏的列</strong>：每行记录都有两个<strong>隐藏的列</strong> 存储 <strong>创建版本号</strong> 和 <strong>回滚指针</strong></li><li><strong>Undo 日志</strong>：<strong>快照存储在 Undo 日志中</strong>，通过<strong>回滚指针</strong>把一个数据行的所有快照连接起来</li></ul></li><li><strong>实现可重复读隔离级别</strong>（此时的事务版本号大于所有数据快照的创建版本号）<ul><li><strong>SELECT</strong>：必须读取<strong>小于等于当前事务版本</strong>的数据行快照。<br><strong>INSERT</strong>：将当前系统版本号作为数据行快照的创建版本号。<br><strong>DELETE</strong>：将当前系统版本号作为数据行快照的删除版本号。<br><strong>UPDATE</strong>：将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</li><li><strong>快照读</strong>（读取的是历史数据）：MVCC 的 <strong>SELECT</strong> 操作是<strong>快照中的数据</strong>（所以<strong>不用加锁</strong>）RC中每次都会生成快照</li><li><strong>当前读</strong>（读取的是数据库当前版本的数据）：<br>MVCC 对修改操作（<strong>INSERT、UPDATE、DELETE</strong>）<strong>加锁</strong>，读取<strong>最新的数据</strong>。</li><li><strong>SELECT 操作的不可重复读问题通过 MVCC 得到了解决</strong><br><strong>UPDATE、DELETE 的不可重复读问题通过 记录锁 解决</strong><br><strong>INSERT 的不可重复读问题是通过 临键锁（记录锁 + 间隙锁）解决的。</strong></li></ul></li></ul></li></ul></li><li><strong>索引</strong><ul><li><strong>数据结构</strong>：<strong>B+ Tree</strong>（Balance Tree <strong>平衡树</strong>也是一棵<strong>查找树</strong>，所有叶子节点位于同一层）<ul><li>B+树是B树的一种变形，它是基于B树和叶子节点顺序访问指针进行实现的</li><li><strong>B+非叶子节点不存储数据</strong>，只存储<strong>索引</strong>，<strong>数据都存在叶子节点</strong></li><li><strong>B树</strong>的实现特性：<strong>AVL树，红黑树，跳表</strong></li><li><strong>B+树</strong>能更好的<strong>支持范围查询</strong></li></ul></li><li>InnoDB 的 B+Tree 索引分为<strong>主索引</strong>和<strong>辅助索引</strong><ul><li><strong>主索引</strong>的叶子节点 data 域<strong>记录着完整的数据记录</strong>，这种索引方式被称为<strong>聚簇索引</strong>。</li><li><strong>辅助索引</strong>的叶子节点的 data 域<strong>记录着主键的值</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找，这个过程也被称作<strong>回表</strong>。</li></ul></li><li><strong>哈希索引</strong>：以 O(1) 时间进行查找，但是失去了有序性，无法用于排序、分组和范围查找。</li><li><strong>索引失效</strong>：<ul><li>在进行查询时，<strong>索引列不能是表达式的一部分</strong>，也<strong>不能是函数的参数</strong>，否则无法使用索引。</li></ul></li><li><strong>索引优化：</strong><ul><li><strong>让选择性（区分度）最强的索引列放在前面</strong>。</li><li><strong>前缀索引</strong>（对于 <strong>BLOB、TEXT 和 VARCHAR</strong> 类型的列，必须使用<strong>前缀索引</strong>，只<strong>索引开始的部分字符</strong>。）</li><li><strong>索引覆盖</strong>（索引<strong>包含所有</strong>需要查询的字段的值，则<strong>无需</strong>访问主索引（<strong>回表操作</strong>））</li><li><strong>尽量减少请求的数据量</strong>（只返回必要的列和行）</li><li><strong>将大查询分割</strong></li><li>查询<strong>模糊匹配优化</strong><ul><li><strong>索引下推（ICP）</strong>（只能<strong>用于二级索引</strong>）（核心思想是<strong>将部分过滤条件下推到存储引擎层</strong>）<br>允许 MySQL 在<strong>存储引擎层</strong>（如 InnoDB）直接<strong>利用索引来过滤数据</strong>，而<strong>不是</strong>将所有数据行<strong>全部返回到服务器层</strong>再进行过滤。<strong>减少</strong>从存储引擎到服务器层的<strong>数据传输量</strong>，从而提高查询效率。</li></ul></li><li><strong>最左匹配原则：</strong><br>最左匹配原则要求查询条件必须<strong>从复合索引的最左列开始匹配</strong>，才能有效利用索引</li></ul></li><li>索引<strong>不适合的场景</strong>：<ul><li><strong>数据量过少</strong></li><li><strong>表数据需要频繁的插入删除</strong></li><li><strong>字段区分度很低</strong></li></ul></li><li><strong>索引的优点</strong>：<ul><li>最重要的就是<strong>大大减少了要扫描的数据行</strong></li><li>同时<strong>避免服务器进行排序操作</strong>（索引本身是有序的）</li><li>将<strong>随机I/O</strong>读取变成<strong>顺序I/O</strong>读取（索引中的相邻数据会存储在一起）</li></ul></li></ul></li><li><strong>explain 分析 Select语句</strong></li><li><strong>分库分表数据切分</strong><ul><li><strong>水平切分</strong>：将同一个表中的记录<strong>拆分</strong>到多个<strong>结构相同</strong>的表中。</li><li><strong>垂直切分</strong>：将一张表按列分成多个表，通常是按照<strong>列的关系</strong>（或热度）密集程度进行<strong>切分</strong></li></ul></li><li><strong>主从复制</strong>：binlog 线程、I/O 线程和 SQL 线程。<ul><li><strong>binlog 线程</strong> ：负责将<strong>主服务器</strong>上的数据更改<strong>写入日志</strong>（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上<strong>读取日志</strong>，并<strong>写入从服务器</strong>的<strong>中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并<strong>在从服务器中重放（Replay）</strong>。</li></ul></li><li><strong>读写分离</strong>：<strong>主服务器</strong>处理<strong>写操作</strong>以及<strong>实时性要求比较高的读操作</strong>，而<strong>从服务器</strong>处理<strong>读操作</strong>。</li><li>一句SQL语句的执行过程<ul><li>首先客户端<strong>发送请求</strong>到服务端，<strong>建立连接</strong>。</li><li>服务端先看下<strong>查询缓存</strong>，对于更新某张表的SQL，该表的所有查询缓存都失效。（MySQL8.0取消）</li><li>接着来到<strong>解析器</strong>，进行<strong>语法分析</strong>，一些系统关键字校验，校验语法是否合规。</li><li>然后<strong>优化器</strong>进行<strong>SQL优化</strong>，比如怎么选择索引之类，然后生成执行计划。</li><li><strong>执行引擎去存储引擎查询需要更新的数据</strong>。</li><li>存储引擎判断当前缓冲池中是否存在需要更新的数据，存在就直接返回，否则去从磁盘加载数据。</li><li><strong>执行引擎调用存储引擎API去更新数据</strong>。</li><li>存储引擎<strong>更新数据</strong>，同时<strong>写入undo_log、redo_log信息</strong>。</li><li><strong>执行引擎写binlog</strong>，<strong>提交事务</strong>，流程<strong>结束</strong>。</li></ul></li><li>SQL优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL知识点&quot;&gt;MySQL知识点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&quot;MySQL&quot;&gt;MySQL&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储引擎&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;InnoDB</summary>
      
    
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/categories/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    <category term="MySQL" scheme="https://stars-at-dawn.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关知识点</title>
    <link href="https://stars-at-dawn.github.io/posts/spring"/>
    <id>https://stars-at-dawn.github.io/posts/spring</id>
    <published>2025-06-07T01:52:49.000Z</published>
    <updated>2025-06-07T01:55:42.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring知识点">Spring知识点</h2><ul><li><strong><span id="Spring源码">Spring框架</span></strong><ul><li><p><strong>依赖注入</strong>，<strong>控制反转</strong>的介绍</p><ul><li><strong>控制反转</strong>指的是一个<strong>过程</strong>，将<strong>原本对象自己控制的依赖关系变成外部容器来进行控制</strong>。</li><li><strong>依赖注入</strong>是它的<strong>实现方式</strong>，Spring容器通过构造函数或者setter方法将依赖关系注入到对象中</li></ul></li><li><p><strong>Bean</strong>的<strong>注入方式</strong></p><ul><li><strong>引导加载方式</strong>：通过<strong>Xml文件</strong>或者<strong>Java注解</strong>（@Bean注解）来实现</li><li><strong>自动配置</strong>：即<br><strong>①自动装配</strong>（声明<strong>setter方法</strong>，<strong>@Autowired</strong> 根据类进行匹配，多个则根据名字匹配（设置**@Qualifier<strong>注解可以指定Bean的名称）（设置</strong>required<strong>参数可以让其在找不到时</strong>不报错**），<strong>@Resouce JDK提供的</strong> 查找方式反一下）（在Bean上使用**@Primary<strong>注解可以设置多个匹配时的</strong>主类**。）<br><strong>②组件扫描</strong>（@ComponentScan注解 默认会在当前包路径下扫描）</li><li><strong>自动装配的过程</strong>：再<strong>创建上下文时进行注册Bean定义</strong>，在<strong>Bean的实例化时进行解析</strong>（根据注解类型来选择执行Bean的后置处理器进行解析）</li></ul></li><li><p><strong>Spring IoC容器加载的流程</strong></p><ul><li>注册容器时，会先<strong>注册启动配置类</strong>，然后调用<strong>refresh()<strong>方法</strong>启动容器</strong></li><li><strong>准备初始化</strong>，对其<strong>设置启动日期和状态标志以及初始化监听器容器</strong>等</li><li><strong>初始化Bean工厂</strong>，<strong>加载Bean定义</strong>，<strong>为其设置</strong>类加载器，添加后置处理器，注册系统环境等<strong>必要组件</strong></li><li><strong>postProcessBeanFactory()<strong>留给</strong>子类</strong>的钩子方法，用来<strong>对工厂后处理</strong>，<strong>然后实例化并调用</strong>所有的<strong>工厂后置处理器</strong>。<ul><li><strong>为什么先加载</strong>工厂后置处理器：因为<strong>Bean定义在IoC容器加载时会先进行注册</strong>，而工厂后置处理器要对加载完的Bean定义进行<strong>扩展</strong>用的，所以要先加载。（比如<strong>解析配置类</strong>的<strong>Bean工厂后置处理器</strong>）</li></ul></li><li><strong>国际化消息的相关支持方法</strong>（默认的消息器会将消息传给父类（如果有的话），本身无实际作用）</li><li>初始化Spring容器的<strong>事件广播器</strong>（以支持事件监听）（如果用户<strong>未定义</strong>自己的广播器，则会<strong>创建一个默认的</strong>）。</li><li><strong>onRefresh()<strong>留给子类的</strong>钩子方法</strong>，用以<strong>注册特殊的Bean</strong>等（<strong>如Spring Boot在此注册Servlet容器</strong>）</li><li>注册<strong>事件监听器</strong>，将它们<strong>加入到刚才的事件广播器中</strong>。</li><li><strong>实例化Bean</strong>。</li><li><strong>创建容器完成，发布最终事件。</strong></li></ul></li><li><p>容器加载过程的<strong>扩展点</strong>：postProcessBeanFactory方法，onRefresh()方法</p></li><li><p><strong>Spring启动过程相关的扩展点：</strong></p><ul><li><strong>钩子方法</strong></li><li><strong>Bean工厂加载</strong>过程：<strong>Bean工厂后置处理器，Bean定义后置处理器，环境后置处理器</strong></li><li><strong>ImportSelector接口</strong>返回一个类全限定名称的数组集合，Spring会根据这个数组解析Bean定义</li><li><strong>ImportBeanDefinitionRegistrar接口</strong>，提供Bean定义的注册器，由用户将Bean定义传入</li><li><strong>Bean的加载</strong>过程：<br><strong>① Aware接口</strong>（设置<strong>Bean名字，类加载器，Bean工厂</strong>的方法）。<br><strong>② Bean的后置处理器</strong>（<strong>Bean初始化的前后</strong>进行调用）。<br><strong>③ InitializingBean接口</strong>，在<strong>Bean初始化后</strong>调用。<br><strong>④ @PostConstruct注解</strong>，在<strong>Bean初始化后</strong>调用。<br><strong>⑤ 使用init-method声明了初始化方法</strong>，在<strong>Bean初始化后</strong>调用。<br><strong>⑥ DisposableBean接口</strong>，在<strong>Bean销毁后</strong>调用。<br><strong>⑦ @PreDestroy，在Bean销毁后调用</strong>。<br><strong>⑧ 使用destory-method 声明销毁方法</strong>，在Bean销毁后调用。<br><strong>⑨ FactoryBean</strong>接口：自定义Bean的创建逻辑。</li><li><strong>监听器扩展</strong>，监听Spring中发布的相关事件</li><li><strong>ApplicationRunner / CommandLineRunner接口</strong>，在<strong>上下文刷新后</strong>提供扩展点（Spring Boot）</li></ul></li><li><p><strong>Bean的加载过程</strong></p><ul><li>先判断<strong>Bean是否为单例模式</strong>或者实现了<strong>SmartFactoryBean接口</strong>（FactoryBean的扩展接口）</li><li>判断成功，会去<strong>一二级缓存中找</strong>，找到则返回，如果<strong>三级缓存</strong>中有值，则调用缓存中的工厂方法创建Bean<strong>返回</strong>，如果都没有，则继续执行。</li><li>执行<strong>Bean实例化</strong>后将Bean包装成一个工厂<strong>加入三级缓存</strong></li><li>根据Bean定义<strong>反射</strong>调用<strong>setter方法</strong>进行<strong>属性注入</strong>（此时会实例化别的Bean）<ul><li>如果又再次回到开头，则会调用三级缓存的工厂方法，返回实例化的对象</li></ul></li><li>相关属性注入完成，再次<strong>去一二缓存中找</strong>（没有三），防止重复创建动态代理</li><li>如果没有，则开始<strong>进行初始化流程</strong>，调用相关扩展接口<strong>加入到一级缓存</strong></li></ul></li><li><p><strong>三级缓存</strong>的作用<br><strong>一级缓存</strong>：保存<strong>创建好的Bean</strong><br><strong>二级缓存</strong>：存储已经<strong>实例化但尚未完成初始化的Bean</strong><br><strong>三级缓存</strong>：存储的是<strong>早期的对象工厂</strong></p><ul><li><strong>二级缓存行不行</strong>？<br><strong>Spring中的三级缓存是为了AOP服务的</strong>，如果实现AOP则从<strong>三级缓存</strong>中<strong>拿到</strong>的实例化对象是<strong>AOP代理对象</strong>，如果使用<strong>二级缓存</strong>，则需要在<strong>注入属性时直接注入代理类</strong>，这<strong>不符合Bean的生命周期</strong>，Bean的AOP创建应在<strong>初始化后调用AOP的后置处理器创建代理</strong>。</li><li><strong>多例Bean无法进行循环依赖</strong>：依赖循环没有出口，因为每次都会创建实例。</li><li><strong>构造函数无法进行循环依赖</strong>（Spring无法直接解决）：<br>构造器注入，会在通过构造函数实例化时就直接注入属性<br>此时可以加上**@Lazy注解**，让其注入时<strong>返回一个空对象</strong>，跳出依赖循环即可。</li><li><strong>Bean的并发创建</strong>：<strong>双重检查锁</strong><br><strong>在第一次查找缓存时，会对二三级缓存上锁</strong>（一级缓存不上锁，是为了<strong>减少性能影响</strong>），等线程创建完成对象<strong>加入一级缓存后</strong>，<strong>锁会被释放</strong>，同时唤醒后的线程因为找不到缓存（一级缓存已经找过了），则执行后面的逻辑，在依赖注入完成后，会<strong>再次上锁查找缓存</strong>（名字的由来），<strong>避免重复创建</strong>。</li></ul></li><li><p><strong>加载第三方的Bean：</strong></p><ul><li><strong>@Bean的方式来配置第三方类</strong><br><strong>@Import直接导入类的方式</strong></li></ul></li><li><p><strong>FactoryBean</strong>的作用以及原理</p><ul><li>它是一个接口，其中的<strong>getObject方法</strong>就是用来获取其产生的对象（且是<strong>懒加载</strong>的）</li></ul></li><li><p>Spring相关的重要注解</p><ul><li>常见注解的功能</li></ul></li><li><p><strong>Spring AOP</strong>（运行时增强）（常见的还有AspectJ AOP （编译时增强））</p><ul><li>实现方式：<strong>JDK（针对接口的实现类）<strong>和</strong>CGLib（生成子类去重写）</strong><br>在<strong>配置类中通过注解开启AOP支持</strong>（可以在此处<strong>设置在线程中暴露代理对象</strong>参数，这样就可以<strong>通过AOP的上下文拿到</strong>当前增强的对象，防止出现本<strong>类方法互相调用时AOP失效</strong>问题。）</li><li>具体使用<br><strong>①基于接口的配置。</strong><br><strong>②@AspectJ注解配置。</strong><br>③AspectJ直接实现。</li><li><strong>实现原理</strong>：基于<strong>动态代理</strong>，代理类会封装目标类，并<strong>拦截</strong>被通知的方法的调用，<strong>执行切面</strong>逻辑，再将调用<strong>转发给目标类</strong>。采用责任链的设计模式。<br>当配置类<strong>设置AOP启动参数</strong>，会<strong>注入一个AOP的Bean后置处理器</strong>，在<strong>初始化前会解析切面注解</strong>并缓存，<strong>初始化后</strong>会拿到之前的缓存，<strong>判断</strong>是否被切点命中，<strong>创建代理</strong>。</li><li>失效的原因：<br><strong>–类内部调用方法</strong>失效（<strong>设置线程暴露参数</strong>，或者直接<strong>注入本类，然后调用</strong>）<br>–方法是<strong>private或者static</strong>（无法继承，实际上<strong>除了public都不行</strong>）<br>–目标类没有配置为Bean</li></ul></li><li><p><strong>事务</strong></p><ul><li><strong>四大特性：</strong><br><strong>原子性</strong>：所有操作<strong>要么全部成功，要么全部回滚</strong><br><strong>一致性</strong>：事务<strong>执行前和执行后必须处于一致性状态</strong><br><strong>隔离性</strong>：并发访问数据时，多个<strong>事务互相不干扰</strong><br><strong>持久性</strong>：事务一旦提交，<strong>对数据库的更改就是永久</strong>的</li><li><strong>实现方式</strong>（<strong>编程式事务管理</strong>（编程的方式，灵活但难维护）和<strong>声明式事务管理</strong>（注解或xml配置，清晰方便））<ul><li><strong>传播行为</strong><br>事务的传播行为指的是<strong>当一个事务方法调用另一个事务方法</strong>时，这个事务应该如何运行。<br>通过设置注解中的<strong>propagation</strong>参数，常见有三种：<br><strong>默认的</strong>：<strong>无事务</strong>调用时会<strong>开启新事务</strong>，<strong>有事务</strong>调用时会<strong>融合</strong>外部事务（适合<strong>增删改</strong>）<br><strong>SUPPORTS</strong>：<strong>无事务</strong>调用<strong>不开启</strong>事务，<strong>有事务</strong>调用时会<strong>融合</strong>外部事务（适合<strong>查询</strong>）<br><strong>REQUIRES_NEW</strong>：<strong>无事务</strong>调用和<strong>有事务</strong>调用都会<strong>开启新事务</strong>（<strong>日志</strong>等）</li><li><strong>隔离级别</strong><br>依赖数据库的<strong>事务隔离级别</strong>，通过注解中的<strong>isolation参数</strong>设置（）<br><strong>脏读（RC）</strong><br><strong>不可重复读（RR）</strong><br><strong>幻影读（SERIALIZABLE）</strong></li></ul></li><li><strong>实现原理</strong>（针对声明式事务管理）<br>基于<strong>AOP</strong>实现的（要在<strong>配置类</strong>中通过<strong>注解开启事务注解支持</strong>）<br>会为此类创建一个<strong>代理</strong>，调用会加上<strong>try-catch语句块</strong><br><strong>Spring事务信息存放在ThreadLocal中</strong>，所以一个线程只能有一个事务<ul><li><strong>try：</strong></li><li><strong>判断ThreadLocal</strong>是否有<strong>数据库连接</strong>，如果<strong>有</strong>，说明现在是<strong>内嵌事务</strong>，执行下面语句：<ul><li>如果是<strong>融入</strong>行为：不会重新创建新事务，将<strong>新事务的标志字段改为false</strong></li><li>如果是<strong>创建</strong>行为：会将<strong>事务状态信息暂存后清空</strong>，重写<strong>创建</strong>一个事务</li></ul></li><li>否则<strong>正常创建数据库连接</strong>，并且<strong>修改自动提交为false</strong>，<strong>执行</strong>目标方法</li><li><strong>catch：<strong>出现异常，需要回滚就会</strong>回滚</strong>，否则正常提交</li><li>无异常执行完成，<strong>当新事务标志字段为true</strong>则<strong>提交</strong>事务，<strong>否则恢复被清理的旧事务</strong>。</li></ul></li></ul></li><li><p><strong>事件监听</strong>机制（<strong>观察者设计模式</strong>）</p><ul><li>实现原理：底层通过<strong>事件广播器</strong>来发布事件，可以<strong>自定义事件监听器</strong>，Spring容器会帮我们自动加入进去。</li></ul></li></ul></li></ul><h2 id="Spring-Boot">Spring Boot</h2><ul><li><strong>Spring Boot框架</strong><ul><li>与Spring的主要区别<ul><li><strong>两者关系</strong>：Spring Boot不像Spring，不是一个框架，它<strong>是一个可以快速构建Spring脚手架工具</strong>，为其开发提供便利</li><li>核心注解：<br><strong>@SpringBootApplication</strong>（其为复合注解，还包括**@EnableAutoConfiguration @SpringBootConfiguration**）</li><li><strong>内嵌Servlet容器</strong></li></ul></li><li><strong>Spring Boot的启动流程</strong><ul><li>运行<strong>main方法</strong>，<strong>初始化SpringApplication</strong>（发布事件）</li><li>运行<strong>run方法</strong>，内部会读取环境变量，打印Banner，设置一些参数等（发布事件）</li><li><strong>创建</strong>SpringApplication上下文与<strong>初始化</strong>上下文，<strong>将启动类作为配置类注册</strong></li><li>调用<strong>refresh方法加载IoC容器</strong>（发布事件）<ul><li>解析**@Import加载的所有自动配置类**<br>（<strong>自动配置类</strong>：<strong>目的就是为我们做第三方库的自动配置</strong>）</li><li><strong>onRefresh</strong>方法中会<strong>创建servlet容器</strong></li></ul></li><li><strong>执行扩展接口</strong>（<strong>ApplicationRunner</strong>和<strong>CommandLineRunner</strong>接口）（发布事件）</li><li>执行<strong>异常也会发布事件</strong></li><li>大量利用<strong>监听器</strong>进行<strong>扩展</strong>（监听事件的发布）</li></ul></li><li><strong>自动配置加载的原理：</strong><ul><li>通过**@SpringBootConfiguration<strong>映入了</strong>@EnableAutoConfiguration**注解</li><li>其中使用**@Import<strong>导入了一个</strong>deferredImportSelcetor**</li><li>加载IoC容器时会<strong>解析@Import</strong>注解</li><li>会<strong>读取所有jar包META-INF/spring.factories文件</strong>（SPI），过滤出<strong>所有AutoConfigurationClass类型的类</strong></li><li>通过**@Condition排除无效的自动配置类**</li></ul></li><li><strong>内嵌Servlet容器启动原理</strong>（默认<strong>Tomcat</strong>）<ul><li>当<strong>引用了web的场景启动器</strong>，就会导入<strong>容器启动的自动配置类</strong>，会导入一个Web容器工厂，在OnRefresh方法创建容器</li><li>Jar包能直接运行的原因<ul><li>Spring Boot提供了一个maven插件，此时打包会将依赖的jar包和Spring Boot相关的类一起打包。<br>同时启动时会分别加载依赖的jar包和启动Main函数。</li></ul></li><li><strong>Servlet</strong>相关概念<ul><li><strong>三大组件</strong>：<br><strong>Servlet</strong>：处理客户端请求的核心组件<br><strong>Listener</strong>：用于监听 Web 应用程序中各种事件的组件<br><strong>Filter</strong>：用于在请求到达 Servlet 之前或响应返回客户端之前对请求和响应进行处理的组件</li><li><strong>Spring Boot</strong>可以在<strong>配置类</strong>中的注册 <strong>注册器Bean</strong>，并在其中<strong>注册相关组件</strong></li></ul></li></ul></li><li><strong><span id="日志框架">日志框架和门面</span></strong><ul><li>日志实现的方式有非常多，为了<strong>统一各个日志框架与日志门面</strong>，出现了<strong>适配器</strong>（让<strong>不同日志门面统一实现SLF4J门面</strong>）和<strong>桥接器</strong>（让<strong>不同日志框架实现SLF4J门面</strong>），只需要加入不同的适配器和桥接器就可以实现日志的整合。</li></ul></li><li><strong>Spring MVC测试方法</strong><ul><li><strong>MockMvc</strong>：<ul><li>不需要启动Web应用，可以<strong>对http请求进行模拟</strong>，同时<strong>提供一套验证工具</strong>，在测试类<strong>注入MockMvc对象</strong>，测试类加上**@AutoConfigureMockMvc**即可使用。</li></ul></li><li><strong>RestTemplate</strong><ul><li>主要适用微服务远程调用（本地也行），在普通类中的构造函数可以通过builder构造一个<br>测试类通过TestRestTemplate直接new一个。（使用完整的远程调用请求路径，以及需要使用无参构造函数）</li></ul></li><li>PostMan/<strong>ApiPost</strong>工具</li><li><strong>Swagger</strong> API测试文档</li></ul></li></ul></li></ul><h2 id="SSM">SSM</h2><ul><li><strong>SSM框架</strong><ul><li><strong>Spring MVC</strong><ul><li><strong>工作流程：</strong><ul><li><strong>客户端</strong>向服务器<strong>发送一个HTTP请求</strong></li><li><strong>前端控制器</strong>（<strong>DispatcherServlet</strong>）接收请求</li><li><strong>根据</strong>请求的URL和其他<strong>信息</strong>，通过<strong>HandlerMapping</strong>确定请求应该由哪个**处理器（Controller）**来处理</li><li><strong>确定处理器后</strong>，<strong>DispatcherServlet</strong>会通过<strong>HandlerAdapter</strong>来<strong>调用处理器</strong>。</li><li><strong>处理器（Controller）<strong>具体的</strong>业务逻辑实现类</strong>，它接收请求参数，执行业务逻辑，并返回一个<strong>ModelAndView</strong>对象。</li><li>返回ModelAndView对象后，<strong>DispatcherServlet</strong>会通过**视图解析器（ViewResolver）**解析视图名称，去找到对应视图。</li><li>找到视图资源后，<strong>DispatcherServlet</strong> 会<strong>将模型数据传递给视图</strong>，并进行<strong>渲染</strong>。</li><li>最后，<strong>DispatcherServlet</strong> 将生成的响应内容<strong>发送回客户端</strong>，客户端（如浏览器）会<strong>显示响应内容</strong>。</li></ul></li><li><strong>HandlerInterceptor</strong>：用于<strong>拦截处理请求</strong>，可以在请求处理前、处理中和处理后执行特定逻辑。</li><li><strong>ControllerAdvice</strong>：用于<strong>全局处理控制器的异常、数据绑定和数据校验</strong>。</li></ul></li><li><strong>Spring</strong> <a href="#Spring%E6%BA%90%E7%A0%81">详细戳这</a></li><li><strong>Mybatis</strong></li><li><strong>三层架构</strong><ul><li><strong>表示层</strong></li><li><strong>业务逻辑层</strong></li><li><strong>数据访问层</strong></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring知识点&quot;&gt;Spring知识点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&quot;Spring源码&quot;&gt;Spring框架&lt;/span&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;，&lt;strong&gt;控</summary>
      
    
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/categories/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    <category term="Spring" scheme="https://stars-at-dawn.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM相关知识点</title>
    <link href="https://stars-at-dawn.github.io/posts/jvm"/>
    <id>https://stars-at-dawn.github.io/posts/jvm</id>
    <published>2025-05-18T06:07:47.000Z</published>
    <updated>2025-06-07T01:52:17.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM相关知识点">JVM相关知识点</h2><ul><li>JVM<ul><li><strong>自动内存管理子系统</strong><ul><li><strong>运行时数据区：</strong><ul><li><strong>方法区</strong>（<u>线程共享的</u>）<ul><li>主要存储对象的<strong>元数据信息</strong>（类名，字段信息，方法信息，父类信息等）和<strong>运行时常量池</strong>（字符串（JDK1.7以前是存放的对象，后面改成了存放引用，对象放到堆内存中了）/数值/布尔字面量，符号引用（类全限定名，字段的描述信息，方法的描述信息））</li><li>实现方式<ul><li>JDK1.8以前实现方式是<strong>永久代</strong>（主要为了<strong>适配堆的分代结构</strong>方便垃圾回收器一起管理）</li><li>JDK1.8后采用<strong>元空间</strong>实现（使用<strong>本地内存</strong>来存储，与堆内存分离，内存大小可以动态扩展，大大<strong>减少了内存溢出的风险</strong>）</li></ul></li></ul></li><li><strong>堆</strong>（<u>线程共享的</u>）<ul><li><p><strong>对象的创建过程</strong></p></li><li><p>当JVM遇到一条new语句时，会先去找常量池找到此类的符号引用，并检查它是否已加载，否则执行<strong>类加载过程</strong>，通过后，JVM会为新对象在堆中<strong>分配固定内存</strong>（其大小在类加载完成后便以确定），同时<strong>初始化零值</strong>（对象头除外），接着<strong>设置对象头</strong>（锁状态信息，GC分代年龄，类型指针（指向它的类型元数据的指针）等，如果是数组则还要记录它的长度），在JVM看来此时对象已经真正创建完成；接着将会<strong>执行<init>方法</strong>才按照我们的意愿操作</p></li><li><p><strong>对象的存储布局</strong></p><ul><li>主要由三部分组成：<strong>对象头</strong>（Mark Word（存放对象自身运行时的数据），类型指针（指向它的类型元数据的指针）），<strong>实例数据</strong>（真正有效的信息，自己定义的各种类型字段内容），<strong>对齐填充</strong>（无意义，只是由于HotSpot虚拟机的要求对象的起始地址必须时8字节的整数倍）</li></ul></li><li><p><strong>垃圾回收器</strong></p><ul><li><p><strong>如何判断垃圾</strong>（哪些内存需要回收）</p><ul><li>“垃圾”指的就是那些不可能被使用的对象</li></ul></li><li><p><strong>判断</strong>是否是<strong>垃圾</strong>主要有两种<strong>算法</strong>，分别是</p><ul><li><strong>引用计数算法</strong><ul><li>在对象中添加一个引用计数器，当有引用指向它就+1，只要计数器为0就说明此对象是垃圾，但单纯的此算法无法解决诸如循环引用等问题</li></ul></li><li><strong>可达性分析算法</strong><ul><li>这个算法的核心就是根节点（GC Roots 如在栈帧引用的对象，类静态属性引用的对象，常量引用的对象（字符串等）等），只要通过根节点找不到这个对象，则表示此对象为垃圾。</li><li>finalize()方法（已被官方废弃），在它们被回收时，如果有必要执行此方法（此方法只会执行一次），则会放到一个队列另起一个线程执行，然后再次对此队列进行再次扫描。</li></ul></li><li><strong>Java中的四种引用类型</strong><ul><li><strong>强引用</strong>（传统的引用，不会被回收）、<strong>软引用</strong>（SoftReference 当要发生内存溢出时会尝试二次GC回收这些对象）、<strong>弱引用</strong>（WeakReference下次GC就会直接回收）、<strong>虚引用</strong>（PhantomReference此引用不起实际的作用，不会对对象的生命周期产生影响，其指向的对象回收后会将虚引用加入到指定的队列，可以得到通知）</li></ul></li></ul></li><li><p><strong>垃圾回收算法</strong>（追踪式的）</p><ul><li>首先这个算法基于<strong>分代收集理论</strong>（说是理论实则是统计学的经验法则）即：<ul><li>①大部分对象都是朝生暮死</li><li>②熬过越多次GC的对象就越难消亡</li></ul></li><li>所以Java将堆分成了几个不同的区域：<strong>新生代和老年代</strong><ul><li>我们将会对不同的区域进行垃圾回收；但同时对象不是孤立的，会存在跨代引用，但这只是占极少数，因此我们在新生代上建立一个<strong>数据结构</strong>（<strong>记忆集</strong>）来标识哪些老年代内存需要一起GC</li></ul></li><li>针对这些区域和特点做了相匹配的算法，也就是下面：</li><li><strong>标记-清除算法</strong><ul><li>最基础的版本，分为两个步骤**“标记”“清除”<strong>，首先标记要回收的对象，然后统一回收掉所有被标记的对象。它的</strong>执行效率不稳定**，因为大量对象都需要回收，标记和清除的动作会导致效率很低，同时<strong>产生大量的内存碎片</strong></li><li><strong>标记-复制算法</strong><ul><li>可以解决这两个问题（<strong>适合新生代GC使用</strong>）（<strong>复制过程可以采用并发来加速提高效率</strong>）最早提出的是半区复制，即GC时，将一半空间中存活的对象复制到另一半空间里，不过这会产生大量的<strong>空间浪费</strong>（新生代存活的对象一般不足十分之一），所以就将新生代分为了<strong>Eden区和Survivor区</strong></li><li>新生代：一个较大的Eden区和两个较小的Survivor区（另一个用来存放复制存活的对象），它们默认的大小比例为8：1：1（大大<strong>减少了空间的浪费</strong>）</li></ul></li><li><strong>标记-整理算法</strong><ul><li>标记-复制算法对老年代的存活对象较多的场景不适用（复制的操作过多，且存活对象过多），于是在“标记”后，将<strong>存活的对象向内侧空间移动，然后直接清理掉边界外的内存</strong>（<strong>适用老年代</strong>）</li><li><strong>移动操作</strong>是一项极为负重的操作，因为移动对象必须全程暂停用户线程才能进行，而这种停顿也被我们戏称为**“Stop The World”**（STW）</li></ul></li></ul></li></ul></li><li><p><strong>HotSpot内部的算法实现细节</strong></p><ul><li>GCRoot的相关细节<ul><li><strong>GC Roots枚举</strong><ul><li>要实现找到垃圾的可达性分析，最终要的就是GC Roots的寻找，由于在此时会STW（要做到准确收集），但HotSpot虚拟机会使用一个Map（<strong>OopMap</strong>），会将对象的偏移量计算后写入，来加速扫描过程。</li></ul></li><li><strong>安全点</strong><ul><li>在每个方法都生成OopMaps（记录信息）是不现实的，所以设置了安全点的概念，只在这生成，同时这里会执行全局操作（GC、类卸载等），要确保状态的可预知性，同时不能安全点设置不能太多也不能太少（会设置在方法调用，循环，异常等指令跳转的地方），线程会通过轮询一个标志位判断是否需要中断（或是虚拟机强制中断线程）</li></ul></li><li><strong>记忆集</strong><ul><li>上面讲到为了<strong>解决跨代之间的对象引用</strong>而建立的数据结构（记录的粒度可以是字长，对象，或者“卡”（一个内存区域，卡表独有））</li><li><strong>卡表</strong>作为记忆集的一种实现方式（<strong>一个字节数字</strong>），它以“卡页”作为精度，一个卡页会包含多个对象，如果其中有一个对象的字段存在跨代引用，则表明这个元素<strong>变脏</strong>，其通过<strong>写屏障技术</strong>维护卡表状态（会为所有赋值操作生成相应指令，相当于虚拟机层面的AOP）</li></ul></li></ul></li><li><strong>并发判断是否是垃圾（并发的可达性分析）</strong><ul><li>在此需要引入<strong>三色标记</strong>来帮助理解为什么并发判断垃圾会出现问题</li><li><strong>三色标记</strong>（<strong>白色：未标记，黑色：标记完成的存活对象，灰色：其指向的对象没有标记完</strong>）</li><li>并发标记会出现如下两个问题（<strong>漏标和多标</strong>）<ul><li>当插入一条黑色到白色的引用同时删除所有灰色到此白色的引用，那么白色引用将无法被找到<ul><li>这会直接影响到程序的运行，是不可容忍的</li><li>为了解决这个问题提出了<strong>增量更新</strong>和<strong>原始快照</strong>两种解决方案</li><li><strong>前者是让黑色对象插入白色引用时变为灰色对象。</strong></li><li><strong>后者是在灰色对象删除白色引用时将白色对象变为灰色，重新扫描。</strong></li></ul></li><li>当删除一条黑色到灰色的引用，虚拟机会无法感知，可能出现内存泄漏（浮动垃圾）<ul><li>只需要等到下次GC清理就行</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>不同的GC的特点和使用场景</strong></p><ul><li>经典的GC的组合：<ul><li><strong>Serial + Serial Old</strong>（简单高效，小型机器使用）<ul><li>都是<strong>单线程</strong>垃圾回收器，<strong>全程都需要STW</strong>，<strong>Serial</strong>采用<strong>标记-复制算法</strong>（Eden和Survivor）负责新生代进行回收，<strong>Serial Old</strong>则采用<strong>标记-整理算法</strong>负责老年代GC</li></ul></li><li><strong>ParNew（JDK 7前首选的新生代收集器） + CMS</strong><ul><li><strong>ParNew</strong> 实际上就是<strong>Serial</strong>的<strong>多线程版本</strong>，使用多条线程并行处理垃圾，其它与Serial并无差异</li><li><strong>CMS</strong>负责<strong>老年代</strong>GC，它第一次实现了<strong>并发的垃圾收集</strong>，从名字就可以看出（Concurrent Mark Sweep）它是基于<strong>标记-清除</strong>算法实现，它的执行包含四个步骤</li><li><strong>GC过程：①初始标记。②并发标记。③重新标记。④并发清除</strong>（<strong>①和③仍然需要STW</strong>）</li><li>①只是<strong>标记GC Roots</strong>能直接关联的对象。②是<strong>遍历</strong>整个对象图标记垃圾的过程。<br>③则是<strong>增量更新</strong>的过程。④是<strong>清除</strong>垃圾的过程（不需要移动对象，所以可以并发）</li><li>CMS存在需多问题，最严重的是它<strong>不能处理浮动垃圾和空间碎片</strong>，GC失败后会调用Serial Old</li></ul></li><li><strong>PS</strong>（Parallel Scavenge） + <strong>PO</strong>（Parallel Old）<ul><li>PS是基于<strong>标记-复制算法</strong>的<strong>并发</strong>收集的<strong>新生代GC</strong>，它的主要特点是关注点不同，它关注<strong>吞吐量</strong>（处理器用于业务代码的时间占比）的大小，<strong><u>适合需要后台运行不需要太多交互的应用</u></strong>，它的<strong>标记阶段是并行的</strong>，在清<strong>理垃圾时是STW的</strong>，因为需要移动对象</li><li>PO是PS<strong>老年代</strong>的版本是基于<strong>标记-整理算法</strong>实现的</li></ul></li><li><strong>G1</strong>（Garbage First） （<strong>JDK 9开始是服务端模式下的推荐方案</strong>了，之前是PS + PO）<ul><li>G1是一个<strong>面向全堆的收集器</strong>，它从<strong>整体上</strong>看是<strong>标记-整理算法</strong>实现，从<strong>局部</strong>（两个Region）上看又是基于<strong>标记-复制算法</strong>实现。它第一次提出了基于<strong>Region</strong>的<strong>内存布局</strong>形式。但是G1没有抛弃分代的理念，<strong>每个Region</strong>都可以<strong>根据需要扮演对应的区域</strong>。</li><li>G1的垃圾回收可以<strong>针对任意区域</strong>（一个<strong>回收集</strong>，称为CSet）进行回收，而不是只局限与整个年龄代，根据<strong>回收的收益</strong>来进行回收，这就是它的<strong>Mixed GC模式</strong>，同时可以<strong>做到可控的GC停顿时间</strong>（用户可以通过参数指定）（衰减平均值的概念）</li><li><strong>维护跨Region的引用对象会变得非常复杂</strong>，需要耗费过多的内存来维护，成为额外负担</li><li><strong>GC过程：①初始标记。②并发标记。③最终标记。④筛选回收</strong>（<strong>①和③和④仍然需要STW</strong>）</li><li>①<strong>标记GC Roots</strong>②如果用户<strong>新创建对象</strong>则会在Region中设置<strong>两个指针标记</strong>，加入其中会默认其是<strong>存活</strong>的③是<strong>原始快照</strong>过程。④负责统计Region的回收价值<strong>制定回收计划</strong>，最后把存活的对象<strong>复制</strong>到空的Region中再清理掉旧的Region（此时需要<strong>STW</strong>再多线程执行移动对象）</li></ul></li></ul></li><li>高性能GC：<ul><li><strong>Shenandoah</strong>（非官方的GC）<ul><li><strong>G1的继承者</strong>，不同的是它<strong>支持并发的整理算法</strong>，其次它<strong>抛弃了分代设计</strong>，此外将<strong>记忆集</strong>的实现方式改成了<strong>连接矩阵</strong>的<strong>全局</strong>数据结构。</li><li>**GC过程：**①初始标记。②并发标记。③最终标记。④并发清理。⑤并发回收。<br><strong>⑥初始引用更新。⑦并发引用更新。⑧最终引用更新。⑨并发清理</strong>（<strong>①③⑥⑧需要STW</strong>）</li><li><strong>①②③与G1基本一样</strong>，<strong>④</strong>会<strong>清理没有存活对象的Region</strong>。<strong>⑤</strong>先将存活对象<strong>复制</strong>到一个没有用过的Region中。<strong>⑥</strong>确定一个执行点，<strong>确保⑤已经执行完成</strong>，此时会STW。<strong>⑦</strong>将堆中的所有指向旧对象的指针<strong>指向新地址</strong>。<strong>⑧</strong>修改<strong>GC Root</strong>的引用，此时会STW。<strong>⑨</strong>再次<strong>调用④过程</strong>。、</li><li><strong>并发移动</strong>时，采用<strong>转发指针</strong>来防止访问旧对象（在对象中加入一个新的引用字段，默认指向自己，而在移动后，指向新地址）</li></ul></li><li><strong>ZGC</strong>（它的设计注定它能承受的对象分配速率不会太高）<ul><li>是一款<strong>基于Region内存布局</strong>的，不采用分代设计的GC。其使用<strong>读屏障，染色指针和内存多映射</strong>等技术实现<strong>并发</strong>的<strong>标记-整理算法</strong></li><li>与G1和Shenandoah不同，它的Region具有动态性，分小、中、大三类，对应不同大小的对象</li><li><strong>染色指针</strong>是它的标志（Linux中通过<strong>多重映射</strong>的方式来<strong>支持</strong>），即将<strong>一部分信息存在指针</strong>上（4位，三色标记状态，是否移动等），所以这会导致ZGC可以管理的内存大小不能超过4TB（2^42），同时它也不能支持<strong>指针压缩</strong>（将64位的指针压缩成32位，减少内存消耗），它可以<strong>使Region被移走后直接释放</strong></li><li><strong>GC过程：①并发标记。②并发预备重分配。③并发重分配。④并发重映射。</strong></li><li><strong>①</strong>与G1和Shenandoah一样的<strong>标记过程</strong>。<strong>②</strong>去<strong>扫描</strong>所有的Region（<strong>省去了记忆集</strong>的开销），确定<strong>回收</strong>的Region<strong>的集合</strong>。<strong>③复制</strong>存活对象到新的Region中，并为老Region维护一个<strong>转发表</strong>，当有引用通过转发表进行访问时，会<strong>重新更新它的引用</strong>，减少后续的开销（<strong>指针自愈</strong>）<strong>④</strong>修正整个堆的<strong>旧引用</strong>，与<strong>Shenandoah的⑦</strong>基本一样，不过ZGC会<strong>在并发标记时一起执行</strong>（自愈）</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><strong>栈</strong>（<u>线程私有的</u>）<ul><li><strong>本地方法栈</strong></li><li><strong>虚拟机栈</strong><ul><li><strong>栈帧</strong>（<a href="#%E6%A0%88%E5%B8%A7">详见此处</a>）</li></ul></li></ul></li></ul></li></ul></li><li><strong>执行子系统：</strong><ul><li><strong>Class文件</strong>的结构<ul><li>开头就是魔术与Class文件的版本号，接着就是Class文件的常量池</li></ul></li><li><strong>类加载机制</strong><ul><li><p><strong>执行时机</strong></p><ul><li><strong>①使用new关键词实例化对象时</strong>。<br><strong>②读取或设置类的静态字段时（final修饰，已在编译器放入常量池的静态字段除外）</strong>。<br><strong>③调用一个类的静态方法时</strong>。</li></ul></li><li><p><strong>类的生命周期</strong></p><ul><li><strong>加载、<u>验证、准备、解析（三个步骤被称为连接）</u></strong><br><strong>初始化、使用、卸载</strong></li></ul></li><li><p><strong>类加载过程</strong></p><ul><li><strong>加载阶段：</strong><br><strong>①通过类的全限定名获取字节流</strong>（如果数组的组件类型是引用类型，将会递归执行此过程）<br><strong>②将静态结构转化为方法区的数据结构</strong><br><strong>③在堆中生成一个Class对象（JDK1.8后移动到堆中，逻辑上属于方法区），作为访问入口</strong><ul><li><strong>类加载器</strong><ul><li>加载阶段是可控性最强的阶段，可以重写类加载器的<strong>findClass或者loadClass方法</strong>来修改<strong>获取字节流的方式</strong>，实现自定义获取程序代码。</li><li><strong>双亲委派模型</strong>（指各个类加载器之间的层次关系）<ul><li>除了启动类加载器，其余类加载器都应有自己的父类加载器</li></ul></li><li><strong>双亲委派机制</strong><ul><li>一个类加载器收到类加载请求，它会先委派父类加载器加载，每个加载器都如此，当父类加载器无法加载时，子类加载器才会尝试加载。</li><li>能够避免类的重复加载，同时确保核心类都由虚拟机自行加载，增加了安全性</li></ul></li><li><strong>破坏双亲委派机制</strong><ul><li><strong>重写loadClass方法</strong></li></ul></li></ul></li></ul></li><li><strong>连接（验证，准备，解析）阶段</strong><ul><li><strong>验证</strong>阶段：<strong>确保Class文件的内容符合规范约束</strong>（如果确认了，则此步骤可以通过参数关闭加速启动时间）<br><strong>准备</strong>阶段：正式<strong>为类中定义的变量（即静态变量）分配内存并设置零值</strong>。<br><strong>解析</strong>阶段：是将Class文件的常量池内的<strong>符号引用替换为直接引用</strong>。（此处可能会触发别的类加载）</li></ul></li><li><strong>初始化阶段（类加载过程的最后阶段</strong>）<ul><li><strong>分配对象内存空间</strong><br><strong>初始化对象</strong><br><strong>将指针指向刚才分配的内存空间</strong></li></ul></li></ul></li></ul></li><li><strong>执行代码的过程</strong><ul><li><strong>执行引擎</strong>（虚拟机字节码执行引擎）<br>-<strong>虚拟机</strong>是一个相对<strong>物理机</strong>的概念，物理机的执行引擎直接建立在<strong>硬件和操作系统层面</strong>上的，而虚拟机执行引擎则是由<strong>软件自行实现</strong>，因此可以不受制约实现其它指令集格式。<br>-虚拟机执行引擎在执行字节码时通常会有<strong>解释执行</strong>和<strong>编译执行</strong>两种方式（或同时存在）。<strong>输入</strong>字节码二进制流，<strong>处理</strong>过程就是对字节码的解释执行，<strong>输出</strong>执行结果<ul><li><strong><span id="栈帧">栈帧</span></strong>（Java虚拟机以方法作为最基本的执行单位）<ul><li>其中包括了<strong>局部变量表</strong>，<strong>操作数栈</strong>，<strong>方法返回地址</strong>等信息（其大小一开始就已经确定了，固定的）</li><li><strong>局部变量表</strong>：是<strong>变量的存储空间</strong>（存放方法参数和方法内部定义的局部变量，非静态方法第0位为this变量）<br><strong>操作数栈</strong>：是一个先进后出的栈（栈的最大深度也是一开始就确定了）</li></ul></li><li><strong>方法调用</strong>（只是<strong>确定调用版本</strong>，<strong>并未执行</strong>方法）<ul><li><strong>静态解析</strong>：针对的是<strong>编译期就可知调用版本</strong>的方法，主要是<strong>静态方法</strong>（直接与类相关）和<strong>私有方法</strong>（外部不可访问）两类</li><li><strong>分派</strong>（多态的具体体现）：<ul><li><strong>静态分派</strong>：依赖静态类型来决定执行版本的分派（最典型的就是<strong>方法重载</strong>）<br>对于<strong>Human man = new Man()；Human 为静态类型，Man为实际类型</strong><br>其在<strong>编译期</strong>就会由编译器通过<strong>静态类型</strong>和<strong>参数</strong>确定执行版本，被称为多分派类型</li><li><strong>动态分派</strong>：根据对象的实际类型来执行版本的分派（<strong>方法重写和多态</strong>）<br>在<strong>运行期</strong>才能知道方法的<strong>调用目标</strong>（<strong>实际类型</strong>）<br>只会<strong>根据实际类型</strong>进行分派（此时参数类型已经确认），被称为单分派类型</li><li>动态分派<strong>优化</strong>：由于此操作极其频繁，会在方法区中创建一个虚方法表用来代替元数据的查找。</li></ul></li><li>**Reflection和MethodHandle（java.lang.invoke包）**的区别：反射（Reflection）是重量级操作，是对象的全面映射，而后者则只是包含该方法的相关信息，较之是轻量级操作</li></ul></li></ul></li></ul></li></ul></li><li><strong>编译子系统：</strong><ul><li><strong>前端编译优化</strong><ul><li><s>Javac</s></li><li><strong>语法糖</strong><ul><li><strong>泛型</strong>：Java的泛型实现方式为“<strong>类型擦除式泛型</strong>”，即Java中的<strong>泛型只在源码中出现</strong>，编译后的字节码中都会被替换为<strong>裸类型</strong>，并在相应地方插入<strong>强制转换代码</strong>。（目的就是为了兼容旧版本）</li><li><strong>自动装箱、拆箱</strong>：大量的诸如<strong>Integer.valueOf</strong>的方法，在“==”运算或者equals方法中时不会起作用</li><li><strong>for-each的迭代器；条件不成立的分支自动去除；枚举类、Lambda表达式</strong>等等。</li></ul></li></ul></li><li><strong>后端编译优化</strong><ul><li><strong>解释器</strong>：它可以<strong>直接运行</strong>程序，不需要编译；它还可以<strong>节约内存</strong>；且是编译<strong>优化失败</strong>后的底牌。</li><li><strong>即时编译器</strong>（C1，C2编译器）<ul><li>针对的是<strong>热点代码</strong>（即<strong>多次执行的循环体</strong>或者被<strong>多次调用的方法</strong>）<br>当对循环体优化时，会发生<strong>栈上替换</strong>，在方法运行时就将其替换</li><li>热点探测（有两种方式）<ul><li><strong>基于采样</strong>的热点探测：会周期性的查看各个线程的<strong>栈顶</strong>，如果发现某个方法出现<strong>频率过高</strong>，就是热点；其<strong>缺点</strong>就是<strong>无法准确确认</strong>一个方法的热度，容易受<strong>线程阻塞</strong>或者外界执行的因素的<strong>影响</strong>。</li><li><strong>基于计数器</strong>的热点探测：HotSpot为每个方法准备了两个计数器，<strong>方法调用计数器</strong>和<strong>回边计数器</strong>；当有其中一个超过阈值，则为热点。<br><strong>方法调用计数器</strong>：见名知意，<strong>统计方法调用次数</strong>，在默认情况下，它<strong>统计</strong>的不是绝对次数，而是<strong>相对的频率</strong>，当<strong>一定时间</strong>过后，如果还未到阈值，则会<strong>减少一半</strong>（被称为<strong>热度的衰减</strong>）<br><strong>回边计数器</strong>：它的作用是<strong>统计循环中代码执行的次数</strong>，其没有热度衰减，<strong>统计的是绝对次数</strong>。</li></ul></li><li><strong>分层编译</strong>的概念：<ul><li>主要由于即使编译器编译<strong>需要占用资源</strong>，所以为了<strong>平衡其影响</strong>提出了分层编译的功能<br>（客户端编译器，服务端编译器）</li></ul></li></ul></li><li><strong>提前编译器</strong></li><li><strong>优化技术</strong><ul><li><strong>方法内联</strong>：最基础也是最重要的优化，是<strong>其它优化的基础</strong>。通过<strong>将方法中的代码“复制”到调用的位置</strong>，可以去除调用时的成本，同时<strong>为其它优化奠定基础</strong>。<br><strong>虚方法的内联</strong>：非虚方法没有什么问题，但虚方法则很难确定调用者的类型，如果查询到<strong>只有一个版本</strong>，则将此内联称为<strong>守护内联</strong>（<strong>Java</strong>是<strong>动态连接</strong>的，所以有可能<strong>被打破</strong>）；如果是<strong>多个版本</strong>，则会<strong>去调用方法</strong>，但会使用一个<strong>缓存</strong>来缩减调用开销。</li><li><strong>逃逸分析</strong>：它也是<strong>为其它优化提供基础的分析技术</strong>；通过分析<strong>对象</strong>的动态<strong>作用域</strong>，分为方法逃逸，线程逃逸，以及从不逃逸。<br>据此它分为<strong>三种优化方式</strong><ul><li><strong>标量替换</strong>：将其成员变量的访问<strong>恢复原始对象的访问</strong>，它<strong>不允许逃逸到方法外面</strong>。</li><li><strong>栈上分配</strong>：<strong>分配到栈上</strong>，可以省去GC的开销，随着栈帧的出栈而回收，它<strong>不允许逃逸到线程外面</strong>。</li><li><strong>同步消除</strong>：对<strong>不能逃逸到线程外</strong>面的代码<strong>取消同步措施</strong></li></ul></li></ul></li></ul></li></ul></li><li><strong>高效并发：</strong>（<strong>阿姆达尔</strong>（Amdahl）<strong>定理</strong>代替<strong>摩尔定律</strong>成为计算机性能发展的源动力）<ul><li><strong>Java内存模型：</strong><ul><li><strong>三大特性：</strong><br><strong>原子性</strong>：指此操作不可分割和中断的，对于基本数据类型的访问，读写都具备原子性<br><strong>可见性</strong>：指一个线程修改了共享变量时，其它线程能够立即得知这个修改。<br><strong>有序性</strong>：在线程内观察，所有操作都是有序的，而线程外看起来则是无序的，先行发生原则（happens-before原则）</li><li><strong>乱序执行</strong>：<br>处理器会对输入代码进行乱序执行优化，是<strong>机器级别的优化</strong></li></ul></li><li><strong>线程的运行状态</strong><br><strong>①新建</strong>（创建但尚未运行）<br><strong>②运行</strong>（运行中的线程）<br><strong>③无限期等待</strong>（未设置等待时间的线程，等待唤醒动作）<br><strong>④限期等待</strong>（设置等待时间的线程，等待唤醒动作或者时间）<br><strong>⑤阻塞</strong>（与等待的区别是，它在等待获取一个排他锁的释放）<br><strong>⑥结束</strong>（终止后的线程状态）</li><li><strong>互斥同步：</strong>（互斥是方法，同步是目的）<ul><li><strong>synchronized</strong>：<br>这是一种<strong>块结构</strong>的同步语法，会在<strong>同步代码块前后</strong>生成<strong>monitorenter和monitorexit</strong>这两个字节码指令，其需要明确加锁对象（Java中如果没指定了加锁对象，则根据<strong>锁定方法</strong>来判断是<u>对象实例</u>（<strong>实例方法</strong>）还是<u>Class对象</u>（<strong>类方法</strong>））<ul><li><strong>monitorenter</strong>会去获取对象的锁，如果获取成功，<strong>锁的计数器加一</strong>，monitorexit也是如此，所以其是<strong>可重入锁</strong></li></ul></li><li><strong>Lock接口：</strong>（JUC包下的）<strong>非块结构</strong>来实现互斥同步<ul><li><strong>ReentrantLock</strong>：<strong>重入锁</strong>，和synchronized一样也是可重入的，但其多了三大功能：<strong>等待可中断</strong>（等待的线程可以选择<strong>放弃等待</strong>），<strong>公平锁</strong>（可以按照等待顺序依次获得锁，默认不公平的，开启后会使得性能下降），<strong>锁绑定多个条件</strong>（锁对象可以绑定多个<strong>Condition对象</strong>）。</li></ul></li><li><strong>互斥同步</strong>的<strong>主要问题</strong>是进行<strong>线程阻塞和唤醒</strong>所带来的<strong>开销</strong>，所以诞生了<strong>非阻塞的同步</strong>，<strong>CAS</strong>（比较并交换）就是其中之一。CAS存在一个<strong>ABA问题</strong>（可以通过版本号来解决，但一般此问题对程序不会有大影响）。</li></ul></li><li><strong>锁优化：</strong><ul><li><strong>自旋锁</strong>：<br>互斥同步最大的性能开销就是阻塞，同时共享变量的锁定状态一般<strong>不会持续很久</strong>，所以不需要每次都直接等待挂起，而是让其<strong>进行一个忙循环</strong>（<strong>自旋</strong>）。如果<strong>多次自旋成功</strong>，可能会允许自旋的<strong>次数更多</strong>，反之则可能会直接<strong>略过自旋</strong>避免<strong>浪费处理器资源</strong>（<strong>自适应自旋</strong>）。</li><li><strong>偏向锁</strong>：<br>目的为了<strong>消除无竞争下的同步操作</strong>，它会<strong>偏向于第一个获得它的线程</strong>，如果没有竞争，则此线程无需执行同步操作（在竞争激烈的程序中可以关闭此功能提升性能）。（在<strong>对象头</strong>中设置标志位）<strong>一旦有别的线程尝试获取这个对象的锁</strong>，偏向锁就会结束，<strong>转为轻量级锁</strong>。</li><li><strong>轻量级锁</strong>：<br>在<strong>对象没有被锁定时</strong>，虚拟机会为此对象的Mark Word的<strong>拷贝</strong>，然后通过<strong>CAS</strong>来将<strong>Mark Word更新为指向栈帧的指针</strong>，同时将锁标志位<strong>设置为轻量级锁定</strong>；如果<strong>失败</strong>则意味这有其它线程在竞争，此时需要<strong>膨胀成重量级锁</strong>，将指针更新为<strong>互斥量指针</strong>；<strong>释放锁</strong>也是同理，如果<strong>CAS</strong>更新Mark Word<strong>失败</strong>，则需要<strong>唤醒其它被挂起的线程</strong>。</li><li><strong>锁消除</strong>：主要通过<strong>逃逸分析</strong>的支持，如果无法被其它线程访问到，则可以将它们的<strong>同步语句去除</strong>。</li><li><strong>锁粗化</strong>：有些情况下连续的一串操作中会不停的加锁解锁（一些方法调用时），此时虚拟机会将这<strong>一些零散的加锁</strong>操作变成<strong>一个范围的加锁同步</strong>。</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM相关知识点&quot;&gt;JVM相关知识点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JVM
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自动内存管理子系统&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运行时数据区：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法区&lt;/str</summary>
      
    
    
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/categories/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="JVM" scheme="https://stars-at-dawn.github.io/tags/JVM/"/>
    
    <category term="知识梳理" scheme="https://stars-at-dawn.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>力扣45跳跃游戏 II</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode45"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode45</id>
    <published>2025-04-20T08:00:20.000Z</published>
    <updated>2025-04-20T08:06:42.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><hr><p>与另一个（力扣55）十分相似，最短的跳跃距离，<strong>依旧是贪心</strong>，只要让位置跳的尽量远即可<br>真就贪心，想不到那就做不出来，无语，这种题目是真没意思，不过得注意不像上一题只要维护最大值，现在还要维护最大步长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前步长能走的最大值，也即下次的步长</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前步数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stepMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];<span class="comment">//最大步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//超过步长则意味着一步已经走完了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; stepMax) &#123;</span><br><span class="line">                step++;</span><br><span class="line">                stepMax = max;</span><br><span class="line">                max = Math.max(nums[i] + i, max);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没走完则接着找当前步长能走的最远距离</span></span><br><span class="line">                max = Math.max(nums[i] + i, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>改动态规划实现</strong>：</p><p>突发奇想改了个动态规划，不过可惜，超时了，感觉有优化空间，不过懒得管了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//横坐标索引 纵坐标剩余步数 </span></span><br><span class="line">        <span class="comment">//剩余步数其实大小也不应该是n，不过我也不知道写啥</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[n - <span class="number">1</span>][i] = <span class="literal">true</span>;<span class="comment">//到达位置，即 剩余步数为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>; step &lt; n; step++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> n - <span class="number">2</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums[index]; i++) &#123;</span><br><span class="line">                    <span class="comment">//这里应该可以优化赋值阶段的工作</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[index + i][step - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[index][step] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][i]) <span class="keyword">return</span> i;<span class="comment">//从上到下返回第一个（最小步数）可以到达的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;0 索引&lt;/strong&gt;整数数组 &lt;code&gt;nums&lt;/code&gt;。初始位置为 &lt;code&gt;nums[0]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每个元</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣55跳跃游戏</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode55"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode55</id>
    <published>2025-04-20T06:38:57.000Z</published>
    <updated>2025-04-20T06:49:48.626Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><hr><p>经典跳跃小游戏，简单的dp缓存表最好想了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="comment">//缓存表</span></span><br><span class="line"><span class="comment">//dp2是和下面优化的代码有所区分无意义，int类型是因为存三个状态：能到，不能到，未缓存</span></span><br><span class="line"><span class="type">int</span>[] dp2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> f(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="comment">//basecase</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp2[index] != <span class="number">0</span>) <span class="keyword">return</span> dp2[index] &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index + nums[index] &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums[index]; i++) &#123;</span><br><span class="line">            res = res | f(nums, index + i);<span class="comment">//去遍历是否有能到的</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp2[index] = res ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>改动态规划实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];<span class="comment">//dp表</span></span><br><span class="line">        dp[nums.length - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//从后往前填写</span></span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;<span class="comment">//如果可以直接到达则返回true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= i + nums[i]; j++) &#123;</span><br><span class="line">                    <span class="comment">//不能的则去遍历能到的位置中有人能达到吗</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">                        dp[i] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//剪枝优化：如果不行，那他的后面也不用看了</span></span><br><span class="line">                        j += nums[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>额外的，贪心实现：</strong></p><p>既然题目要求我们到达最后一个，实际上就是要我们走的越远越好，即当前位置能跳的距离和前面最远的距离的较大值即为当前位置的最远距离，只要大于数组长度就返回<code>true</code>，反之到不了就返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下 非常短    </span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump3</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;<span class="comment">//当前位置能去的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            max = Math.max(max, i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (max&gt;=nums.length-<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//max能到了，就返回结束程序运行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣189 轮转数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode189"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode189</id>
    <published>2025-04-19T14:01:04.000Z</published>
    <updated>2025-04-20T06:38:48.721Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><hr><p>题目非常简单，分成两段数组分别赋值即可，不过注意是检查的依旧是原数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        k = k % nums.length;<span class="comment">//超过一圈后都是循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - k; i++) &#123;</span><br><span class="line">            nums[i + k] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i - nums.length + k] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>空间复杂度优化</strong></p><p>又是进行复杂度优化，好吧，挺困难的，想了半天憋了个这还写不出来233 &gt;:<br>无所谓了，这里是用循环替代来进行替换（替换到最后会回到原位）<br>不过这里用最大公因数限制次数确实是没想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gcd</span> <span class="operator">=</span> gcd(k, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gcd; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> nums[i];<span class="comment">//为了保留第一个参数</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + k) % n;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t2</span> <span class="operator">=</span> nums[next];</span><br><span class="line">                nums[next] = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (current != i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y &gt; <span class="number">0</span> ? gcd(y, x % y) : x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>不过还有个大神方法：数组反转</strong><br>将全部数组反转，再分别反转前k个和后k个即可完成此效果（因为<strong>反转后即使只有部分再反转，其中的相对顺序保持不变</strong>，根据轮转的效果来看也确实是相对顺序不变，只是分了两块而已）（确实是想不到啊~~）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate5</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k %= n;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//数组前后指针的数字交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">            nums[j--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，将数组中的元素向右轮转 &lt;code&gt;k&lt;/code&gt; 个位置，其中 &lt;code&gt;k&lt;/code&gt; 是非负数。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目非常简单，分成两段数组</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣169 合并两个有序数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode169"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode169</id>
    <published>2025-04-18T12:44:18.000Z</published>
    <updated>2025-04-18T12:55:09.673Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><hr><p>题目非常简单，让我们找出现次数最多的数，使用Hash表应该是最好想到的，不多赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];<span class="comment">//特殊情况，直接返回</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i])) map.put(nums[i], <span class="number">1</span>);<span class="comment">//不存在创建添加</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(nums[i]) &gt; nums.length / <span class="number">2</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>空间复杂度优化</strong>（<strong>难度比较高，感觉有点像贪心</strong>）</p><p>但题目让我们尝试<strong>设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法</strong>解决此问题。而上面的空间复杂度为 O(N)所以我们要优化，只用有限的变量去实现这个记录最大次数，也就是其他参数应该是“无状态的”，至少应该不需要我们去解决，笔者尝试几分钟并没找到解法，看答案才知道，所以给大家写一下我的理解以及怎样有可能能想到这些方法。</p><p>这里要用到的是<strong>摩尔投票</strong>的算法：<br>题目告诉我们有个数出现次数超过n/2，我们称它X，而所谓的算法就是指如果数据进行投票，非X则投反票，X投正票，最后的投票一定是正的。（投票本身不重要，重要的是思想，应该怎样<strong>量化这些数据</strong>）</p><p>如果我指定一个数作为基准，当经过一轮投票后为0，则这轮有一半为此数，但有两种情况：<br><strong>数刚好就X，那无所谓，对最后的结果没影响</strong><br>否则，那此时X可能在另外的数中，但对后面却不影响，因为<strong>最多失去一半X，但同时失去的还有一半其他数</strong>（<strong>由于X的次数已经限定了大于一半，甚至没有等于 233，所以这个分支不会出现在最后一轮</strong>）<br>据此我们可知，<strong>最后一轮我们的选择必定刚好就是X</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement3</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//每一轮假定的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">votes</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//量化其他数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) x = num;<span class="comment">//如果为0 则开启下一轮</span></span><br><span class="line">            votes += x == num ? <span class="number">1</span> : -<span class="number">1</span>; <span class="comment">//数据进行投票</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个大小为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其中的多数元素。多数元素是指在数组中出现次数 &lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/c</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣80 删除有序数组中的重复项 II</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode80"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode80</id>
    <published>2025-04-18T01:51:04.000Z</published>
    <updated>2025-04-18T01:59:40.755Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><ul><li><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p></li></ul><hr><p>与leetcode26优化后的结果差不多：<br>我们看看能不能优化一下，依旧是大小不重要，所以依旧在原数组上进行修改遍历，我们可以通过<strong>记录当前应该去重的数据数量</strong>来确定当前数据<strong>如果不重复应该移动的位置</strong>，不过题目要求是重复两次以上，所以额外再加一个变量记录重复次数。</p><p>这样分析会有三种情况</p><p><strong>当前数据位置与索引位置相等：重复次数+1</strong></p><p>​<strong>且数据重复次数大于两次：则应该去重的数量+1</strong><br>​<strong>否则少于两次应该保留：即需要移动数据</strong></p><p><strong>当前数据位置与索引位置不相等：重复次数重置为1，保留（移动）数据</strong></p><p><strong><u>注意的是：移动数据的目的就是为了保留此数据</u></strong>，因为后面的数据不参与答案校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//重复的数据数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//重复次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - res - <span class="number">1</span>]) &#123;</span><br><span class="line">                count++;<span class="comment">//重复次数+1</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    res++;<span class="comment">//重复次数大于两次：要去重的数量+1</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i - res] = nums[i];<span class="comment">//少于两次重复次数应该移动数据进行保留</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i - res] = nums[i];<span class="comment">//不相等，移动数据进行保留</span></span><br><span class="line">                count = <span class="number">1</span>;<span class="comment">//重置重复次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给你一个有序数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣26 合并两个有序数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode26"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode26</id>
    <published>2025-04-18T01:21:12.000Z</published>
    <updated>2025-04-18T01:21:14.021Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><hr><p>创建一个新数组遍历去重就不多说啦<br>我们看看能不能优化一下，依旧是大小不重要，所以依旧在原数组上进行修改遍历，我们可以通过记录当前重复的数据数量来确定当前数据如果不重复应该移动的位置，比如重复了两个数，那么这个位置未重复的数应该前移两个</p><p><strong>注意的是：</strong><br>记录的是当前重复的数据数所以返回时应该用总数减去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//重复的数据数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - count - <span class="number">1</span>]) count++;<span class="comment">//重复+1</span></span><br><span class="line">            <span class="keyword">else</span> nums[i - count] = nums[i];<span class="comment">//非重复移动（没有重复数则原地赋值也不会出错）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - count; <span class="comment">//总数减去重复数即为非重复数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你**&lt;a href=&quot;http://baike.baidu.com/item/%E5%8E%9F%E5%</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣27 移除元素</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode27"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode27</id>
    <published>2025-04-18T00:59:47.000Z</published>
    <updated>2025-04-18T00:59:48.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> <strong>移除所有数值等于 <code>val</code> 的元素</strong>。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> <strong>不同的元素的数量</strong>。<br>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><hr><p>简单题，不多赘述；（去创建一个数组遍历我想大家都会）<br>不过由于nums的大小不重要，我们会想到能不能在原数组进行操作？这里可以通过<strong>记录非<code>val</code>的数据的数量</strong>来进行优化</p><p><strong>注意的是：</strong></p><p>count为当前非<code>val</code>的数据数量<br>赋值操作不会覆盖未比较的值（因为count永远比当前索引小）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) </span><br><span class="line">            <span class="keyword">if</span> (num != val) </span><br><span class="line">                nums[count++] = num;<span class="comment">//数据为非val 当前位置赋值 且数量+1</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8E%9F%</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣88 合并两个有序数组</title>
    <link href="https://stars-at-dawn.github.io/posts/leetcode88"/>
    <id>https://stars-at-dawn.github.io/posts/leetcode88</id>
    <published>2025-04-18T00:35:39.000Z</published>
    <updated>2025-04-20T06:38:39.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。<br>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。<br>**注意：**最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><hr><p>经典的<strong>双指针问题</strong>，可以分别从左往右遍历两个数组来按顺序merge<br>简单题，不多赘述</p><p><strong>注意的是：</strong><br>由于校验的是nums1指针指向的数组（不是传统的返回数据校验）<br>所以我们需要修改的是<strong>原指针指向的数组</strong>，开头去创建一个对象复制原数组用做中间量，<strong>原数组当作结果容器</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//nums1是一个指针，对其赋值源对象不会修改，即原调用方无法感知这件事</span></span><br><span class="line">        <span class="type">int</span>[] copyNum1 = Arrays.copyOf(nums1, m);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; m &amp;&amp; j &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copyNum1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                nums1[i + j] = copyNum1[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[i + j] = nums2[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总会有一方未遍历完，继续赋值</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; m; i++) &#123;</span><br><span class="line">            nums1[i + j] = copyNum1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; n; j++) &#123;</span><br><span class="line">            nums1[i + j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给你两个按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排列的整数数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;，另有两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;</summary>
      
    
    
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
    <category term="算法" scheme="https://stars-at-dawn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣" scheme="https://stars-at-dawn.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://stars-at-dawn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>常见打字错误拼音记录</title>
    <link href="https://stars-at-dawn.github.io/posts/b6b3d2a3"/>
    <id>https://stars-at-dawn.github.io/posts/b6b3d2a3</id>
    <published>2024-11-04T01:00:07.000Z</published>
    <updated>2024-11-13T07:03:58.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打字网站推荐">打字网站推荐</h2><p><strong>这个网站不错（免费的还可以自己加文章），大家有空可以来测试一下打字速度！</strong></p><p><a href="https://dazi.91xjr.com/?e57bd12b463dbaaf965fbbe68280069c">https://dazi.91xjr.com/?e57bd12b463dbaaf965fbbe68280069c</a></p><h2 id="前后鼻音">前后鼻音</h2><hr><p><strong>馨 xin</strong> | 温馨 wen xin<br><strong>新 xin  欣 xin  心 xin  信 xin  辛 xin</strong><br><strong>星 xing  兴 xing</strong>  杏 xing</p><p><strong>品 pin  聘 pin  拼 pin  频 pin  贫 pin</strong><br><strong>平 | 评 萍 坪 苹 | ping  屏 ping</strong>  凭 ping  瓶 ping</p><p><strong>今 jin  金 jin  尽 jin 进 jin</strong><br><strong>竟 jing  经 jing</strong></p><p><strong>音 yin  吟 yin</strong>  因 yin  <strong>银 yin</strong> <strong>阴 | 荫 yin</strong><br><strong>应 ying</strong>  英 ying  赢 ying  <strong>影 ying</strong>  荧 ying</p><p><strong>亲 qin</strong>  秦 qin  琴qin<br><strong>青 | 请 清 晴 情 | qing  轻 qing</strong>  庆 qing  氢 qing  卿 qing</p><p><strong>林 | 淋 琳 霖 | lin</strong>  |  <strong>粦 | 麟 鳞 磷 粼 | lin  临 lin  邻 lin</strong><br><strong>令 | 岭 零 领 铃 翎 | ling</strong>  |  <strong>夌 | 凌 陵 绫 | ling  另 ling  灵 ling</strong>  菱 ling</p><hr><p><strong>身 shen  深 shen</strong> 神 shen 伸 shen  甚 shen  慎 shen 绅 shen <strong>什 shen</strong><br><strong>声 sheng  生 sheng  盛 sheng</strong>  圣 sheng  升 sheng  <strong>剩 sheng</strong></p><p><strong>真 zhen</strong>  震 zhen  针 zhen  帧 zhen<br><strong>蒸 zheng  争 | 挣 睁 狰| zheng  正 | 证 政 征 症 怔|zheng</strong></p><p><strong>称 chen | 匀称    cheng | 称呼</strong><br><strong>趁 chen  晨 chen</strong>  沉 chen  <strong>陈 chen  尘 chen</strong>  辰 chen  臣 chen<br><strong>成 cheng  乘 cheng  承 cheng  撑 cheng</strong></p><p><strong>艮 | 跟 根 哏 | gen</strong>  <strong>亘 gen</strong><br><strong>更 | 梗 鲠 哽 | geng</strong>  <strong>耕 geng</strong>  庚 geng  羹 geng</p><p><strong>温 wen 文 wen</strong><br><strong>翁 | 嗡 瓮 | weng</strong></p><p><strong>嫩 nen</strong><br><strong>能 neng</strong></p><p><strong>忍 ren 人 ren 任 ren 仁 ren 刃 | 纫 韧 | ren</strong><br><strong>扔 reng 仍 reng</strong></p><p><strong>盆 | 湓 pen  喷 pen</strong><br><strong>朋 peng  碰 peng</strong></p><p><strong>分 | 粉 份 芬 酚 纷 | fen  奋 fen</strong><br><strong>丰 | 封 沣 | feng  夆 | 峰 蜂 逢 缝 | feng  风 feng  枫 feng</strong></p><hr><p><strong>路 lu 录 lu</strong><br><strong>绿 lv 率 lv 律 lv 屡 lv 虑 lv 缕 lv</strong></p><hr><h2 id="容易错的拼音">容易错的拼音</h2><p><strong>推 tui  堆 dui  丢 diu</strong><br><strong>且 qie  别 bie</strong></p><p><strong>卵 luan</strong> <strong>峦 luan | 峰峦</strong><br><strong>么 me | 多么 duo me  呢 ne  我们 wo men</strong><br><strong>袄 ao | 棉袄 偏颇 pian po</strong><br><strong>怜悯 lián mǐn  冷漠 mo 某 mou</strong><br><strong>呻吟 shen yin</strong> <strong>身影 shen ying</strong> <strong>声音 sheng yin</strong><br><strong>应该 ying gai 因为 yin wei 哽咽 geng ye</strong><br><strong>应当 ying dang 努力 nu li</strong></p><hr><p><strong>E</strong> <strong>R T</strong>    ? \ 都是打字容易出错的</p><hr><h2 id="常错字">常错字</h2><p><strong>身 shen  深 shen 今 jin</strong></p><p><strong>努 nu 很 hen 神 shen</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;打字网站推荐&quot;&gt;打字网站推荐&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个网站不错（免费的还可以自己加文章），大家有空可以来测试一下打字速度！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dazi.91xjr.com/?e57bd12b463dbaa</summary>
      
    
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小知识" scheme="https://stars-at-dawn.github.io/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    <category term="打字" scheme="https://stars-at-dawn.github.io/tags/%E6%89%93%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>马丁·路德·金《我有一个梦想》演讲稿（中英文双版）</title>
    <link href="https://stars-at-dawn.github.io/posts/36b602fd"/>
    <id>https://stars-at-dawn.github.io/posts/36b602fd</id>
    <published>2024-11-04T00:51:20.000Z</published>
    <updated>2024-11-04T01:05:22.956Z</updated>
    
    <content type="html"><![CDATA[<h1>马丁路德金的演讲稿《我有一个梦想》（中英文双版）</h1><p>《我有一个梦想》是1960年代的美国黑人民权运动领袖马丁·路德·金博士一场极为著名演讲的名称，由于他在该次演说中，强力且有说服力地描述他对于黑人与白人有一天能和平且平等共存的远景时，不断重复使用的“I have a dream”一词。演讲在1963年8月28日华盛顿大游行中，于林肯纪念堂前发表。该演讲促使美国国会在1964年通过《1964年民权法案》宣布所有种族隔离和歧视政策为非法政策。</p><h2 id="中文版全文">中文版全文:</h2><h3 id="我有一个梦想">我有一个梦想</h3><p>100年前，一位伟大的美国人签署了解放黑奴宣言，今天我们就是在他的雕像前集会。这一庄严宣言犹如灯塔的光芒，给千百万在那摧残生命的不义之火中受煎熬的黑奴带来了希望。它之到来犹如欢乐的黎明，结束了束缚黑人的漫漫长夜。然而100年后的今天，我们必须正视黑人还没有得到自由这一悲惨的事实。100年后的今天，在种族隔离的镣铐和种族歧视的枷锁下，黑人的生活备受压榨。100年后的今天，黑人仍生活在物质充裕的海洋中一个穷困的孤岛上。100年后的今天，黑人仍然萎缩在美国社会的角落里，并且意识到自己是故土家园中的流亡者。今天我们在这里集会，就是要把这种骇人听闻的情况公诸于众。</p><p>就某种意义而言，今天我们是为了要求兑现诺言而汇集到我们国家的首都来的。我们共和国的缔造者草拟宪法和独立宣言的气壮山河的词句时，曾向每一个美国人许下了诺言，他们承诺给予所有的人以生存、自由和追求幸福的不可剥夺的权利。</p><p>就有色公民而论，美国显然没有实践她的诺言。美国没有履行这项神圣的义务，只是给黑人开了一张空头支票，支票上盖着“资金不足”的戳子后便退了回来。但是我们不相信正义的银行已经破产，我们不相信，在这个国家巨大的机会之库里已没有足够的储备。因此今天我们要求将支票兑现——这张支票将给予我们宝贵的自由和正义的保障。</p><p>我们来到这个圣地也是为了提醒美国，现在是非常急迫的时刻。现在决非侈谈冷静下来或服用渐进主义的镇静剂的时候。现在是实现民主的诺言时候。现在是从种族隔离的荒凉阴暗的深谷攀登种族平等的光明大道的时候，现在是向上帝所有的儿女开放机会之门的时候，现在是把我们的国家从种族不平等的流沙中拯救出来，置于兄弟情谊的磐石上的时候。</p><p>如果美国忽视时间的迫切性和低估黑人的决心，那么，这对美国来说，将是致命伤。自由和平等的爽朗秋天如不到来，黑人义愤填膺的酷暑就不会过去。1963年并不意味着斗争的结束，而是开始。有人希望，黑人只要撒撒气就会满足；如果国家安之若素，毫无反应，这些人必会大失所望的。黑人得不到公民的权利，美国就不可能有安宁或平静，正义的光明的一天不到来，叛乱的旋风就将继续动摇这个国家的基础。</p><p>但是对于等候在正义之宫门口的心急如焚的人们，有些话我是必须说的。在争取合法地位的过程中，我们不要采取错误的做法。我们不要为了满足对自由的渴望而抱着敌对和仇恨之杯痛饮。我们斗争时必须永远举止得体，纪律严明。我们不能容许我们的具有崭新内容的抗议蜕变为暴力行动。我们要不断地升华到以精神力量对付物质力量的崇高境界中去。</p><p>现在黑人社会充满着了不起的新的战斗精神，但是不能因此而不信任所有的白人。因为我们的许多白人兄弟已经认识到，他们的命运与我们的命运是紧密相连的，他们今天参加游行集会就是明证。他们的自由与我们的自由是息息相关的。我们不能单独行动。</p><p>当我们行动时，我们必须保证向前进。我们不能倒退。现在有人问热心民权运动的人，“你们什么时候才能满足？”只要黑人仍然遭受警察难以形容的野蛮迫害，我们就绝不会满足。只要我们在外奔波而疲乏的身躯不能在公路旁的汽车旅馆和城里的旅馆找到住宿之所，我们就绝不会满足。只要黑人的基本活动范围只是从少数民族聚居的小贫民区转移到大贫民区，我们就绝不会满足。只要密西西比仍然有一个黑人不能参加选举，只要纽约有一个黑人认为他投票无济于事，我们就绝不会满足。</p><p>不！我们现在并不满足，我们将来也不满足，除非正义和公正犹如江海之波涛，汹涌澎湃，滚滚而来。</p><p>我并非没有注意到，参加今天集会的人中，有些受尽苦难和折磨，有些刚刚走出窄小的牢房，有些由于寻求自由，曾在居住地惨遭疯狂迫害的打击，并在警察暴行的旋风中摇摇欲坠。你们是人为痛苦的长期受难者。坚持下去吧，要坚决相信，忍受不应得的痛苦是一种赎罪。</p><p>让我们回到密西西比去，回到亚拉巴马去，回到南卡罗来纳去，回到佐治亚去，回到路易斯安那去，回到我们北方城市中的贫民区和少数民族居住区去，要心中有数，这种状况是能够也必将改变的。我们不要陷入绝望而不可自拔。</p><p>朋友们，今天我对你们说，在此时此刻，我们虽然遭受种种困难和挫折，我仍然有一个梦想，这个梦想是深深扎根于美国的梦想中的。</p><p>我梦想有一天，这个国家会站立起来，真正实现其信条的真谛：“我们认为这些真理是不言而喻的，人人生而平等。”</p><p>我梦想有一天，在佐治亚的红山上，从前奴隶的后嗣将能够和奴隶主的后嗣坐在一起，共叙兄弟情谊。</p><p>我梦想有一天，甚至连密西西比州这个正义匿迹，压迫成风，如同沙漠般的地方，也将变成自由和正义的绿洲。我梦想有一天，我的四个孩子将在一个不是以他们的肤色，而是以他们的品格优劣来评价他们的国度里生活。</p><p>我今天有一个梦想。我梦想有一天，亚拉巴马州能够有所转变，尽管该州州长现在仍然满口异议，反对联邦法令，但有朝一日，那里的黑人男孩和女孩将能与白人男孩和女孩情同骨肉，携手并进。</p><p>我今天有一个梦想。我梦想有一天，幽谷上升，高山下降；坎坷曲折之路成坦途，圣光披露，满照人间。这就是我们的希望。我怀着这种信念回到南方。有了这个信念，我们将能从绝望之岭劈出一块希望之石。有了这个信念，我们将能把这个国家刺耳的争吵声，改变成为一支洋溢手足之情的优美交响曲。 有了这个信念，我们将能一起工作，一起祈祷，一起斗争，一起坐牢，一起维护自由；因为我们知道，终有一天，我们是会自由的。</p><p>在自由到来的那一天，上帝的所有儿女们将以新的含义高唱这支歌：“我的祖国，美丽的自由之乡，我为您歌唱。您是父辈逝去的地方，您是最初移民的骄傲，让自由之声响彻每个山岗。”</p><p>如果美国要成为一个伟大的国家，这个梦想必须实现。让自由之声从新罕布什尔州的巍峨的崇山峻岭响起来！让自由之声从纽约州的崇山峻岭响起来！让自由之声从科罗拉多州冰雪覆盖的落基山响起来！让自由之声从加利福尼亚州蜿蜒的群峰响起来！不仅如此，还要让自由之声从佐治亚州的石岭响起来！让自由之声从田纳西州的了望山响起来！ 让自由之声从密西西比的每一座丘陵响起来！让自由之声从每一片山坡响起来。</p><p>当我们让自由之声响起来，让自由之声从每一个大小村庄、每一个州和每一个城市响起来时，我们将能够加速这一天的到来，那时，上帝的所有儿女，黑人和白人，犹太教徒和非犹太教徒，耶稣教徒和天主教徒，都将手携手，合唱一首古老的黑人灵歌：“终于自由啦！终于自由啦！感谢全能天父，我们终于自由啦！”</p><h2 id="英文版全文">英文版全文:</h2><h3 id="I-Have-a-Dream">I Have a Dream</h3><p>I am happy to join with you today in what will go down in history as the greatest demonstration for freedom in the history of our nation.</p><p>Five score years ago, a great American, in whose symbolic shadow we stand today, signed the Emancipation Proclamation. This momentous decree came as a great beacon light of hope to millions of Negro slaves who had been seared in the flames of withering injustice. It came as a joyous daybreak to end the long night of their captivity.</p><p>But one hundred years later, the Negro still is not free. One hundred years later, the life of the Negro is still sadly crippled by the manacles of segregation and the chains of discrimination. One hundred years later, the Negro lives on a lonely island of poverty in the midst of a vast ocean of material prosperity. One hundred years later, the Negro is still languished in the corners of American society and finds himself an exile in his own land. And so we’ve come here today to dramatize a shameful condition.</p><p>In a sense we’ve come to our nation’s capital to cash a check. When the architects of our republic wrote the magnificent words of the Constitution and the Declaration of Independence, they were signing a promissory note to which every American was to fall heir. This note was a promise that all men, yes, black men as well as white men, would be guaranteed the “unalienable Rights” of “Life, Liberty and the pursuit of Happiness.” It is obvious today that America has defaulted on this promissory note, insofar as her citizens of color are concerned. Instead of honoring this sacred obligation, America has given the Negro people a bad check, a check which has come back marked “insufficient funds.”</p><p>But we refuse to believe that the bank of justice is bankrupt. We refuse to believe that there are insufficient funds in the great vaults of opportunity of this nation. And so, we’ve come to cash this check, a check that will give us upon demand the riches of freedom and the security of justice.</p><p>We have also come to this hallowed spot to remind America of the fierce urgency of Now. This is no time to engage in the luxury of cooling off or to take the tranquilizing drug of gradualism. Now is the time to make real the promises of democracy. Now is the time to rise from the dark and desolate valley of segregation to the sunlit path of racial justice. Now is the time to lift our nation from the quicksands of racial injustice to the solid rock of brotherhood. Now is the time to make justice a reality for all of God’s children.</p><p>It would be fatal for the nation to overlook the urgency of the moment. This sweltering summer of the Negro’s legitimate discontent will not pass until there is an invigorating autumn of freedom and equality. Nineteen sixty-three is not an end, but a beginning. And those who hope that the Negro needed to blow off steam and will now be content will have a rude awakening if the nation returns to business as usual. And there will be neither rest nor tranquility in America until the Negro is granted his citizenship rights. The whirlwinds of revolt will continue to shake the foundations of our nation until the bright day of justice emerges.</p><p>But there is something that I must say to my people, who stand on the warm threshold which leads into the palace of justice: In the process of gaining our rightful place, we must not be guilty of wrongful deeds. Let us not seek to satisfy our thirst for freedom by drinking from the cup of bitterness and hatred. We must forever conduct our struggle on the high plane of dignity and discipline. We must not allow our creative protest to degenerate into physical violence. Again and again, we must rise to the majestic heights of meeting physical force with soul force.</p><p>The marvelous new militancy which has engulfed the Negro community must not lead us to a distrust of all white people, for many of our white brothers, as evidenced by their presence here today, have come to realize that their destiny is tied up with our destiny. And they have come to realize that their freedom is inextricably bound to our freedom.</p><p>We cannot walk alone.</p><p>And as we walk, we must make the pledge that we shall always march ahead.</p><p>We cannot turn back.</p><p>There are those who are asking the devotees of civil rights, “When will you be satisfied?” We can never be satisfied as long as the Negro is the victim of the unspeakable horrors of police brutality. We can never be satisfied as long as our bodies, heavy with the fatigue of travel, cannot gain lodging in the motels of the highways and the hotels of the cities. <strong>We cannot be satisfied as long as the negro’s basic mobility is from a smaller ghetto to a larger one. We can never be satisfied as long as our children are stripped of their self-hood and robbed of their dignity by signs stating: “For Whites Only.”</strong> We cannot be satisfied as long as a Negro in Mississippi cannot vote and a Negro in New York believes he has nothing for which to vote. No, no, we are not satisfied, and we will not be satisfied until “justice rolls down like waters, and righteousness like a mighty stream.”</p><p>I am not unmindful that some of you have come here out of great trials and tribulations. Some of you have come fresh from narrow jail cells. And some of you have come from areas where your quest – quest for freedom left you battered by the storms of persecution and staggered by the winds of police brutality. You have been the veterans of creative suffering. Continue to work with the faith that unearned suffering is redemptive. Go back to Mississippi, go back to Alabama, go back to South Carolina, go back to Georgia, go back to Louisiana, go back to the slums and ghettos of our northern cities, knowing that somehow this situation can and will be changed.</p><p>Let us not wallow in the valley of despair, I say to you today, my friends.</p><p>And so even though we face the difficulties of today and tomorrow, I still have a dream. It is a dream deeply rooted in the American dream.</p><p>I have a dream that one day this nation will rise up and live out the true meaning of its creed: “We hold these truths to be self-evident, that all men are created equal.”</p><p>I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood.</p><p>I have a dream that one day even the state of Mississippi, a state sweltering with the heat of injustice, sweltering with the heat of oppression, will be transformed into an oasis of freedom and justice.</p><p>I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character.</p><p>I have a dream today!</p><p>I have a dream that one day, down in Alabama, with its vicious racists, with its governor having his lips dripping with the words of “interposition” and “nullification” – one day right there in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers.</p><p>I have a dream today!</p><p>I have a dream that one day every valley shall be exalted, and every hill and mountain shall be made low, the rough places will be made plain, and the crooked places will be made straight; &quot;and the glory of the Lord shall be revealed and all flesh shall see it together.&quot;2</p><p>This is our hope, and this is the faith that I go back to the South with.</p><p>With this faith, we will be able to hew out of the mountain of despair a stone of hope. With this faith, we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood. With this faith, we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day.</p><p>And this will be the day – this will be the day when all of God’s children will be able to sing with new meaning:</p><p>My country 'tis of thee, sweet land of liberty, of thee I sing. Land where my fathers died, land of the Pilgrim’s pride, From every mountainside, let freedom ring!</p><p>And if America is to be a great nation, this must become true.</p><p>And so let freedom ring from the prodigious hilltops of New Hampshire.</p><p>Let freedom ring from the mighty mountains of New York.</p><p>Let freedom ring from the heightening Alleghenies of Pennsylvania.</p><p>Let freedom ring from the snow-capped Rockies of Colorado.</p><p>Let freedom ring from the curvaceous slopes of California.</p><p>But not only that:</p><p>Let freedom ring from Stone Mountain of Georgia.</p><p>Let freedom ring from Lookout Mountain of Tennessee.</p><p>Let freedom ring from every hill and molehill of Mississippi.</p><p>From every mountainside, let freedom ring.</p><p>And when this happens, and when we allow freedom ring, when we let it ring from every village and every hamlet, from every state and every city, we will be able to speed up that day when all of God’s children, black men and white men, Jews and Gentiles, Protestants and Catholics, will be able to join hands and sing in the words of the old Negro spiritual:</p><p>Free at last! Free at last!</p><p>Thank God Almighty, we are free at last!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;马丁路德金的演讲稿《我有一个梦想》（中英文双版）&lt;/h1&gt;
&lt;p&gt;《我有一个梦想》是1960年代的美国黑人民权运动领袖马丁·路德·金博士一场极为著名演讲的名称，由于他在该次演说中，强力且有说服力地描述他对于黑人与白人有一天能和平且平等共存的远景时，不断重复使用的“I ha</summary>
      
    
    
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="推荐" scheme="https://stars-at-dawn.github.io/tags/%E6%8E%A8%E8%8D%90/"/>
    
    <category term="书籍" scheme="https://stars-at-dawn.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
